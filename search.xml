<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于SpringMVC的url-pattern]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%85%B3%E4%BA%8ESpringMVC%E7%9A%84url-pattern%2F</url>
    <content type="text"><![CDATA[记录在学习spring MVC中遇到的一个坑：controller里面定义的内容无法访问，报错404。最后发现是web.xml配置文件里面的一个小错误，在这里做一个记录。 在Intelli IDEA中初始化一个springMVC项目以后，web.xml的内容如下： 图1 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 然后在controller中定义了一个页面跳转： 12345678910@Controller@RequestMapping("/")public class HelloMVCController &#123; @RequestMapping(value = "/hello", method = RequestMethod.GET) public String printWelcome(ModelMap model) &#123; model.addAttribute("msg", "Spring MVC Hello World"); model.put("content", "This is my first spring mvc web!"); return "hello"; &#125;&#125; servlet.xml中也定义了文件位置： 1234567&lt;!--对应src下的包名，需要自己新建--&gt; &lt;context:component-scan base-package="com.spring.mvc" /&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 这个配置是配置JSP页面的位置，按照你自己的配置来配 --&gt; &lt;property name="prefix" value="/WEB-INF/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; 然而每次只能访问到 localhost:8080,显示的内容是WEB-INF目录下的index.jsp，手动在url中加上“/hello”,就报错404，十分绝望。 其实是在web.xml中的 &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 出了问题，改为 &lt;url-pattern&gt;/&lt;/url-pattern&gt; 就可以了！ ①：&lt;url-pattern&gt;/&lt;/url-pattern&gt; 会匹配到/login这样的路径型url，不会匹配到模式为*.jsp这样的后缀型url②：&lt;url-pattern&gt;/*&lt;/url-pattern&gt; 会匹配所有url：路径型的和后缀型的url(包括/login,*.jsp,*.js和*.html等) ①：地址为 localhost:8080/login , /login 返回login.jsp 访问去Controller下的/login 跳转到相应的视图login.jsp ②：访问的地址为 localhost:8080/login/ ，/login 返回login.jsp 访问去Controller下的/login,跳转到login.jsp ，然后进过dispatchservlet的时候，由于是/* ，又会以localhost:8088/login/login.jsp 去请求Controller ,那么如果Controller没有 /login/login.jsp 的Mapping映射，则会报404 错误！]]></content>
      <categories>
        <category>spring MVC</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring MVC</tag>
        <tag>maven</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ SLT学习笔记]]></title>
    <url>%2F2018%2F07%2F19%2FC-SLT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[感觉自己敲了很久的C++，每次做算法题目的时候，依然还停留在C的水平，这次系统的学习一下C++ STL 中的数据结构和容器。 什么是STL？STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。 STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组； STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效； 从逻辑层次来看，在STL中体现了泛型化程序设计的思想，引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代子（iterator）等。与OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术；从实现层次看，整个STL是以一种类型参数化的方式实现的，这种方式基于一个在早先C++标准中没有出现的语言特性–模板（template）。 总之，C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件： 组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。 stringC++ 标准库中的string表示可变长的字符串，它在头文件string里面。 比C语言中的char用起来要方便很多！ 常用函数汇总： 12345678910111213141516171819202122getline(cin,s) //读取一行字符串赋给s，（可以带空格），返回字符串ss.empty() //s为空返回true，否则返回falses.size() //返回s中字符的个数s[n] //返回s中第n个字符的值，位置从0开始计数s1 + s2 //返回s1和s2连接后的结果s1 = s2 //用s2的副本代替s1中原来的字符s1 == s2 //判断s1和s2是否完全相等（对大小写敏感）s1 != s2 //不相等&lt;,&lt;=,&gt;,&gt;= //利用字符在字典中的顺序进行比较，且对字母的大小写敏感str.find("ab"); //返回字符串ab在str的位置str.substr(3); //返回str[3]及以后的子串str.substr(2,4); //返回str[2]~str[2+(4-1)]子串(即从[2]开始4个字符组成的字符串)str.replace(2, 4, "ab"); //返回把 [2]~[2+(4-1)] 的内容替换为 "ab" 后的新字符串str.replace(2, 4, "abcd", 3); //返回把 [2]~[2+(4-1)] 的内容替换为 "abcd" 的前3个字符后的新字符串str.insert(2, "ab"); //从 [2] 位置开始添加字符串 "ab"，并返回形成的新字符串str.insert(2, "abcd", 3); //从 [2] 位置开始添加字符串 "abcd" 的前 3 个字符，并返回形成的新字符串str.insert(2, "abcd", 1, 3); //从 [2] 位置开始添加字符串 "abcd" 的前 [2]~[2+(3-1)] 个字符，并返回形成的新字符串str.erase(3); //删除 [3] 及以后的字符，并返回新字符串str.erase(3, 5); //删除从 [3] 开始的 5 个字符，并返回新字符串str1.swap(str2); //把 str1 与 str2 交换transform(str.begin(),str.end(),str.begin(),::tolower); //把字符串全部转换为小写字母transfrom(str.begin(),str.end(),str.begin(),::toupper); //把字符串全部转换为大写字母 声明需要引入头文件&lt; string &gt; ,既然是C++，就还要引入头文件&lt; iostream &gt; 和using namespace std; 123456#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string s;//声明一个string 对象string ss[10];//声明一个string对象的数组 string的io操作使用cin读入字符串时，遇到空白就停止读取。也就是说一句话只能读到空格前面的内容。怎么读入一个句子呢？ 123string str；getline(cin,str);cout&lt;&lt;str&lt;&lt;endl; string的比较（字典顺序）12345678910111213141516string PPAP[] = &#123;"I", "have", "a", "pen", "an", "apple", "um", "apple-pen"&#125;;sort(PPAP, PPAP + 8);for(int i = 0; i &lt; 8; i++)&#123; cout &lt;&lt; PPAP[i] &lt;&lt; endl;&#125;/*输出结果：Iaanappleapple-penhavepenum*/ 遍历字符串在C语言中我都是用下标或者指针来访问数组元素，而在C++里，有个新奇的东西叫做迭代器iterator，我们可以使用它来访问容器元素。 12345678910111213141516171819string str("hello world");for(string::iterator it=str.begin();it!=str.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;endl;&#125;/*输出结果：helloworld*/ 查找子字符串问题string提供了一系列find查找子字符串的函数。最好用的还是find( )函数，返回在字符串中第一次出现的位置，位置变量的定义方式是 string::size_type ,如果没有找到，函数的返回值是string::npos，对应的位置变量是一个很大的常数。 如果用int 定义位置变量，也可以正常使用。如果没有找到，用int定义的位置变量为-1。 1234567891011121314151617#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int main()&#123; string::size_type position;//教程里面都是这样定义变量，但是我试过用int也可以正常使用 //int position; string a,b; cin&gt;&gt;a&gt;&gt;b; position = a.find(b);//在a中查找b cout&lt;&lt;position&lt;&lt;endl; if(a.find(b)==string::npos)//没有找到，返回string::npos cout&lt;&lt;"不存在！"&lt;&lt;endl; return 0;&#125; 还有一个字母转换的函数，把所有的大写字母都转换为小写字母： 1transform(str.begin(),str.end(),str.begin(),::tolower); 把所有字母转换成大写字母： 1transform(s.begin(), s.end(), s.begin(), ::toupper); vectorC++ STL中的verctor好比是C语言中的数组，但是vector又具有数组没有的一些高级功能。与数组相比，vector就是一个可以不用再初始化就必须制定大小的边长数组，当然了，它还有许多高级功能。 要想用vector首先得包含头文件vector。 1#include&lt;vector&gt; 初始化如果vector的元素类型是int，默认初始化为0；如果vector元素类型为string，则默认初始化为空字符串。 1234567vector&lt;int&gt; v1(10, 12); //10个元素，每个元素值都是12vector&lt;int&gt; v2(10); //10个元素，每个元素值都是0vector&lt;int&gt; v3; //0个元素vector&lt;string&gt; v4(10, "hi"); //10个元素，每个元素值都是“hi”vector&lt;string&gt; v5&#123;10, "hi"&#125;; //10个元素，每个元素值都是“hi”vector&lt;string&gt; v6&#123;10&#125;; //10个元素，每个元素值都是“”vector&lt;vector&lt;int&gt; &gt;; //注意空格。这里相当于二维数组int a[n][n]; 添加元素使用push_back加入元素，并且这个元素是被加在数组尾部的。 1234for(int i = 0;i &lt; 20; i++)&#123; v.push_back(i);&#125; 注意：只能对已存在的元素进行赋值或者修改操作，如果是要加入新元素，务必使用push_back。push_back的作用有两个：告诉编译器为新元素开辟空间、将新元素存入新空间里。 比如下面的代码是错误的，但是编译器不会报错，就像是数组越界： 12vector&lt;int&gt; vec;vec[0] = 1; //错误！ 基本操作123456789v.empty(); //v为空返回truev.size(); //v中元素个数v[n]; //返回v中位置为n的元素v1 = v2; //把v1中的元素替换为v2中元素的副本。v.resize(n); //重新调整vector容量大小为nv.push_back(t); //将t插入到v的末尾v.pop_back(t); //删除vector尾部的对象v.erase(); //删除一个或多个元素v.clear(); //删除所有的元素 遍历使用迭代器来访问元素： 12345678910111213vector&lt;string&gt; v6 = &#123; "hi","my","name","is","lee" &#125;;for (vector&lt;string&gt;::iterator iter = v6.begin(); iter != v6.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl;&#125;/*输出结果：himynameislee*/ set其实set的大部分操作是与vector类似的，不过set不支持随机访问，必须要使用迭代器去访问。由于set放入一个元素就会调整这个元素的位置，把它放到合适的位置，所以set中只有一个insert插入操作。 set输出的集合中的元素是按字母大小顺序排列的，而且每个值都不重复。如果cin重复值，并不会真正存入。 输出时，必须用迭代器遍历输出每一个元素。 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;string&gt; strset; set&lt;string&gt;::iterator iter; strset.insert("apple"); strset.insert("orange"); strset.insert("grapes"); strset.insert("grapes"); for(iter=strset.begin();iter!=strset.end();iter++) &#123; cout&lt;&lt;*iter&lt;&lt;endl; &#125;&#125; listlist就是链表，list是一个双向链表，双向链表的优点是插入和删除元素都比较快捷，缺点是不能随机访问元素。 1234567891011#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;int main()&#123; list&lt;int&gt; a=&#123;1,2,3,4,3,6,8,2,1&#125;; for(list&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) cout&lt;&lt;*it&lt;&lt;" "; cout&lt;&lt;endl; return 0;&#125; list的排序方式和algorithm的略有不同： 123a.sort();for(list&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) cout&lt;&lt;*it&lt;&lt;endl;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 搭建Spring MVC环境]]></title>
    <url>%2F2018%2F07%2F17%2FIntelliJ-IDEA-%E6%90%AD%E5%BB%BASpring-MVC%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[记录在IntelliJ IDEA中创建Spring MVC的web项目的全过程，与Maven项目的方法不同，这个需要手动导入jar包。 这种普通的方法比Maven的使用要稍微简单一些，但是熟练之后，还是Maven比较方便。 新建项目File –&gt; New –&gt; Project，最上面是填java JDK安装路径的，如果以前使用Idea编辑器，就会自动帮你选上。选择Spring MVC，下面有两个选项可以选，“use library”就是需要选择本地的依赖包，而“download”就是在生成项目的时候就下载Spring MVC的包，如果是初次创建Spring MVC的项目，就选择“download”。 填写项目名称和项目存储的位置： 点击Finsh，项目就创建完成了。 创建好后的项目目录如下图，lib中已经自动导入了java的包和Spring MVC的包： 修改代码文件修改index.jsp文件index.jsp文件就是等会运行时，显示在浏览器中的界面，初始代码如下： 上面一部分是注释，包含项目的基本信息，中间是空的，可以把&lt; title &gt; 中间改为你想要的文字，例如“SpringMVC”，&lt; body &gt;中间的内容就是正文内容，也可以随意添加，例如改为“Hello World!”,最后的代码如下图： 新增一个控制器HelloMVCController.java首先在src目录下新建一个包，我这里把它命名为 com.spring.mvc ： 然后在这个包下，新增一个类，命名为HelloMVCController ： 文件结构如下： 编辑HelloMVCController.java，代码如下： 123456789101112131415package com.spring.mvc;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class HelloMVCController &#123; @RequestMapping(value="/hello",method = RequestMethod.GET) public String printWelcome(ModelMap model) &#123; model.addAttribute("msg", "Spring 3 MVC Hello World"); return "hello"; &#125;&#125; 修改 dispatcher-servlet.xml 文件dispatcher-servlet.xml文件在web/WEB-INF文件夹下，打开替换为一下代码： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!--对应src下的报名，需要自己新建--&gt; &lt;context:component-scan base-package="com.spring.mvc" /&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix"&gt; &lt;!-- 这个配置是配置JSP页面的位置，按照你自己的配置来配 --&gt; &lt;value&gt;/WEB-INF&lt;/value&gt; &lt;/property&gt; &lt;property name="suffix"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 部署项目在上方菜单栏Run-&gt;Edit Configurations ： 点击左上角的”+”号，选择Tomcat Server，(如果没有请选择最下方的33 items more，找到Tomcat Server)，再选择Local，点击 Application server 右边的 Configure，导入Tomcat 目录： 切换到Deployment标签，再点击右边的”+”号，添加一个Artifact. 选择第二个：war exploded，点击OK，这样，该项目就已经部署到了Tomcat中. 点击OK，这时整个Tomcat就配置好了。点击右上角的运行符号： 这时，发现Artifact报错了： 先暂停运行： 修正错误打开 Project Structure： 选择 Artifacts–&gt;Output Layout ，看到右边有两个包，点击右键，选择第一个Put into/WEB-INF/lib，两个包都要这样操作。 完成后，应该是这样的页面： 点击OK，再次运行，就可以成功部署了，浏览器会自动打开并跳转到 localhost:8080，内容就是index.jsp中所写的。 大功告成！]]></content>
      <categories>
        <category>spring MVC</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring MVC</tag>
        <tag>maven</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA创建Spring MVC的Maven项目]]></title>
    <url>%2F2018%2F07%2F17%2FMVC%E7%9A%84Maven%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[记录在IntelliJ IDEA中创建Spring MVC的Maven项目。 创建Maven Web项目菜单File-&gt;New Project可进入如图界面，首先选择左边栏Maven，再配置JDK的路径(如果之前添加了JDK的话会自动填充，如未添加点击旁边的New将JDK目录导入即可)。勾选”Create from archetype”，然后选中maven-archetype-webapp，点Next，进入如下界面： 点击next，需要输入GroupID，ArtifactID，Version是自带的版本，暂时不用改。 点击next，填写Maven的配置，配置文件和本地仓库都可以不填。 点击next，填写项目名称和项目保存位置，点击Finsh。 maven会在后台生成web项目，这需要等待一定的时间，视网络环境而定。 选择右边红框的Enable-Auto- Import，这样就可以在每次修改pom.xml后，自动的下载并导入jar包。 下图展示了初始的文件结构： 我们可以看到，目录结构并不是严格的maven格式,因为少了java源码文件夹 。 首先在main文件夹下创建一个文件夹，名称为java ： 将java文件夹标识为Source Root，之后文件夹会变成蓝色，就表明设置成功了 ： 再在main文件夹下创建一个文件夹，名称为recources ，将recources 文件夹标识为recources Root，文件图标也会更换： Maven自动导入jar包现在已经创建好了一个Maven项目，但是还需要给Maven添加依赖。 Maven所做的工作就是自动把你需要的jar包下载到本地，然后关联到项目中来。maven的所有jar包都是保存在几个中央仓库里面的，其中一个最常用的是Maven Repository，即，你需要什么jar包，它就会从仓库中拿给你。那么如何告诉maven需要什么jar包呢？我们看看工程目录，能找到一个pom.xml文件（这个文件在刚创建好项目时就已经展现在了大家面前），maven就是靠它来定义需求的，初始时是这样子的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.cici&lt;/groupId&gt; &lt;artifactId&gt;maven_mvc_test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;maven_mvc_test Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;maven_mvc_test&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.20.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 可以看到，这里面已经自动生成了我们之前定义的本项目的groupId等信息，这些信息是该项目的标识，我们不要去改动它们。重点看 &lt; dependencies &gt;标签，翻译过来是”依赖”的意思，也就是说把对每个包的需求都称为一个依赖&lt; depedency &gt;，定义在&lt; dependencies &gt;中。在每个&lt; depedency &gt;中，你需要提供的是所需jar包的groupId、artifactId、version(g,a,v)这三个必要信息(坐标)。比如上面我们看到引入可一个junit包，格式如下： Junit是单元测试包，提供了三个基本信息，第4个scope对其他包来说是非必需的。所有jar包的引入都要满足这个格式。 现在我们需要把Spring MVC的包加入依赖项，怎么查看这些jar包的3个信息呢？这就需要查阅仓库，打开Maven Repository，搜索spring-webmvc，进入如下界面： 点击打开后，可以看到很多版本，选择一个比较新的版本： 很方便，仓库里面已经写好了Maven的依赖代码，直接复制就可以了。 现在，把这段代码复制到pox.xml中的&lt; dependencies &gt;中： 这时，Maven就会自动把对应的jar包移植到本地项目里： 可以发现，虽然我们只写了一个依赖，但是会把与它密切相关的jar包同时导入进来。 自此演示一个简单的maven项目所需的jar包其实已经够了~ SpringMVC框架设置现在进行项目的配置。 web.xml 配置默认代码如下： 1234567&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;/web-app&gt; 现在需要创建一个创建Spring MVC的中央控制器 ，还有一个servlet名为mvc-dispatcher(名称可修改)，用于拦截请求（url-pattern为*.do），并交由Spring MVC的后台控制器来处理。这一项配置是必须的。为了能够处理中文的post请求，再配置一个encodingFilter，以避免post请求中文出现乱码情况，最终web.xml的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;display-name&gt;winner-test Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc-dispatcher.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; mvc-dispatcher.xml配置在resources文件夹下创建mvc-dispatcher.xml ,代码如下： 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置包扫描器 --&gt; &lt;context:component-scan base-package="com.winner.controller"/&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; MainController配置在java文件夹下创建一个class，名为MainController，代码如下： 123456789101112import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class MainController &#123; @RequestMapping(value = "/test.do",method = RequestMethod.GET) public String index() &#123; return "index"; &#125;&#125; –@Controller注解：采用注解的方式，可以明确地定义该类为处理请求的Controller类；–@RequestMapping()注解：用于定义一个请求映射，value为请求的url；–return “index”：处理完该请求后返回的逻辑视图。 配置Tomcat来运行项目在上方菜单栏Run-&gt;Edit Configurations ： 点击左上角的”+”号，选择Tomcat Server，(如果没有请选择最下方的33 items more，找到Tomcat Server)，再选择Local，点击 Application server 右边的 Configure，导入Tomcat 目录： 切换到Deployment标签，再点击右边的”+”号，添加一个Artifact. 选择第二个：war exploded，点击OK，这样，该项目就已经部署到了Tomcat中. 点击OK，这时整个Tomcat就配置好了。点击右上角的运行符号： 这时，浏览器会自动打开，输出文字： 这样就算成功完成了最基本的设置。 这段话是写在哪里的呢？在index.jsp里面！ 12345678&lt;html&gt;&lt;body&gt;&lt;h2&gt; Hello World! Hello Spring MVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>spring MVC</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring MVC</tag>
        <tag>maven</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF历届真题]]></title>
    <url>%2F2018%2F07%2F16%2FCCF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[CCF历届真题汇总笔记，持续更新中…… [TOC] 201312-1出现次数最多的数问题描述 给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。 输入格式 输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。 输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。 输出格式 输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。 样例输入 ​ 6 10 1 10 20 30 20 样例输出 ​ 10 很简单，直接用一个数组a[] 存放所有的数，用数组b[] 存放每个元素出现的次数，b数组的下标就是a[i]的值，然后找出b数组中最大数的下标就可以了。需要注意的是数据范围是1 ≤ n ≤ 1000 ，1 ≤ si ≤ 10000，所以 a数组的范围可以是1000，而 b数组的范围必须是10000！ 代码 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i; int a[1005],b[10005]=&#123;0&#125;; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; b[a[i]]++; &#125; int max=b[0]; int flag=0; for(i=0;i&lt;=10000;i++) &#123; if(b[i]&gt;max) &#123; max=b[i]; flag=i; &#125; &#125; cout&lt;&lt;flag&lt;&lt;endl; return 0;&#125; 201312-2 ISBN号码问题描述 每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔 符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。 识别码的计算方法如下： 首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，…，9，再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码。 编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出是正确的ISBN号码。 输入格式 输入只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。 输出格式 输出一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。 样例输入 ​ 0-670-82162-4 样例输出 ​ Right 样例输入 ​ 0-670-82162-0 样例输出 ​ 0-670-82162-4 定位到每一个数字，进行运算模11进行比较判断。不用纠结循环取数，判断是否是“-”的问题，直接一个数一个数的取，因为数据格式是固定的。运算完后的总和模11之后，要转换为字符型变量，与给定的数字进行比较。 代码 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; string s; cin&gt;&gt;s; int i,j,sum=0; int a[10]; a[0]=s[0]-'0'; a[1]=s[2]-'0'; a[2]=s[3]-'0'; a[3]=s[4]-'0'; a[4]=s[6]-'0'; a[5]=s[7]-'0'; a[6]=s[8]-'0'; a[7]=s[9]-'0'; a[8]=s[10]-'0'; a[9]=s[12]-'0'; for(i=0,j=1;i&lt;9;i++,j++) &#123; sum+=a[i]*j; &#125; sum=sum%11; char c=sum==10?'X':sum+'0'; if(s[12]==c) cout&lt;&lt;"Right"&lt;&lt;endl; else &#123; s[12]=c; cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125; 201312-3 最大的矩形问题描述 在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。 请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。 输入格式 第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。 第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。 输出格式 输出一行，包含一个整数，即给定直方图内的最大矩形的面积。 样例输入 ​ 6 3 1 6 5 2 3 样例输出 ​ 10 一开始感觉是动态规划问题，看了答案之后发现其实就是暴力法，遍历每一条条形，如果它后面出现高度小于它的条形，就找到当前这个条形所能得到的最大矩形面积。然后每次遍历时都检验这个面积是不是最大的面积。 代码 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,j,a[1005],ans=0; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=0;i&lt;n;i++) &#123; int h=a[i]; for(j=i;j&lt;n;j++) &#123; if(a[j]&lt;h) h=a[j]; int s=(j-i+1)*h; if(s&gt;ans) ans=s; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 201403-1 相反数问题描述 ​ 有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数(a 和 -a 为一对相反数)。 输入格式 ​ 第一行包含一个正整数 N。(1 ≤ N ≤ 500)。 ​ 第二行为 N 个用单个空格隔开的非零整数,每个数的绝对值不超过1000,保证这些整数各不相同。 输出格式 ​ 只输出一个整数,即这 N 个数中包含多少对相反数。 样例输入 5 1 2 3 -1 -2 样例输出 2 题目中很重要的一句话是，有 N 个非零且各不相同的整数 ，所以不用考虑有多组相同的相反数，也没有0干扰判断。直接双重循环，如果2个数相加等于0，就计数，最后计数除以2就是相反数的对数。 代码 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,j,sum=0,a[505]; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; if(a[i]+a[j]==0) sum++; &#125; &#125; cout&lt;&lt;sum/2&lt;&lt;endl; return 0;&#125; 201403-2 窗口问题描述 在某图形操作系统中,有 N 个窗口,每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别,在多于一个窗口重叠的区域里,只会显示位于顶层的窗口里的内容。 当你点击屏幕上一个点的时候,你就选择了处于被点击位置的最顶层窗口,并且这个窗口就会被移到所有窗口的最顶层,而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口,则系统会忽略你这次点击。 现在我们希望你写一个程序模拟点击窗口的过程。 输入格式 输入的第一行有两个正整数,即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10) 接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2,表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 &lt; x2,y1 2。 接下来 M 行每行包含两个非负整数 x, y,表示一次鼠标点击的坐标。 题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过 2559 和 1439。 输出格式 输出包括 M 行,每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口,则输出这个窗口的编号(窗口按照输入中的顺序从 1 编号到 N);如果没有,则输出”IGNORED”(不含双引号)。 样例输入 3 40 0 4 41 1 5 52 2 6 61 10 04 40 5 样例输出 211IGNORED 样例说明 第一次点击的位置同时属于第 1 和第 2 个窗口,但是由于第 2 个窗口在上面,它被选择并且被置于顶层。 第二次点击的位置只属于第 1 个窗口,因此该次点击选择了此窗口并将其置于顶层。现在的三个窗口的层次关系与初始状态恰好相反了。 第三次点击的位置同时属于三个窗口的范围,但是由于现在第 1 个窗口处于顶层,它被选择。 最后点击的 (0, 5) 不属于任何窗口。 CCF的第2道题很喜欢出这类型的题目，首先第一个难点就是怎么存每一个窗口的坐标和次序，答案就是用结构体进行存储。第二个难点是查找点击的坐标属于哪个窗口并重新排序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;struct Windows&#123; int x1; int x2; int y1; int y2; int order;&#125;a[15];int main()&#123; int n,m,i,j,k,x,y; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++) &#123; a[i].order=i; cin&gt;&gt;a[i].x1&gt;&gt;a[i].y1&gt;&gt;a[i].x2&gt;&gt;a[i].y2; &#125; Windows b; for(i=1;i&lt;=m;i++) &#123; cin&gt;&gt;x&gt;&gt;y; for(j=n;j&gt;0;j--) &#123; if(x&gt;=a[j].x1 &amp;&amp; x&lt;=a[j].x2 &amp;&amp; y&gt;=a[j].y1 &amp;&amp; y&lt;=a[j].y2) &#123; b=a[j]; cout&lt;&lt;a[j].order&lt;&lt;endl; for(k=j;k&lt;n;k++) &#123; a[k]=a[k+1]; &#125; a[n]=b; break; &#125; &#125; if(j==0) cout&lt;&lt;"IGNORED"&lt;&lt;endl; &#125; return 0;&#125; 201409-1 相邻数对问题描述 给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。 输入格式 输入的第一行包含一个整数n，表示给定整数的个数。 第二行包含所给定的n个整数。 输出格式 输出一个整数，表示值正好相差1的数对的个数。 样例输入 610 2 6 3 7 8 样例输出 3 样例说明 值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。 评测用例规模与约定 1&lt;=n&lt;=1000，给定的整数为不超过10000的非负整数。 排个序，判断一下上一个数和下一个数是否相差为1即可。 代码 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,sum=0; int a[1005]; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); for(i=0;i&lt;n;i++) &#123; if(a[i]+1==a[i+1]) sum++; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 201409-2 画图问题描述 在一个定义了直角坐标系的纸上，画一个(x1,y1)到(x2,y2)的矩形指将横坐标范围从x1到x2，纵坐标范围从y1到y2之间的区域涂上颜色。 下图给出了一个画了两个矩形的例子。第一个矩形是(1,1) 到(4, 4)，用绿色和紫色表示。第二个矩形是(2, 3)到(6, 5)，用蓝色和紫色表示。图中，一共有15个单位的面积被涂上颜色，其中紫色部分被涂了两次，但在计算面积时只计算一次。在实际的涂色过程中，所有的矩形都涂成统一的颜色，图中显示不同颜色仅为说明方便。 给出所有要画的矩形，请问总共有多少个单位的面积被涂上颜色。 输入格式 输入的第一行包含一个整数n，表示要画的矩形的个数。 接下来n行，每行4个非负整数，分别表示要画的矩形的左下角的横坐标与纵坐标，以及右上角的横坐标与纵坐标。 输出格式 输出一个整数，表示有多少个单位的面积被涂上颜色。 样例输入 21 1 4 42 3 6 5 样例输出 15 评测用例规模与约定 1&lt;=n&lt;=100，0&lt;=横坐标、纵坐标&lt;=100。 这个题目比较简单，不需要用结构体，直接建一个二维数组保存标记，一组一组的读入坐标，再把对应二维数组标记为1就可以了。最后统计标记了多少个格子即可。 代码 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int a[105][105]=&#123;0&#125;;int main()&#123; int n,i,j,k,sum=0; cin&gt;&gt;n; while(n--) &#123; int x1,y1,x2,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; for(i=x1;i&lt;x2;i++) &#123; for(j=y1;j&lt;y2;j++) &#123; a[i][j]=1; &#125; &#125; &#125; for(i=0;i&lt;105;i++) &#123; for(j=0;j&lt;105;j++) &#123; if(a[i][j]==1) sum++; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 用结构体一样的： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int flag[105][105]=&#123;0&#125;;struct&#123; int x1; int y1; int x2; int y2;&#125;a[100];int main()&#123; int n,i,j,k,sum=0; cin&gt;&gt;n; for(k=0;k&lt;n;k++) &#123; cin&gt;&gt;a[k].x1&gt;&gt;a[k].y1&gt;&gt;a[k].x2&gt;&gt;a[k].y2; for(i=a[k].x1;i&lt;a[k].x2;i++) &#123; for(j=a[k].y1;j&lt;a[k].y2;j++) &#123; flag[i][j]=1; &#125; &#125; &#125; for(i=0;i&lt;105;i++) &#123; for(j=0;j&lt;105;j++) &#123; if(flag[i][j]==1) sum++; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 201409-3 字符串匹配问题描述 给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。 输入格式 输入的第一行包含一个字符串S，由大小写英文字母组成。 第二行包含一个数字，表示大小写敏感的选项，当数字为0时表示大小写不敏感，当数字为1时表示大小写敏感。 第三行包含一个整数n，表示给出的文字的行数。 接下来n行，每行包含一个字符串，字符串由大小写英文字母组成，不含空格和其他字符。 输出格式 输出多行，每行包含一个字符串，按出现的顺序依次给出那些包含了字符串S的行。 样例输入 Hello15HelloWorldHiHiHelloHiHiGrepIsAGreatToolHELLOHELLOisNOTHello 样例输出 HelloWorldHiHiHelloHiHiHELLOisNOTHello 样例说明 在上面的样例中，第四个字符串虽然也是Hello，但是大小写不正确。如果将输入的第二行改为0，则第四个字符串应该输出。 评测用例规模与约定 1&lt;=n&lt;=100，每个字符串的长度不超过100。 字符串操作的问题，对于大小写敏感的查找，就使用C++中的string类，find函数，可以查找子字符串；对于大小写不敏感的查找，需要先把所有的字符串转换为小写的，再用find函数进行查找！ string大法好！函数大法好！ 代码 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string str; cin&gt;&gt;str; int flag,n,i; cin&gt;&gt;flag&gt;&gt;n; if(flag==1) &#123; while(n--) &#123; string s; cin&gt;&gt;s; if(s.find(str)!=string::npos) cout&lt;&lt;s&lt;&lt;endl; &#125; &#125; if(flag==0) &#123; transform(str.begin(), str.end(), str.begin(),::tolower); while(n--) &#123; string s; cin&gt;&gt;s; string p=s; transform(p.begin(), p.end(), p.begin(),::tolower); if(p.find(str)!=string::npos) cout&lt;&lt;s&lt;&lt;endl; &#125; &#125; return 0;&#125; 201402-1 门禁系统问题描述 涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。 输入格式 输入的第一行包含一个整数n，表示涛涛的记录条数。 第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。 输出格式 输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。 样例输入 51 2 1 1 3 样例输出 1 1 2 3 1 评测用例规模与约定 1≤n≤1,000，读者的编号为不超过n的正整数。 用另外一个字符串记录每个数出现的次数，读入一个数，输出计数值一次。 代码 123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i; int a[1005],b[1005]=&#123;0&#125;; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; b[a[i]]++; cout&lt;&lt;b[a[i]]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125; 201503-1 图像旋转问题描述 旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。 计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。 输入格式 输入的第一行包含两个整数n, m，分别表示图像矩阵的行数和列数。 接下来n行每行包含m个整数，表示输入的图像。 输出格式 输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。 样例输入 2 31 5 33 2 4 样例输出 3 45 21 3 评测用例规模与约定 1 ≤ n, m ≤ 1,000，矩阵中的数都是不超过1000的非负整数。 矩阵的转置，没有什么难度… 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int a[1005][1005];int main()&#123; int n,m,i,j; cin&gt;&gt;m&gt;&gt;n; for(i=0;i&lt;m;i++) &#123; for(j=0;j&lt;n;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(j=n-1;j&gt;=0;j--) &#123; for(i=0;i&lt;m;i++) &#123; cout&lt;&lt;a[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 201503-2 数字排序问题描述 给定n个整数，请统计出每个整数出现的次数，按出现次数从多到少的顺序输出。 输入格式 输入的第一行包含一个整数n，表示给定数字的个数。 第二行包含n个整数，相邻的整数之间用一个空格分隔，表示所给定的整数。 输出格式 输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的次数。按出现次数递减的顺序输出。如果两个整数出现的次数一样多，则先输出值较小的，然后输出值较大的。 样例输入 125 2 3 3 1 3 4 2 5 2 3 5 样例输出 3 42 35 31 14 1 评测用例规模与约定 1 ≤ n ≤ 1000，给出的数都是不超过1000的非负整数。 如果就是记录出现的次数并排序，就十分简单，但是这个要输出对应的元素值，一开始想到用结构体存储，但是好像一排序顺序也打乱了…结果暴力的双重循环，遇到a[i]==j 的就把 j 和a[j]都输出来。 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,num,i,j; int a[1005]=&#123;0&#125;; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;num; a[num]++; &#125; for(i=1004;i&gt;0;i--) &#123; for(j=0;j&lt;1005;j++) &#123; if(a[j]==i) cout&lt;&lt;j&lt;&lt;" "&lt;&lt;a[j]&lt;&lt;endl; &#125; &#125; return 0;&#125; 201503-3 节日问题描述 有一类节日的日期并不是固定的，而是以“a月的第b个星期c”的形式定下来的，比如说母亲节就定为每年的五月的第二个星期日。 现在，给你a，b，c和y1, y2(1850 ≤ y1, y2 ≤ 2050)，希望你输出从公元y1年到公元y2年间的每年的a月的第b个星期c的日期。 提示：关于闰年的规则：年份是400的整数倍时是闰年，否则年份是4的倍数并且不是100的倍数时是闰年，其他年份都不是闰年。例如1900年就不是闰年，而2000年是闰年。 为了方便你推算，已知1850年1月1日是星期二。 输入格式 输入包含恰好一行，有五个整数a, b, c, y1, y2。其中c=1, 2, ……, 6, 7分别表示星期一、二、……、六、日。 输出格式 对于y1和y2之间的每一个年份，包括y1和y2，按照年份从小到大的顺序输出一行。 如果该年的a月第b个星期c确实存在，则以”yyyy/mm/dd”的格式输出，即输出四位数的年份，两位数的月份，两位数的日期，中间用斜杠“/”分隔，位数不足时前补零。 如果该年的a月第b个星期c并不存在，则输出”none”（不包含双引号)。 样例输入 5 2 7 2014 2015 样例输出 2014/05/112015/05/10 评测用例规模与约定 所有评测用例都满足：1 ≤ a ≤ 12，1 ≤ b ≤ 5，1 ≤ c ≤ 7，1850 ≤ y1, y2 ≤ 2050。 CCF就喜欢出这种骚题目，看起来很简单，改来改去就是a不了。刚开始觉得很简单，先计算出a月1号是周几，再计算a月第一个星期c是几号，日期加上（b - 1）*7，就是最终的日期。需要注意几个问题：第一个问题是，如果按照题目中所说从1850年开始推算日子的话，1850年1月1号是周二，不好惯性思维……也可以不管题目，直接从1年1月1日开始计算，1年1月1日是周日！第二个问题是，是打印y1~y2年间的每一个日期，不是只打印y1年和y2年的……题目中的样例正好y1和y2是连着的，我就一直以为只输出这两个年份，害我改了一早上，读题目啊！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int month_day[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;//计算year年month月day日是星期几int weeks(int year,int month,int day)&#123; if(year%400==0 || (year%4==0 &amp;&amp; year%100!=0)) month_day[2]=29; else month_day[2]=28; int sum=0; for(int i=1;i&lt;year;i++) &#123; if(i%400==0 || (i%4==0 &amp;&amp; i%100!=0)) sum+=366; else sum+=365; &#125; for(int j=1;j&lt;month;j++) &#123; sum+=month_day[j]; &#125; sum+=day; int k=sum%7; if(k==0) return 7; if(k==1) return 1; if(k==2) return 2; if(k==3) return 3; if(k==4) return 4; if(k==5) return 5; if(k==6) return 6;&#125;int main()&#123; int a,b,c,y1,y2; int y[3005],first_date[3005],day[3005]; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;y1&gt;&gt;y2; for(int i=y1;i&lt;=y2;i++) &#123; y[i]=i; &#125; for(int i=y1;i&lt;=y2;i++) &#123; //计算y年a月1号是周几 first_date[i]=weeks(y[i],a,1); //计算周c距离a月1日有几天 if(c&lt;first_date[i]) &#123; day[i]=first_date[i]-c; day[i]=7-day[i]+1; &#125; if(c&gt;=first_date[i]) &#123; day[i]=c-first_date[i]+1; &#125; day[i]=day[i]+(b-1)*7; //骚的不行的输出 if(day[i]&gt;month_day[a]) cout&lt;&lt;"none"&lt;&lt;endl; else &#123; cout&lt;&lt;y[i]&lt;&lt;"/"; if(a&lt;10) cout&lt;&lt;"0"&lt;&lt;a&lt;&lt;"/"; else cout&lt;&lt;a&lt;&lt;"/"; if(day[i]&lt;10) cout&lt;&lt;"0"&lt;&lt;day[i]&lt;&lt;endl; else cout&lt;&lt;day[i]&lt;&lt;endl; &#125; &#125; return 0;&#125; 201509-1 数字分段问题描述 给定一个整数数列，数列中连续相同的最长整数序列算成一段，问数列中共有多少段？ 输入格式 输入的第一行包含一个整数n，表示数列中整数的个数。 第二行包含n个整数a1, a2, …, an，表示给定的数列，相邻的整数之间用一个空格分隔。 输出格式 输出一个整数，表示给定的数列有多个段。 样例输入 88 8 8 0 12 12 8 0 样例输出 5 样例说明 8 8 8是第一段，0是第二段，12 12是第三段，倒数第二个整数8是第四段，最后一个0是第五段。 评测用例规模与约定 1 ≤ n ≤ 1000，0 ≤ ai ≤ 1000。 检查目前输入进来的数和上一个数相不相同，不相同就计数加一。我感觉a[0]不赋值并没有关系啊，然而不赋值就90分，赋了值就满分了… 代码 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,sum=0; int a[1005]; a[0]=-1; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; if(a[i]!=a[i-1]) sum++; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 201509-2 日期计算问题描述 给定一个年份y和一个整数d，问这一年的第d天是几月几日？ 注意闰年的2月有29天。满足下面条件之一的是闰年： 1） 年份是4的整数倍，而且不是100的整数倍； 2） 年份是400的整数倍。 输入格式 输入的第一行包含一个整数y，表示年份，年份在1900到2015之间（包含1900和2015）。 输入的第二行包含一个整数d，d在1至365之间。 输出格式 输出两行，每行一个整数，分别表示答案的月份和日期。 样例输入 201580 样例输出 321 样例输入 200040 样例输出 29 不是很难，关键是细心。先把12个月份每个月多少天存在数组里，如果是闰年就把2月改为29天。再一个月一个月的减，直到d小于下个月的天数，就可以输出月份和d了。容易忽视的是：1月根本就不能进入循环，直接输出1月d号！ 代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int year,d,i; int month[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;; cin&gt;&gt;year&gt;&gt;d; if(year%400==0 || (year%4==0 &amp;&amp; year%100!=0)) month[2]=29; if(d&lt;=month[1]) cout&lt;&lt;"1"&lt;&lt;endl&lt;&lt;d&lt;&lt;endl; else &#123; for(i=1;i&lt;=12;i++) &#123; d-=month[i]; if(d&lt;=month[i+1]) break; &#125; cout&lt;&lt;i+1&lt;&lt;endl&lt;&lt;d&lt;&lt;endl; &#125; return 0;&#125; 201604-1 折点计数问题描述 给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天和第6天是折点。 给定n个整数a1, a2, …, an表示销售量，请计算出这些天总共有多少个折点。 为了减少歧义，我们给定的数据保证：在这n天中相邻两天的销售量总是不同的，即ai-1≠ai。注意，如果两天不相邻，销售量可能相同。 输入格式 输入的第一行包含一个整数n。 第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an。 输出格式 输出一个整数，表示折点出现的数量。 样例输入 75 4 1 2 3 6 4 样例输出 2 评测用例规模与约定 所有评测用例满足：1 ≤ n ≤ 1000，每天的销售量是不超过10000的非负整数。 只要三个连续的数不是连续递增或者递减就计数增加。 代码 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,sum=0; int a[1005]; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=1;i&lt;n-1;i++) &#123; if((a[i]-a[i-1])*(a[i+1]-a[i])&lt;0) sum++; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 201512-2 消除类游戏问题描述 消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。 现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。 请注意：一个棋子可能在某一行和某一列同时被消除。 输入格式 输入的第一行包含两个整数n, m，用空格分隔，分别表示棋盘的行数和列数。 接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。 输出格式 输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。 样例输入 4 52 2 3 1 23 4 5 1 42 3 2 1 32 2 2 4 4 样例输出 2 2 3 0 23 4 5 0 42 3 2 0 30 0 0 4 4 样例说明 棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。 样例输入 4 52 2 3 1 23 1 1 1 12 3 2 1 32 2 3 3 3 样例输出 2 2 3 0 23 0 0 0 02 3 2 0 32 2 0 0 0 样例说明 棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。 评测用例规模与约定 所有的评测用例满足：1 ≤ n, m ≤ 30。 不算很难，一个二维数组a存储数据，另外一个二维数组b改写0，这样就可以先一排一排的检查，再一列一列的检查。感觉有点啰嗦，但是a了就好。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,m,i,j; int a[35][35],b[35][35]; cin&gt;&gt;n&gt;&gt;m; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; cin&gt;&gt;a[i][j]; b[i][j]=a[i][j]; &#125; &#125; for(i=0;i&lt;n;i++) &#123; for(j=1;j&lt;m-1;j++) &#123; if(a[i][j]==a[i][j-1] &amp;&amp; a[i][j]==a[i][j+1]) &#123; b[i][j-1]=0; b[i][j]=0; b[i][j+1]=0; &#125; &#125; &#125; for(i=1;i&lt;n-1;i++) &#123; for(j=0;j&lt;m;j++) &#123; if(a[i][j]==a[i-1][j] &amp;&amp; a[i][j]==a[i+1][j]) &#123; b[i-1][j]=0; b[i][j]=0; b[i+1][j]=0; &#125; &#125; &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; cout&lt;&lt;b[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 201604-2 俄罗斯方块问题描述 俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。 游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。 在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。 具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。 输入格式 输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。 输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。 第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例） 输出格式 输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。 样例输入 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 0 0 0 1 1 1 10 0 0 0 1 0 0 0 0 00 0 0 00 1 1 10 0 0 10 0 0 03 样例输出 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 1 1 1 1 1 1 10 0 0 0 1 1 0 0 0 0 模拟的思想，找到方块能够下降的位置，然后重新赋值后输出。提示好坑人啊，什么左边是不是0的问题，一开始被误导了…底板的边界从1开始计数，而不是0。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int board[20][20]; int block[5][5]; int i,j,k,a,b,pos; for(i=1;i&lt;=15;i++) for(j=1;j&lt;=10;j++) cin&gt;&gt;board[i][j]; for(j=1;j&lt;=10;j++) board[16][j]=1; for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) cin&gt;&gt;block[i][j]; cin&gt;&gt;pos; bool over=false; //模拟，找到下降的位置 for(i=1;i&lt;=15;i++) &#123; for(a=0;a&lt;4;a++) &#123; for(b=0;b&lt;4;b++) &#123; if(block[a][b]==1 &amp;&amp; board[i+a][pos+b]==1) over = true; &#125; &#125; if(over==true) break; &#125; //改变值 for(a=0;a&lt;4;a++) for(b=0;b&lt;4;b++) board[i+a-1][pos+b]+=block[a][b]; for(i=1;i&lt;=15;i++) &#123; for(j=1;j&lt;=10;j++) &#123; cout&lt;&lt;board[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 201609-2 火车购票问题描述 请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。 假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。 购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。 假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。 输入格式 输入的第一行包含一个整数n，表示购票指令的数量。 第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。 输出格式 输出n行，每行对应一条指令的处理结果。 对于购票指令p，输出p张车票的编号，按从小到大排序。 样例输入 42 5 4 2 样例输出 1 26 7 8 9 1011 12 13 143 4 样例说明 1) 购2张票，得到座位1、2。 2) 购5张票，得到座位6至10。 3) 购4张票，得到座位11至14。 4) 购2张票，得到座位3、4。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。 我就直接暴力模拟，对1~5这五种情况全部列举一遍，得了90分，有一个问题就是如果前20次都是4个座位，第21次再买4个座位时，应该输出：5 10 15 20，中间是空格而不是换行，所以需要手动输出空格和换行。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int s[101]=&#123;0&#125;;void buy(int op)&#123; int i; if(op==1) &#123; for(i=1;i&lt;=100;i++) &#123; if(s[i]==0) &#123; cout&lt;&lt;i; s[i]=1; break; &#125; &#125; &#125; if(op==2) &#123; int flag=0; for(i=1;i&lt;=99;i++) &#123; if(s[i]==0 &amp;&amp; s[i+1]==0 &amp;&amp; i%5!=0) &#123; flag=1; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i+1&lt;&lt;endl; s[i]=1; s[i+1]=1; break; &#125; &#125; if(flag==0) &#123; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;endl; &#125; &#125; if(op==3) &#123; int flag=0; for(i=1;i&lt;=98;i++) &#123; if(s[i]==0 &amp;&amp; s[i+1]==0 &amp;&amp; s[i+2]==0 &amp;&amp; i%5&lt;=3 &amp;&amp; i%5!=0) &#123; flag=1; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i+1&lt;&lt;" "&lt;&lt;i+2&lt;&lt;endl; s[i]=1; s[i+1]=1; s[i+2]=1; break; &#125; &#125; if(flag==0) &#123; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;endl; &#125; &#125; if(op==4) &#123; int flag=0; for(i=1;i&lt;=97;i++) &#123; if(s[i]==0 &amp;&amp; s[i+1]==0 &amp;&amp; s[i+2]==0 &amp;&amp; s[i+3]==0 &amp;&amp; i%5&lt;=2 &amp;&amp; i%5!=0) &#123; flag=1; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i+1&lt;&lt;" "&lt;&lt;i+2&lt;&lt;" "&lt;&lt;i+3&lt;&lt;endl; s[i]=1; s[i+1]=1; s[i+2]=1; s[i+3]=1; break; &#125; &#125; if(flag==0) &#123; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;endl; &#125; &#125; if(op==5) &#123; int flag=0; for(i=1;i&lt;=96;i++) &#123; if(s[i]==0 &amp;&amp; s[i+1]==0 &amp;&amp; s[i+2]==0 &amp;&amp; s[i+3]==0 &amp;&amp; s[i+4]==0 &amp;&amp; i%5==1) &#123; flag=1; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i+1&lt;&lt;" "&lt;&lt;i+2&lt;&lt;" "&lt;&lt;i+3&lt;&lt;" "&lt;&lt;i+4&lt;&lt;endl; s[i]=1; s[i+1]=1; s[i+2]=1; s[i+3]=1; s[i+4]=1; break; &#125; &#125; if(flag==0) &#123; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;endl; &#125; &#125;&#125;int main()&#123; int n,k,op; cin&gt;&gt;n; for(k=0;k&lt;n;k++) &#123; cin&gt;&gt;op; buy(op); if(op==1) cout&lt;&lt;endl; &#125; return 0;&#125; 201712-2 游戏问题描述 有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。 游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。 例如，当n=5, k=2时： 1号小朋友报数1； 2号小朋友报数2淘汰； 3号小朋友报数3； 4号小朋友报数4淘汰； 5号小朋友报数5； 1号小朋友报数6淘汰； 3号小朋友报数7； 5号小朋友报数8淘汰； 3号小朋友获胜。 给定n和k，请问最后获胜的小朋友编号为多少？ 输入格式 输入一行，包括两个整数n和k，意义如题目所述。 输出格式 输出一行，包含一个整数，表示获胜的小朋友编号。 样例输入 5 2 样例输出 3 样例输入 7 3 样例输出 4 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。 仔细读题目！不是约瑟夫环问题！报数要一直一直递增下去…模拟的思路。另外要注意n=1时，无论k为何值都应该是输出1。 代码 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,k,count=0,index=0,step=1; cin&gt;&gt;n&gt;&gt;k; int a[1005]=&#123;0&#125;; while(n&gt;count) &#123; if(a[index]==0) &#123; if((step%k==0)||(step%10==k)) &#123; if(count==n-1) &#123; cout&lt;&lt;index+1&lt;&lt;endl; break; &#125; a[index]=1; count++; &#125; step++; &#125; index=(++index)%n; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解算法》学习笔记9]]></title>
    <url>%2F2018%2F06%2F11%2F%E3%80%8A%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%2F</url>
    <content type="text"><![CDATA[第九章的学习笔记 第九章 动态规划背包问题经典的背包问题： 假设你是一个小偷，背着一个可以装4磅东西的背包。你可以盗取的物品有以下3样： 音响 3000美元 4磅 笔记本电脑 2000美元 3磅 吉他 1500美元 1磅 为了让盗窃的商品价值最高，应该怎么选择商品？ 解题过程每一个动态规划问题都是从一个网格开始，背包问题的网格如下： 网格的各行为商品，各列为不同容量（1~4磅）的背包。所有这些列都需要，因为他们帮助你计算子背包的价值。网格最初是空的，你将填充其中的每一个单元格，网格填满后，就可以得出答案。 现在开始填表： 吉他行 这一行中，你能够拿的物品只有吉他。当背包容量为1时就可以拿吉他，因为吉他的重量就是1，这时最大价值为1500，接下来当背包容量为2，3，4时，依然只能拿吉他，所以第一行全部都是1500。 音响行 现在可以选择的物品有吉他和音响。当容量为1，2，3时，只能拿吉他，价值为1500；当容量为4时，可以拿音响，音响比吉他值钱，所以拿音响，价值为3000。 这时容量为4的背包最大价值更新为3000。 笔记本电脑行 现在可以选择的物品有吉他、音响、笔记本电脑。当容量为1，2时，只能拿吉他，价值1500；当容量为3时，可以拿笔记本电脑，更新价值为2000；当容量为4时，可以拿（容量为3时的最大值 + 余下的1磅物品）或者之前选择的音响。发现笔记本电脑+吉他更之前，更新价值为4500。 现在表填完了，最后一行的最后一列代表所有物品都可以选且容量为背包最大容量时能获得的最大价值，即为答案。 动态规划算法在刚刚填表的过程中，其实是有一套规则的：$$cell\ [\ i\ ][\ j\ ]=\begin{cases} 上一个单元格的值（即cell\ [\ i-1\ ][\ j-1\ ]的值）\\当前商品的价值 + 剩余空间的价值（cell\ [\ i-1\ ][\ j- 当前商品的重量\ ]）\end{cases}$$背包问题FAQ Q：再增加一个物品呢？ A：直接再加一行即可，表格中前面的值不变，只用填新加的这一行就可以了，依然遵循刚才的填表原则。 Q：行的排列顺序发生变化会如何？ A：无论行是什么顺序，都不影响最终结果。 Q：可以逐列而不是逐行填表吗？ A：背包问题可以，有些动态规划问题不行。 Q：增加一件更小的物品怎么办？ A：例如增加一个0.5磅的物品，子背包应该变为0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4。 Q：可以偷商品的一部分吗？ A：不行，动态规划不能解决只拿一部分的问题。需要用贪心算法每次选择价值最高的物品。 Q：最优解可能出现没装满的情况吗？ A：很有可能。 最长公共子串&amp;子序列最长公共子串最长公共子串问题描述：假如用户输入一个单词，但是拼错了，你的字典里根本没有这个单词，但是有几个类似的单词，怎么判断另一个单词和他输入的单词的有多少字母相同呢？ 例如他输入hish，而你想计算fish和它的相似度。 填表： H I S H F 0 0 0 0 I 0 1 0 0 S 0 0 2 0 H 1 0 0 3 表格中最大的数为3，所以两个单词的最长公共子串的长度为3。 怎么填表的呢？ 如果两个字母不相同，则为0 如果两个字母相同，则为左上角邻居的值+1 最长公共子序列 F O S H F 1 1 1 1 I 1 1 1 1 S 1 1 2 2 H 1 1 2 3 填表依据： 如果两个字母不同，就选择上方和左方邻居中较大的那个 如果两个字母相同，就是左方单元格的值+1 代码实现1234567891011121314151617181920212223242526272829import string,randomdef lcs_dp(input_x, input_y): # 建立一个dp二维数组 # input_y as column, input_x as row dp = [([0] * (len(input_y) + 1)) for i in range(len(input_x) + 1)] for i in range(1, len(input_x) + 1): for j in range(1, len(input_y) + 1): if i == 0 or j == 0: # 在边界上，自行+1 dp[i][j] = 1 elif input_x[i - 1] == input_y[j - 1]: # 不在边界上，相等就加一 dp[i][j] = dp[i - 1][j - 1] + 1 else: # 不相等 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[-1][-1]def random_str(randomlength): str = "" for i in range(randomlength): str += random.choice(list(string.ascii_letters)) return strif __name__ == "__main__": str1 = random_str(10000) str2 = random_str(10000) print("字符串1:", str1) print("字符串2:", str2) print("最长子序列的长度：", lcs_dp(str1, str2)) 小结动态规划可以解决的常见实际问题： 生物学家根据最长公共子序列来确定DNA链的相似性，进而判断两种动物或疾病有多相似。 代码查重/论文查重也是查找最长公共子序列的问题。 计算编辑距离的问题，拼写检查、判断盗版都是用动态规划解决的。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解算法》学习笔记8]]></title>
    <url>%2F2018%2F06%2F10%2F%E3%80%8A%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08%2F</url>
    <content type="text"><![CDATA[第八章的学习笔记 第八章 贪婪算法教室调度问题假设有一张课表，你希望将尽可能多的课程安排在某间教室上。但是又本可能所有课都在这一间教室上，因为有些课的上课时间有冲突。 美术 9：00AM 10:00AM 英语 9：30AM 10：30AM 数学 10：00AM 11：00AM 计算机 10：30AM 11：30AM 音乐 11：00AM 12：00AM 具体做法是： 1.选出结束最早的课，它就是要在这间教室上的第一堂课。 2.接下来，必须选择第一堂课结束后才开始的课。同样，你选择结束最早的课，这将是要在这间教室上的第二堂课。 重复这样做就能找到答案。 贪婪算法很简单：每一步都采取最优的做法。用专业术语说，每步都选择局部最优解，最终得到的就是全局最优解。 集合覆盖问题假设需要让全美50个州都收到广播节目，不同的广播公司向不同的州广播，怎么选择最少的广播公司呢？ 这就需要列举出所有可能的集合，在这个集合中选择覆盖全美50个州的最小集合。 这样的穷举需要耗费大量的时间，效率极低。为了解决这种问题，可以采用近似算法，使用贪婪算法可以得到非常接近的解，而时间可以大大缩短。 12345678910111213141516171819202122states_needed = &#123;"mt", "wa", "or", "id", "nv", "ut", "ca", "az"&#125;stations = &#123;"kone": &#123;"id", "nv", "ut"&#125;, "ktwo": &#123;"wa", "id", "mt"&#125;, "kthree": &#123;"or", "nv", "ca"&#125;, "kfour": &#123;"nv", "ut"&#125;, "kfive": &#123;"ca", "az"&#125;&#125;final_stations = set()while states_needed: best_station = None states_covered = set() for station, states in stations.items(): covered = states_needed &amp; states if len(covered) &gt; len(states_covered): best_station = station states_covered = covered states_needed -= states_covered final_stations.add(best_station)print(final_stations) 小结 旅行商问题和集合覆盖问题有一个共同之处：需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。 元素较少时算法的运算速度非常快，但是随着元素数量的增加，速度会变得非常慢。 涉及“所有组合”的问题通常是NP完全问题。 不能将问题分成小问题，必须考虑各种情况的可能情况。这可能是NP完全问题。 贪婪算法寻找局部最优解，企图用这种方式获得全局最优解，贪婪算法易于实现、运算速度快，是不错的近似算法。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解算法》学习笔记7]]></title>
    <url>%2F2018%2F06%2F04%2F%E3%80%8A%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07%2F</url>
    <content type="text"><![CDATA[第七章的学习笔记 第七章 Dijkstra算法算法概述Dijkstra算法解决的是：在加权图中，一个点（源点）到其余各个顶点的最短路径问题，也叫做“单源最短路径”。例如下图所示的一个加权图中，从1到6有很多条路径，每一段的长度都不同，用Dijkstra算法可以选择一条长度最短的路径。 注意该算法要求图中不存在负权边。 核心思路若对于顶点 s 存在能直接到达的边（s,m），则把d[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径。当算法结束时，d[v] 中存储的便是从 s 到 v的最短路径，或者如果路径不存在的话是无穷大。 边的拓展是Dijkstra 算法的基础操作：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到尾部来拓展一条从 s 到 v 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比目前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直运行到所有的 d[v] 都代表从 s 到 v 的最短路径的长度值。此算法的组织令 d[u] 达到其最终值时，每条边（u, v）都只被拓展一次。 算法维护两个顶点集合 S 和 Q。集合 S 保留所有已知最小 d[v] 值的顶点 v ，而集合 Q 则保留其他所有顶点。集合S初始状态为空，而后每一步都有一个顶点从 Q 移动到 S。这个被选择的顶点是 Q 中拥有最小的 d[u] 值的顶点。当一个顶点 u 从 Q 中转移到了 S 中，算法对 u 的每条外接边 (u, v) 进行拓展。 换钢琴的实例这是交换物品的一张图，乐谱是起点（已经有的东西），现在需要花最少的钱来还到钢琴。 第一步：从起点（乐谱）出发，找到最便宜的节点。 这里只有两个节点，一个是唱片（权值为5），一个是海报（权值为0），所以选择海报这个节点。 第二步：计算前往该节点（海报）的各个邻居的开销。 用一个表来记录： 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 海报 吉他 30 海报 架子鼓 35 — 钢琴 &infin; 第三步：再次执行第一步。下一个最便宜的节点为唱片。 第四部：再次执行第二步。计算前往该节点（唱片）的各个邻居的开销。 用一个表来记录： 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 唱片 吉他 20 唱片 架子鼓 25 — 钢琴 &infin; 第五步：更新开销。 发现通过唱片到吉他和通过唱片到架子鼓的开销更小。所以将架子鼓和吉他的父节点更新为唱片。 第六步：重复第一步。现在起点变成了唱片。下一个最便宜的节点是吉他。 第七步：重复第二步。计算前往该节点（吉他）的各个邻居的开销。 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 唱片 吉他 20 唱片 架子鼓 25 吉他 钢琴 40 第八步：重复第一步。起点是唱片，除了吉他，下一个最便宜的节点是架子鼓。 第九步：重复第二步。计算前往该节点（架子鼓）的各个邻居的开销。 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 唱片 吉他 20 唱片 架子鼓 25 架子鼓 钢琴 35 第十步：更新开销。 通过架子鼓到钢琴更便宜，所以钢琴的父节点更新为架子鼓。 至此，就找到了从乐谱到各个节点的最便宜的方案，例如要还到钢琴，就需要35元。怎么确定路径呢？根据父节点向前推导就可以知道这条路径了。 代码实现题目如下图为例： 定义散列表一共需要三个散列表，一个是定义图，节点之间权值的散列表，一个是costs，一个是parents，也就是前文例子中的表格后两列。 1234567891011121314151617181920212223# 先定义一个散列表，起点分别是start，a，b，fingraph = &#123;"start": &#123;&#125;, "a": &#123;&#125;, "b": &#123;&#125;, "fin": &#123;&#125;&#125;graph["start"]["a"] = 4graph["start"]["b"] = 2graph["a"]["fin"] = 1graph["b"]["a"] = 3graph["b"]["fin"] = 5infinity = float("inf")# 定义开销的散列表costs = &#123;&#125;costs["a"] = 6costs["b"] = 2costs["fin"] = infinity# 定义父节点的散列表parents = &#123;&#125;parents["a"] = "start"parents["b"] = "start"parents["fin"] = None 最小costs函数123456789def find_lowest_cost_node(costs): lowest_cost = float("inf") lowest_cost_node = None for node in costs: cost = costs[node] if cost &lt; lowest_cost and node not in processed: lowest_cost = cost lowest_cost_node = node return lowest_cost_node 主函数123456789101112node = find_lowest_cost_node(costs)while node is not None: cost = costs[node] neighbors = graph[node] for n in neighbors.keys(): new_cost = cost + neighbors[n] if costs[n] &gt; new_cost: costs[n] = new_cost parents[n] = node processed.append(node) node = find_lowest_cost_node(costs) print(node)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记6]]></title>
    <url>%2F2018%2F06%2F02%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%2F</url>
    <content type="text"><![CDATA[第六章的学习笔记 第六章 广度优先搜索BFS的核心思想：层层递进首先以一个未被访问过的顶点作为起始顶点，访问其所有相邻的顶点，然后对每个相邻的顶点再访问它们相邻的未被访问过的顶点，直到所有顶点都被访问过，遍历结束。 BFS搜索是一种用于图的查找，可以帮助回答两类问题： 从节点A出发，有前往节点B的路径吗？ 从节点A出发，前往节点B的哪条路径最短？ 芒果经销商的例子 假设你经营着一个芒果农场，需要寻找芒果经销商，为此，你在朋友列表中查找 这种查找很简单，创建一个朋友名单，并依次遍历每一个朋友看她是不是芒果经销商 假设没有，这时就要在朋友的朋友中查找 这时对于每一个朋友，再将他们的朋友加入到列表中 再次遍历列表，看朋友的朋友是不是芒果经销商 如果依然没有，就把第三层关系人物加入到列表，在重复遍历查找的操作。 广度优先搜索就是先查找一度关系，再查找二度关系、再查找三度关系，以此类推。在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，一层一层的向外查找。 注意，必须按照添加顺序查找时，才能实现这样的目的。如果不按照层次顺序查找，就无法找到最短路径。想要按照添加顺序进行检查，就需要使用一种数据结构，那就是队列（queue）。 队列队列是一种先进先出（First In First Out,FIFO）的数据结构，而栈是一种后进先出（Last In First Out,LIFO）的数据结构。 队列的工作原理与生活中的队列完全相同，不能随机访问队列中的元素，队列只支持两种操作：入队和出队。 实现算法 首先，创建一个队列。在python中，可以用deque来创建一个双端队列。 12345678910111213141516171819202122232425262728293031323334353637from collections import deque# 可以用散列表来生成图graph = &#123;&#125;graph['you'] = ['alice', 'bob', 'claire']graph['bob'] = ['anuj', 'peggy']graph['alice'] = ['peggy']graph['claire'] = ['thom', 'jonny']graph['anuj'] = []graph['peggy'] = []graph['thom'] = []graph['jonny'] = []def person_is_seller(name): # 自定义以m结尾的名字就是芒果经销商 return name[-1] == 'm'def search(name): search_queue = deque() search_queue += graph[name] searched = [] while search_queue: person = search_queue.popleft() # 取出第一个人 if person not in searched: if person_is_seller(person): print(person + " is a mango seller!") return True else: search_queue += graph[person] searched.append(person) return Falseif __name__ == '__main__': search('you') 小结 广度优先搜索指出是否有从A到B的路径。 如果有，广度优先搜索将找出最短路径。 有向图中的边为箭头，箭头方向指定了关系的方向。 无向图中的边不带箭头，其中的关系是双向的。 队列是先进先出（FIFO）的。 栈是后进先出（LIFO）的。 广度优先搜索需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。 对于检查过的人，务必不要再检查，否则会导致无限循环。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记5]]></title>
    <url>%2F2018%2F05%2F31%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%2F</url>
    <content type="text"><![CDATA[第五章的学习笔记 第五章 散列表散列表散列表（Hash table），也叫哈希表，是根据键（key）而直接访问在内存存储位置的数据结构，也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。 一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 X 到首字母 F(X) 的一个函数关系，在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则 F( )，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。 散列函数散列函数（英文：Hash function）又称哈希函数。 散列函数总是将同样的输入映射到相同的索引。 散列函数只带数组有多大，只返回有效的索引。 Python提供的散列表实现为字典，可以使用函数 dict 来创建散列表。 哈希查找1234567891011121314151617181920212223242526272829303132333435363738class HashTable: def __init__(self, size): self.elem = [None for i in range(size)] # 使用list数据结构作为哈希表元素保存方法 self.count = size # 最大表长 def hash(self, key): return key % self.count # 散列函数采用除留余数法 def insert_hash(self, key): """插入关键字到哈希表内""" address = self.hash(key) # 求散列地址 while self.elem[address]: # 当前位置已经有数据了，发生冲突。 address = (address+1) % self.count # 线性探测下一地址是否可用 self.elem[address] = key # 没有冲突则直接保存。 def search_hash(self, key): """查找关键字，返回布尔值""" star = address = self.hash(key) while self.elem[address] != key: address = (address + 1) % self.count if not self.elem[address] or address == star: # 说明没找到或者循环到了开始的位置 return False return True if __name__ == '__main__': list_a = [12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34] hash_table = HashTable(12) for i in list_a: hash_table.insert_hash(i) for i in hash_table.elem: if i: print((i, hash_table.elem.index(i)), end=" ") print("n") print(hash_table.search_hash(15)) print(hash_table.search_hash(33)) 小结 散链表常用于查找、防止重复。缓存。 散链表适用于映射关系、防止重复、缓存/记住数据。 冲突很糟糕，应该使用可以最大限度减小冲突的散列函数。 散列表的查找、插入、删除操作速度都非常快。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记4]]></title>
    <url>%2F2018%2F05%2F30%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[第四章的学习笔记 第四章 快速排序分治法——分而治之总述 分而治之（divide and conquer,D&amp;C）是一种著名的递归式问题解决方法。分治法提供了一种解决问题的思路，是另一种可供你使用的工具。分治法的核心思想就是用一种对解决某个问题通用而且尽可能简单的方法，不断缩小问题的规模，知道求解出问题为止。 步骤 找出基线条件，这种条件必须尽可能简单 不断将问题分解（缩小规模），直到符合基线条件。 分治法：划分方块问题题目要求 现在有一个矩形，边长为1680 * 640，需要将这个矩形均匀地分成方块，且分出的方块要尽可能大。 思路 找基线条件：当一条边长是另一条边长的整数倍时，就可以尽可能大的划分成方块。 分解问题： 首先找到这个矩形能容纳的最大方块：因为宽度是640，所以可以划分的最大方块的边长为640*640，一共可以划分出两个这样的方块。 剩下的矩形边长为640*400。 再对剩下的矩形进行相同的操作，找出这个矩形能容纳的最大方块：400*400。 剩下的矩形变成了400*240。 再对这个矩形进行同样的操作，找出最大能容纳的方块：240*240。 剩下的矩形变成了240*120。这时这个矩形可以划分成两个小方形（满足基线条件：一条边长是另一条边长的整数倍）结束。 最后，对于最初的那个矩形，适用的最大方块为80*80。 这里用到了一个原理：适用于这小块地的最大方块，也是适用于整块地的最大方块。这个原理来源于欧几里得算法。 分治法：求数组元素之和题目要求 给出一个数组，数组中有一串数组，现在需要求这数组中数字元素之和。 最简单的方法就是直接循环求和： 12345def sum(arr): total = 0 for x in arr: total += x return total 但是怎么用递归函数来实现呢？这就需要不断的把问题规模缩小。 例如给出一个数组：[2,4,6],求和： 第一步：找出基线条件：$$\begin{cases}空集不包含任何元素 ,&amp; \text{总和为0} \\ 只包含一个元素, &amp; \text {总和为该元素本身}\end{cases}$$第二步：缩小规模： 1234def dc_sum(arr): if arr == []: return 0 return arr[0] + dc_sum(arr[1:]) 分治法：快速排序快速排序的思想是：先选择一个元素值做为基准值，然后将数组中所有小于基准数的数放在这个数的左边，大于这个数的元素都放在右边。再在这两个子数组中做这种操作，各选择一个基准数，然后小的放一边，大的放一边……直到子数组为空或者只有一个元素（这两种情况下的子数组一定是有序的）。 12345678def quick_sort(arr): if len(arr) &lt; 2: return arr else: pivot = arr[0] #这里直接把第一个元素当做基准值 less = [i for i in arr[1:] if i &lt;= pivot] more = [i for i in arr[1:] if i &gt; pivot] return quick_sort(less) + [pivot] + quick_sort(more) 总结 分治法将问题逐步分解，划分成n个子问题。使用分治法处理列表时，基线条件很可能是空数组或者只包含一个元素。 实现快速排序时，基准值可以随机选择。 快速排序的平均运行时间为O(n logn)。 虽然快速排序和归并排序的时间效率都是O(n logn)，但是快速排序往往比归并排序要快很多。这是因为大O表示法中的常量事关重大。 快速查找比简单查找和二分查找的效率高很多。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验四]]></title>
    <url>%2F2018%2F05%2F27%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验四 作业调度方案我们现在要利用m台机器加工n个工件，每个工件都有m道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。 每个工件的每个工序称为一个操作，我们用记号j-k表示一个操作，其中j为1到n中的某个数字，为工件号；k为1到m中的某个数字，为工序号，例如2-4表示第2个工件第4道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。 例如，当n=3，m=2时，“1-1，1-2，2-1，3-1，3-2，2-2”就是一个给定的安排顺序，即先安排第1个工件的第1个工序，再安排第1个工件的第2个工序，然后再安排第2个工件的第1个工序，等等。 一方面，每个操作的安排都要满足以下的两个约束条件。 (1) 对同一个工件，每道工序必须在它前面的工序完成后才能开始； (2) 同一时刻每一台机器至多只能加工一个工件。 另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。 由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为“1 1 2 3 3 2”。 还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。 例如，取n=3,m=2，已知数据如下： 工件号 机器号/加工时间 工序 11 工序 22 11 , 1/31/3 , 2/22/2 22 , 1/21/2 , 2/52/5 33 , 2/22/2 , 1/41/4 则对于安排顺序“1 1 2 3 3 2”，下图中的两个实施方案都是正确的。但所需要的总时间分别是10与12。 当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件（1）（2）的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件（1）（2）的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。 显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。 输入 第1行为两个正整数m和n（其中m（&lt;20）表示机器数，n（&lt;20）表示工件数），用一个空格隔开：第2行：个用空格隔开的数，为给定的安排顺序。接下来的2n行，每行都是用空格隔开的m个正整数，每个数不超过20。其中前n行依次表示每个工件的每个工序所使用的机器号，第1个数为第1个工序的机器号，第2个数为第2个工序机器号，等等。后n行依次表示每个工件的每个工序的加工时间。 输出 只有一个正整数，为最少的加工时间。 样例输入 2 31 1 2 3 3 21 21 22 13 22 52 4 样例输出 10 题目解读代码 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int i,j,k,l,m,n,num[25][25],a[500],t[25][25],sum[25],f[25][1000],mx[25],ans,mt[25];int main() &#123; scanf("%d%d",&amp;m,&amp;n); for (i=1; i&lt;=m*n; i++) scanf("%d",&amp;a[i]); for (i=1; i&lt;=n; i++) for (j=1; j&lt;=m; j++) scanf("%d",&amp;num[i][j]); for (i=1; i&lt;=n; i++) for (j=1; j&lt;=m; j++) scanf("%d",&amp;t[i][j]); for (i=1; i&lt;=m*n; i++) &#123; sum[a[i]]++; for (j=mt[a[i]]; j&lt;=1000; j++) &#123; int pd=1; for (k=j; k&lt;=j+t[a[i]][sum[a[i]]]-1; k++) &#123; if (f[num[a[i]][sum[a[i]]]][k]==1) &#123; pd=0; break; &#125; &#125; if (pd==1) &#123; if (j+t[a[i]][sum[a[i]]]&gt;mx[num[a[i]][sum[a[i]]]]) mx[num[a[i]][sum[a[i]]]]=j+t[a[i]][sum[a[i]]]; if (j+t[a[i]][sum[a[i]]]&gt;mt[a[i]]) mt[a[i]]=j+t[a[i]][sum[a[i]]]; for (k=j; k&lt;=j+t[a[i]][sum[a[i]]]-1; k++) f[num[a[i]][sum[a[i]]]][k]=1; break; &#125; &#125; &#125; for (i=1; i&lt;=m; i++) ans=max(mx[i],ans); printf("%d\n",ans); &#125; Maximum Tape Utilization Ratio设有n 个程序{1,2,…, n }要存放在长度为L的磁带上。程序i存放在磁带上的长度是li ，1 &lt; = i &lt; = n。 程序存储问题要求确定这n 个程序在磁带上的一个存储方案，使得能够在磁带上存储尽可能多的程序。在保证存储最多程序的前提下还要求磁带的利用率达到最大。 对于给定的n个程序存放在磁带上的长度，编程计算磁带上最多可以存储的程序数和占用磁带的长度。 输入 第一行是2 个正整数，分别表示文件个数n &lt;=600和磁带的长度L&lt;=6000。接下来的1 行中，有n个正整数，表示程序存放在磁带上的长度。 输出 第1 行输出最多可以存储的程序数和占用磁带的长度；第2行输出存放在磁带上的每个程序的长度。 样例输入 9 502 3 13 8 80 20 21 22 23 样例输出 5 492 3 13 8 23 题目解读动态规划，优先考虑尽可能多的程序个数，如果程序个数相同再考虑程序占据的长度。 dp[i][j][0]：代表前i个程序，占据j长度，存储程序个数最大值 dp[i][j][1]：代表前i个程序，占据j长度，存储程序长度最大值 注意输入时倒序输，因为最后要回溯判断选了哪些并按顺序输出。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int dp[605][6005][2];//dp[i][j][k]//k=0，前i个程序，占据j长度，存储程序个数最大值//k=1，前i个程序，占据j长度，存储程序长度最大值int main()&#123; int n,L,i,j,k; int w[605]; cin&gt;&gt;n&gt;&gt;L; for(i=1;i&lt;=n;i++) cin&gt;&gt;w[n+1-i]; for(i=1;i&lt;=n;i++) &#123; for(j=0;j&lt;=L;j++) &#123; if(w[i]&lt;=j &amp;&amp; dp[i-1][j][0] &lt; dp[i-1][j-w[i]][0]+1) &#123; dp[i][j][0]=dp[i-1][j-w[i]][0]+1; dp[i][j][1]=dp[i-1][j-w[i]][1]+w[i]; &#125; else if(w[i]&lt;=j &amp;&amp; dp[i-1][j][0] == dp[i-1][j-w[i]][0]+1) &#123; dp[i][j][0]=dp[i-1][j][0]; dp[i][j][1]=max(dp[i-1][j][1],dp[i-1][j-w[i]][1]+w[i]); &#125; else &#123; dp[i][j][0]=dp[i-1][j][0]; dp[i][j][1]=dp[i-1][j][1]; &#125; &#125; &#125; cout&lt;&lt;dp[n][L][0]&lt;&lt;" "&lt;&lt;dp[n][L][1]&lt;&lt;endl; i=n,j=dp[n][L][1],k=0; while(i) &#123; if(dp[i][j][0] == dp[i-1][j-w[i]][0]+1 &amp;&amp; dp[i][j][1] == dp[i-1][j-w[i]][1]+w[i]) &#123; j-=w[i]; if(k++) cout&lt;&lt;" "; cout&lt;&lt;w[i]; &#125; i--; &#125; cout&lt;&lt;endl; return 0;&#125; Soldiers在一个划分成网格的操场上，n个士兵散乱地站在网格点上。网格点由整数坐标(x,y)表示。士兵们可以沿网格边上、下、左、右移动一步，但在同一时刻任一网格点上只能有一名士兵。按照军官的命令，士兵们要整齐地列成一个水平队列，即排列成(x,y),(x+1,y),…,(x+n-1,y)。如何选择x 和y的值才能使士兵们以最少的总移动步数排成一列。计算使所有士兵排成一行需要的最少移动步数。 输入 第1 行是士兵数n，1&lt; =n&lt; =10000。接下来n 行是士兵的位置，每行2个整数x和y，-10000&lt; =x，y&lt; =10000。 输出 第1 行中的数是士兵排成一行需要的最少移动步数。 样例输入 51 22 21 33 -23 3 样例输出 8 题目解读因为是排成一排，所以y方向必须选择一个中间值，对y左边排序取中位数。如果n是奇数，则就是中位数，如果n是偶数，就是中间两个数中的任意一个。 下面考虑x方向，需要注意的是，排好队后x坐标必须是连续的。所以说先对x排序，然后 x[i]-i 就是x每个x需要移动的最小距离，再对这个新的数组求中位数就是最佳位置。 代码 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,x[10005],y[10005],midx,midy,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; sort(y,y+n); midy=y[n/2]; sort(x,x+n); for(int i=0;i&lt;n;i++) x[i]-=i; sort(x,x+n); midx=x[n/2]; for(int i=0;i&lt;n;i++) ans+=abs(midx-x[i])+abs(midy-y[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Edit Distance设A 和B 是2 个字符串。要用最少的字符操作将字符串A 转换为字符串B。这里所说的字符操作包括 (1)删除一个字符； (2)插入一个字符； (3)将一个字符改为另一个字符。 将字符串A变换为字符串B 所用的最少字符操作数称为字符串A到B 的编辑距离，记为d(A,B)。试设计一个有效算法，对任给的2 个字符串A和B，计算出它们的编辑距离d(A,B)。 输入 第一行是字符串A，文件的第二行是字符串B。字符串长度不大于2000。 输出 输出距离d(A,B) 样例输入 fxpimuxwr 样例输出 5 题目解读此题常见的思路是动态规划，令dp[i][j] 表示原字符串S[0…i] 和目标串T[0…j] 的最短编辑距离，其边界： dp[i][0] = i, dp[0][j] = j ,我们可以得到状态转移方程：$$dp[i][j]=min \begin{cases} dp[i-1][j]+1,&amp;\text{S[i]不在T[0…j]中}\\ dp[i][j-1]+1，&amp;\text{S[i]在T[0…j-1]中}\\ dp[i-1][j-1] + 0or1，&amp;\text{S[i]在T[j]中}\end{cases}$$下面解释这3个式子： S[i] 不在 T[0…j]中，说明目标串里面没有源字符串的这个字符，即在某一次操作中这个字符被删除了。因为删除操作没有前后相关性，不妨将其在第一次操作中删除，进行了一次删除操作后，后续编辑操作是将长度为i-1的字符串编辑为长度为 j 的字符串，即dp[i-1][j]。 S[i] 在 T[0…j-1]中说明，S[i] 出现在 T[0…j-1]中的某个位置，不妨认为是k，因为最小编辑步数的定义，那么，在k+1到j-1的字符，必然是通过插入新字符完成的。因为共插入了(j-k)个字符，故编辑次数为(j-k)次。而字符串S[1…i]经过编辑，得到了T[1…k]，编辑次数为dp[i][k]。故： dp[i][j] = dp[i][k] + (j-k)。 由于最后的(j-k)次是插入操作，可以讲(j-k)逐次规约到dp[i][k]中。即：dp[i][k]+(j-k)=dp[i][k+1] + (j-k-1) 规约到插入操作为1次，得到 dp[i][k]+(j-k) =dp[i][k+1] + (j-k-1) =dp[i][k+2] + (j-k-2)=… =dp[i][k+(j-k-1)] + (j-k)-(j-k-1) =dp[i][j-1] + 1。 关于dp[i-1][j-1] + 0/1, s[i] 在T[j]的说明：s[i]经过编辑，最终落在T[j]的位置。 则要么s[i] == t[j]，s[i]直接落在T[j]。这种情况，编辑操作实际上是将长度为i-1的S’串，编辑成长度为j-1的T’串：即dp[i-1][j-1]； 要么s[i] ≠ t[j]，s[i] 落在T[j]后，要将s[i]修改成T[j]，即在上一种情况的基础上，增加一次修改操作：即dp[i-1][j-1] + 1。 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int dp[2005][2005];int main()&#123; char a[2005],b[2005]; cin&gt;&gt;a&gt;&gt;b; int len1,len2,i,j,cost; len1=strlen(a); len2=strlen(b); for(i=0;i&lt;=len1;i++) dp[i][0]=i; for(j=0;j&lt;=len2;j++) dp[0][j]=j; for(i=1;i&lt;=len1;i++) &#123; for(j=1;j&lt;=len2;j++) &#123; if(a[i-1]==b[j-1]) cost=0; else cost=1; dp[i][j]=min(dp[i-1][j-1]+cost,min(dp[i-1][j],dp[i][j-1])+1); &#125; &#125; cout&lt;&lt;dp[len1][len2]&lt;&lt;endl; return 0;&#125; Independent Task Scheduling用2 台处理机A 和B 处理n 个作业。设第i 个作业交给机器A 处理时需要时间i a ，若由机器B 来处理，则需要时间i b 。由于各作业的特点和机器的性能关系，很可能对于某些i，有ai &gt;=bi，而对于某些j,j≠i，有aj &lt; bj 。既不能将一个作业分开由2 台机器处理，也没有一台机器能同时处理2 个作业。设计一个动态规划算法，使得这2 台机器处理完这n个作业的时间最短(从任何一台机器开工到最后一台机器停工的总时间)。研究一个实例： (a1,a2,a3,a4,a5,a6)＝(2,5,7,10,5,2)；(b1,b2,b3,b4,b5,b6)＝(3,8,4,11,3,4)。 对于给定的2 台处理机A 和B处理n 个作业，找出一个最优调度方案，使2台机器处理完这n 个作业的时间最短。 输入 第1行是1个正整数n&lt;=200, 表示要处理n个作业。 接下来的2行中，每行有n 个正整数，分别表示处理机A 和B 处理第i 个作业需要的处理时间。 输出 最短处理时间 样例输入 62 5 7 10 5 23 8 4 11 3 4 样例输出 15 题目解读代码 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int a[205],b[205],t[2005]=&#123;0&#125;; int n,i,j,k,ta=0; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; ta+=a[i]; &#125; for(j=1;j&lt;=n;j++) cin&gt;&gt;b[j]; for(k=1;k&lt;=n;k++) &#123; for(i=ta;i&gt;=0;i--) &#123; if(i&gt;=a[k]) t[i]=min(t[i-a[k]],t[i]+b[k]); else t[i]=t[i]+b[k]; &#125; &#125; int ans=10000; for(i=0;i&lt;=ta;i++) &#123; ans=min(ans,max(i,t[i])); &#125; printf("%d\n",ans); return 0;&#125; Arbitrage套汇是指利用货币汇兑率的差异将一个单位的某种货币转换为大于一个单位的同种货币。例如，假定1 美元可以买0.7 英镑，1 英镑可以买9.5 法郎，且1 法郎可以买到0.16美元。通过货币兑换，一个商人可以从1 美元开始买入，得到0.7×9.5×0.16=1.064美元，从而获得6.4%的利润。 给定n 种货币c1 ,c2 ,… ,cn的有关兑换率，试设计一个有效算法，用以确定是否存在套汇的可能性。 输入 含多个测试数据项。每个测试数据项的第一行中只有1 个整数n (1&lt; =n&lt; =30)，表示货币总数。其后n行给出n种货币的名称。接下来的一行中 有1 个整数m，表示有m种不同的货币兑换率。其后m行给出m种不同的货币兑换率，每行有3 个数据项ci ， rij 和cj ，表示货币ci 和cj的兑换率为 rij。文件最后以数字0 结束。 输出 对每个测试数据项j，如果存在套汇的可能性则输出“Case j Yes”， 否则输出“Case j No”。 样例输入 3USDollarBritishPoundFrenchFranc3USDollar 0.5 BritishPoundBritishPound 10.0 FrenchFrancFrenchFranc 0.21 USDollar3USDollarBritishPoundFrenchFranc6USDollar 0.5 BritishPoundUSDollar 4.9 FrenchFrancBritishPound 10.0 FrenchFrancBritishPound 1.99 USDollarFrenchFranc 0.09 BritishPoundFrenchFranc 0.19 USDollar0 样例输出 Case 1 YesCase 2 No 题目解读看到题目之后首先想到的就是转换成图的问题，每个货币单位对应一个节点，计算一个节点经过其他节点最后回到自己时的路径（算路径时不时传统的权值相加，而应该是相乘）是否大于1的问题。关键问题就在于怎么把输入的数据转换成图… 思路就是先读入所有的name，然后循环找输入进来的每一条汇率中的两个国名分别是name中的第几个，对应的rank[j][k]就是汇率值。找的方法就是循环，用strcmp做为终止条件（即str1==str2），记录下标就可以把对应的rank[j][k]置为对应的汇率值。 接下来就是一个Floyd算法的变形，标准的Floyd应该是加法，因为最短路径是求每一段路程的总和；而这里应该是乘法，因为算汇率是乘法。如果找到汇率大于1的情况，就说明可以套汇，否则不能套汇。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,m,i,j,k,cnt=1; float x,rank[35][35]; char name[35][35],a[35],b[35]; while(cin&gt;&gt; n&amp;&amp;n) &#123; for(i=0;i&lt;n;i++) cin&gt;&gt;name[i]; memset(rank,0.0,sizeof(rank)); cin&gt;&gt;m; for(i=0;i&lt;m;i++) &#123; cin&gt;&gt;a&gt;&gt;x&gt;&gt;b; for(j=0;strcmp(a,name[j]);j++); for(k=0;strcmp(b,name[k]);k++); rank[j][k]=x; &#125; for(i=0;i&lt;n;i++) rank[i][i]=max(float(1.0),rank[i][i]); for(k=0;k&lt;n;k++) for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) rank[i][j]=max(rank[i][j],rank[i][k]*rank[k][j]); for(i=0;i&lt;n;i++) &#123; if(rank[i][i]&gt;1) break; &#125; if(i&lt;n) cout&lt;&lt;"Case "&lt;&lt;cnt++&lt;&lt;" Yes"&lt;&lt;endl; else cout&lt;&lt;"Case "&lt;&lt;cnt++&lt;&lt;" No"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记3]]></title>
    <url>%2F2018%2F05%2F26%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[第三章的学习笔记 第三章 递归递归的核心思想现在有一个盒子，盒子里还有盒子，要找到藏在某个盒子里的钥匙。 非递归思想（循环）： 递归思想： 简单来说：递归的思想就是函数自己调用自己。 基线条件和递归条件编写函数时，必须告诉它何时停止递归。正因如此，每个递归函数都有两个部分：基线条件和递归条件。递归条件指的是函数调用自己，而基线条件则值的是函数不再调用自己，从而避免形成无限循环。 递归求阶乘12345def factorial(x): if (x == 1): return 1 else: return x * factorial(x-1)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记2]]></title>
    <url>%2F2018%2F05%2F24%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[第二章的学习笔记 第二章 选择排序 本章主要学习两种最基本的数据结构——数组和链表。 同时还要学习一种排序算法——选择排序。 数组和链表数组对于数组来说，随机的读取元素时很高效，因为直接根据数组的下标就可以找到对应的元素。 但是数组的不便之处在于，需要提前申明数组的大小，如果需要存的数据量大于申明的数组大小，就无法存储多余的数据，如果用不完就会造成一定的内存浪费。 数组的另外一个不足之处就是，不便于进行插入、删除操作。如果要在数组的中间插入一个元素，要先将它后面的数据整体向后移动一个位置，才能插入新的元素，效率低下。 链表链表无需申明长度，可以随意进行元素的添加，在链表中，每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一次。这种数据结构的优势就是，便于进行插入、删除操作，只需将上一个元素存储的下一个元素地址指向待插入的元素地址，再把待插入的元素存储下一个元素地址，就完成了插入操作，比数组方便很多。 但是反过来，链表就不便于进行随机地读取元素了，因为并不知道待查找的元素的位置，所以需要一个一个的查，直到找到为止。 数组 链表 读取 O(1) O(n) 插入 O(n) O(1) 删除 O(n) O(1) O(n) = 线性时间 O(n) = 常量时间 总结数组和链表哪个用的更多呢？需要看具体情况。 有两种访问方式：随机访问和顺序访问。 顺序访问意味着从一个元素开始逐个地址读取元素，链表只能顺序访问。 随机访问意味着可以直接跳到第10个元素，数组可以随机访问。 因为在大部分情况下，我们需要随机访问，所以还是数组使用的更多。 选择排序既然是排序算法，就是给出一串无序的数组，然后编程使他们按照从小到大或者从大到小的顺序排列。 核心思想选择排序的思想很简单：首先找到所有数里最小的元素，把它存放在新的数组中，然后再在剩下的（n-1）个元素中找到最小的元素，并存放在新数组里面，以此类推，每次都在剩下的数中挑选出最小的存成新的数组，直到选完为止。 python代码1234567891011121314151617181920def findSmallest(arr): smallest = arr[0] #存储最小的值 smallest_index = 0 #存储最小值的索引 for i in range(1,len(arr)): if(arr[i] &lt; smallest): smallest = arr[i] smallest_index = i return smallest_indexdef selection_sort(arr): newArr = [] for i in range(len(arr)): smallest_index = findSmallest(arr) newArr.append(arr.pop(smallest_index)) #每次都找到最小的元素存入新数组，并在原来数组里删除掉 return newArrif __name__ == '__main__': print(selection_sort([5,3,6,2,10])) C/C++代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;void selection_sort(int *arr,int len)&#123; int i,j,min; for(i=0;i&lt;len-1;i++) &#123; min=i; for(j=i;j&lt;len;j++) &#123; if(arr[j]&lt;arr[min]) min=j; &#125; if(min!=i) &#123; int t=arr[min]; arr[min]=arr[i]; arr[i]=t; &#125; &#125;&#125;int main()&#123; int arr[5]=&#123;5,3,6,2,10&#125;; selection_sort(arr,5); for(int i=0;i&lt;5;i++) &#123; cout&lt;&lt;arr[i]&lt;&lt;" "; &#125; return 0;&#125; 时间复杂度每比较一次，就需要遍历一遍数组，所以每一次比较的时间复杂度都是O(n)，需要比较n次，所以选择排序的时间复杂度是O(n2)。 遗留问题： 随着排序的进行，每次需要比较的元素数在减小，最后一次需要检查的元素都只有一个，为什么是n个O(n)呢？ 因为平均每次检查的元素个数为n/2,因此运行时间为O(n * n/2)，但是大O表示法省略诸如1/2这样的常数，因此简写为O(n)。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记1]]></title>
    <url>%2F2018%2F05%2F22%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[《算法图解》像小说一样有趣的算法入门书，作者推崇图解式写作风格，生动易读。就我个人而言，算法一直是弱项，这次想花一个月的时间，坚持打卡学习，争取能在算法能力上取得一定的提升。 本书采用python语言编写，由于大部分ACM程序设计大赛都是用C/C++或java，所以我不仅用python编写，还会尽量用C/C++写代码。 第一章 算法简介二分查找算法定义二分查找，也叫折半查找，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 举例举个例子，给出一串有序数组：[10,20,30,40,50,60,70,80,90] 编号 1 2 3 4 5 6 7 8 9 数字 10 20 30 40 50 60 70 80 90 现在想要寻找80在哪个位置，蛮力法即是循环遍历数组中的每个元素，当遍历到的元素正好等于80时，就找到了，对于这个数组，需要查询8次。 而二分法的思想是，先看中间第5号元素是多少，结果是50，这样就把前面5个元素排除掉了，因为要找的90比50还大；现在只需要在5号到10号中间选，再挑选中间的7号元素查看，发现是70，还是比90小，那么前7个元素都被排除了；再在7到9之间选中间的8号元素查看，正好是80，就找到了，只查询了3次。 可以想象，随着元素的增多，二分法查找的效率会明显高于蛮力法，这就是二分法查找算法的优势。 代码实例python代码： 1234567891011121314151617181920212223242526def binary_search(list,item): #用low和high代表需要查找的区间范围 low = 0 high = len(list) - 1 while(low&lt;=high): #只要范围没有缩小到只剩一个元素 mid = (low + high) // 2 #中间的元素 #（"//"运算符代表取整除，返回商的整数部分，否则如果是小数，就无法在数组中查询了） guess = list[mid] #查看中间元素对应的值 if(guess == item): #找到了 return mid if(guess &gt; item): #猜大了 high = mid - 1 else: #猜小了 low = mid + 1 return None #没找到if __name__ == '__main__': my_list = [1,3,5,7,9] print(binary_search(my_list, 3)) print(binary_search(my_list, -1))"""1None""" C/C++代码： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int arr[5]=&#123;1,3,5,7,9&#125;;int binary_search(int n,int item) //传入数组的长度和需要查找的值&#123; int low = 0,high = n-1; while(low&lt;=high) &#123; int mid = (low + high) / 2; if(arr[mid]==item) &#123; return mid; break; &#125; if(arr[mid]&gt; item) high=mid-1; if(arr[mid]&lt; item) low=mid+1; &#125; return -1;&#125;int main()&#123; printf("%d\n",binary_search(5,3)); printf("%d\n",binary_search(5,-1)); return 0;&#125; 大O表示法 在计算机科学中，算法的时间复杂度是一个函数，它定性描述该算法的运行时间，这是一个代表算法输入值的字符串的长度的函数。时间复杂度通常用大O表示。 引入下面做一个实验，分别比较同种操作系统下、同种规模的数据量（1到105、106、107），二分法和蛮力查找最后一个元素时，所花费的时间。 python中计算运行时间的方法： 1234import timet0 = time.clock()binary_search(list,item)print("process time:", time.clock() - t0) python中蛮力法遍历查找的代码如下： 12345678910def rude_search(num_list,item): for index,element in enumerate(num_list): if(element == item): return index return Noneif __name__ == '__main__': my_list = [1,3,5,7,9] print(rude_search(my_list, 3)) print(rude_search(my_list, -1)) 下面是运行时间的比较,我们做出曲线图： 这时我们就会发现一个问题，仅知道算法需要多长时间才能运行完毕还不够，还需要知道运行时间如何随列表增长而增加，这正是大O的用武之地。 大O大O指出了算法有多快。例如，假设列表有n个元素，蛮力法查找需要检查每个元素，因此需要（最多）执行n次操作。使用大O表示法，这个运行时间为O(n)，没有单位，因为大O表示法让你能够比较操作次数，它指出了算法运行时间的增速。 常见的大O运行时间 名称 时间复杂度 算法举例 对数时间 O(log n) 二分查找 线性时间 O(n) 遍历数组 线性迭代对数时间 O(n * log n) 快速排序 二次时间 O(n2) 选择排序 阶乘时间 O(n!) 旅行商问题]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（上）]]></title>
    <url>%2F2018%2F05%2F19%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[动态规划（英语：Dynamic programming，简称DP） 常常适用于有重叠子问题 和最优子性质的问题。 动态规划（上）动态规划（英语：Dynamic programming，简称DP） 常常适用于有重叠子问题 和最优子性质的问题。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 斐波那契数列斐波那契数列可以以递归的方式来定义： F0 = 0 F1 = 1 Fn = Fn-1 + Fn-2 （n&gt;=2) 用文字来说，就是斐波那契数列由0和1开始，之后的数就是前面连个数之和：0,1,1,2,3,5,8,13…… 求解斐波那契数列时，可以直接使用递归的定义方法： 12345int fib(n)&#123; if(n==0 || n==1) return n; return fib(n-1)+fib(n-2);&#125; 这样的定义方式便于理解，但是有一个问题：对于相似的子问题进行了大量重复的计算，例如在求fib(5)时，经历了这样的步骤： fib(5) fib(4) + fib(3) ( fib(3) + fib(2) ) + ( fib(2) + fib(1) ) [ ( fib(2) + fib(1) ) + ( fib(1) + fib(0) ) ] + [ ( fib(1) + fib(0) ) + fib(1) ] [ ( ( fib(1) + fib(0) ) + fib(1) ) + ( fib(1) + fib(0) ) ] + [ ( fib(1) + fib(0) ) + fib(1) ] 由这个过程可以看出，这样递归的方法会重复计算多次fib(2)、fib(3)，因此效率很低，如果将前n个已经计算出来了的 fib(i) 存在一个数组中，这样在后面的计算中，就可以直接调用数组中存储的值，而避免了重复计算。这种思想就是动态规划的思想。 1234567int dp[1005];int fib(n)&#123; if(n==0) dp[n]=0; if(n==1) dp[n]=1; dp[n]=dp[n-1]+dp[n-2];&#125; 收集硬币问题有一串数字，现在需要取出一些数组，取数规则就是不能选两个相邻的数。现在需要计算在这种规则下，能取到的数字之和最大是多少。 例如以下这一串数字： 编号 0 1 2 3 4 5 num 5 1 2 10 6 2 现在定义一个数组dp[ ],dp[i]代表选择到第i个硬币时，能得到的最大金额数。 以dp[5]为例，此时有两种选择： 选5号（那就不能选4号）：dp[3]+num[5] 不选5号（就可以选4号）：dp[4] 这样就可以推导出状态方程：$$\begin{cases}dp[i] = max( dp[i-2] + num[i] , dp[i-1] )\dp[0] = num[0]\dp[1] = max( num[0], num[1] )\end{cases}$$这样就可以敲代码了，如果使用递归的方法，会产生很多重叠子问题，运算速度慢，效率为O(n^2^)。所以不使用递归方法，而是建立一个dp数组，然后循环填表，一次把dp[0],dp[1],dp[2]……的值计算出来，最后最优解即是dp[n-1]。 代码 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define max(a,b) ((a&gt;b)?a:b)int main()&#123; int num[10000],dp[10000]=&#123;0&#125;; int n,i; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;num[i]; &#125; dp[0]=num[0]; dp[1]=max(num[0],num[1]); for(i=2;i&lt;n;i++) &#123; dp[i]=max(dp[i-2]+num[i],dp[i-1]); &#125; printf("%d\r\n",dp[n-1]); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv-python人脸识别应用]]></title>
    <url>%2F2018%2F05%2F08%2Fopencv-python%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[利用OpenCV和python环境实现简单的人脸识别应用：识别人脸并框处人脸、检测并框处人的眼睛、检测笑脸、并框处笑脸。 环境准备 系统环境：win7 python版本：python3.6.3 已存在vs2015（OpenCV需要C++环境） OpenCV 关于OpenCV自带的分类器OpenCV 是一个跨平台的计算机视觉库，它实现了图像处理和计算机视觉方面的很多通用算法，是一个非常强大的开源库。 OpenCV项目源码中有很多训练好的Haar分类器。 这些xml文件是已经训练好的数据，可以直接调用，进而达到识别分类的功能。本文不训练数据，直接使用这些OpenCV库中自带的方法进行人脸识别。 找到图像中人脸的位置1234567891011121314151617#detectFaces()返回图像中所有人脸的矩形坐标（矩形左上、右下顶点）#使用haar特征的级联分类器haarcascade_frontalface_default.xml，在haarcascades目录下还有其他的训练好的xml文件可供选择。#注：haarcascades目录下训练好的分类器必须以灰度图作为输入。def detectFaces(image_name): img = cv2.imread(image_name) face_cascade = cv2.CascadeClassifier("D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_frontalface_default.xml") #分类器函数中的参数就是xml文件的具体位置 if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 faces = face_cascade.detectMultiScale(gray, 1.2, 5)#1.3和5是特征的最小、最大检测窗口，它改变检测结果也会改变 result = [] for (x,y,width,height) in faces: result.append((x,y,x+width,y+height)) return result 函数最终返回一个列表，包含识别出来的人脸的左上、右上、左下、右下4个定点的坐标。 框出人脸123456789101112#在原图像上画矩形，框出所有人脸。#调用Image模块的draw方法，Image.open获取图像句柄，ImageDraw.Draw获取该图像的draw实例，然后调用该draw实例的rectangle方法画矩形(矩形的坐标即#detectFaces返回的坐标)，outline是矩形线条颜色(B,G,R)。#注：原始图像如果是灰度图，则去掉outline，因为灰度图没有RGB可言。drawEyes、detectSmiles也一样。def drawFaces(image_name): faces = detectFaces(image_name) if faces: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in faces: draw_instance.rectangle((x1,y1,x2,y2), outline=(255, 0,0)) img.save('drawfaces_'+image_name) 效果如图，可以看到正面人脸都被识别出来了，有一处判断错误的地方。 检测眼睛12345678910111213141516#检测眼睛，返回坐标#由于眼睛在人脸上，我们往往是先检测出人脸，再细入地检测眼睛。故detectEyes可在detectFaces基础上来进行，代码中需要注意“相对坐标”。#当然也可以在整张图片上直接使用分类器,这种方法代码跟detectFaces一样，这里不多说。def detectEyes(image_name): eye_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_eye.xml') faces = detectFaces(image_name) img = cv2.imread(image_name) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) result = [] for (x1,y1,x2,y2) in faces: roi_gray = gray[y1:y2, x1:x2] eyes = eye_cascade.detectMultiScale(roi_gray,1.3,2) for (ex,ey,ew,eh) in eyes: result.append((x1+ex,y1+ey,x1+ex+ew,y1+ey+eh)) return result 使用眼睛的分类器进行分类，将四个顶点的坐标保存在列表里。 框出眼睛123456789#在原图像上框出眼睛.def drawEyes(image_name): eyes = detectEyes(image_name) if eyes: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in eyes: draw_instance.rectangle((x1,y1,x2,y2), outline=(0, 0,255)) img.save('draweyes_'+image_name) 效果如图，识别的还不算太精准： 检验笑脸1234567891011121314#检测笑脸def detectSmiles(image_name): img = cv2.imread(image_name) smiles_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_smile.xml') if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 smiles = smiles_cascade.detectMultiScale(gray,4,5) result = [] for (x,y,width,height) in smiles: result.append((x,y,x+width,y+height)) return result 框出笑脸123456789#在原图像上框出笑脸def drawSmiles(image_name): smiles = detectSmiles(image_name) if smiles: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in smiles: draw_instance.rectangle((x1,y1,x2,y2), outline=(100, 100,0)) img.save('drawsmiles_'+image_name) 效果如图： 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import osimport cv2from PIL import Image,ImageDraw#detectFaces()返回图像中所有人脸的矩形坐标（矩形左上、右下顶点）#使用haar特征的级联分类器haarcascade_frontalface_default.xml，在haarcascades目录下还有其他的训练好的xml文件可供选择。#注：haarcascades目录下训练好的分类器必须以灰度图作为输入。def detectFaces(image_name): img = cv2.imread(image_name) face_cascade = cv2.CascadeClassifier("D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_frontalface_default.xml") if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 faces = face_cascade.detectMultiScale(gray, 1.2, 5)#1.3和5是特征的最小、最大检测窗口，它改变检测结果也会改变 result = [] for (x,y,width,height) in faces: result.append((x,y,x+width,y+height)) return result#保存人脸图def saveFaces(image_name): faces = detectFaces(image_name) if faces: #将人脸保存在save_dir目录下。 #Image模块：Image.open获取图像句柄，crop剪切图像(剪切的区域就是detectFaces返回的坐标)，save保存。 save_dir = image_name.split('.')[0]+"_faces" os.mkdir(save_dir) count = 0 for (x1,y1,x2,y2) in faces: file_name = os.path.join(save_dir,str(count)+".jpg") Image.open(image_name).crop((x1,y1,x2,y2)).save(file_name) count+=1#在原图像上画矩形，框出所有人脸。#调用Image模块的draw方法，Image.open获取图像句柄，ImageDraw.Draw获取该图像的draw实例，然后调用该draw实例的rectangle方法画矩形(矩形的坐标即#detectFaces返回的坐标)，outline是矩形线条颜色(B,G,R)。#注：原始图像如果是灰度图，则去掉outline，因为灰度图没有RGB可言。drawEyes、detectSmiles也一样。def drawFaces(image_name): faces = detectFaces(image_name) if faces: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in faces: draw_instance.rectangle((x1,y1,x2,y2), outline=(255, 0,0)) img.save('drawfaces_'+image_name)#检测眼睛，返回坐标#由于眼睛在人脸上，我们往往是先检测出人脸，再细入地检测眼睛。故detectEyes可在detectFaces基础上来进行，代码中需要注意“相对坐标”。#当然也可以在整张图片上直接使用分类器,这种方法代码跟detectFaces一样，这里不多说。def detectEyes(image_name): eye_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_eye.xml') faces = detectFaces(image_name) img = cv2.imread(image_name) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) result = [] for (x1,y1,x2,y2) in faces: roi_gray = gray[y1:y2, x1:x2] eyes = eye_cascade.detectMultiScale(roi_gray,1.3,2) for (ex,ey,ew,eh) in eyes: result.append((x1+ex,y1+ey,x1+ex+ew,y1+ey+eh)) return result#在原图像上框出眼睛.def drawEyes(image_name): eyes = detectEyes(image_name) if eyes: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in eyes: draw_instance.rectangle((x1,y1,x2,y2), outline=(0, 0,255)) img.save('draweyes_'+image_name)#检测笑脸def detectSmiles(image_name): img = cv2.imread(image_name) smiles_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_smile.xml') if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 smiles = smiles_cascade.detectMultiScale(gray,4,5) result = [] for (x,y,width,height) in smiles: result.append((x,y,x+width,y+height)) return result#在原图像上框出笑脸def drawSmiles(image_name): smiles = detectSmiles(image_name) if smiles: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in smiles: draw_instance.rectangle((x1,y1,x2,y2), outline=(100, 100,0)) img.save('drawsmiles_'+image_name)if __name__ == '__main__': drawFaces('obama.jpg') drawEyes('obama.jpg') drawSmiles('obama.jpg') saveFaces('obama.jpg')"""上面的代码将眼睛、人脸、笑脸在不同的图像上框出，如果需要在同一张图像上框出，改一下代码就可以了。总之，利用opencv里训练好的haar特征的xml文件，在图片上检测出人脸的坐标，利用这个坐标，我们可以将人脸区域剪切保存，也可以在原图上将人脸框出。剪切保存人脸以及用矩形工具框出人脸，本程序使用的是PIL里的Image、ImageDraw模块。此外，opencv里面也有画矩形的模块，同样可以用来框出人脸。""" 总结OpenCV自带的分类器使用起来比较简单，对于标准的人脸图片识别的准确率比较高，但是也有误判的现象，特别是笑脸的判断不够精准，还有待完善。 后期可以使用OpenCV制作分类器，大致分为3步： 制作训练集的数据集 训练分类器 使用分类器进行分类]]></content>
      <categories>
        <category>onpencv</category>
      </categories>
      <tags>
        <tag>图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验三]]></title>
    <url>%2F2018%2F05%2F04%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验三 简单背包问题设有一个背包可以放入的物品重量为S，现有n件物品，重量分别是w1，w2，w3，…wn。 问能否从这n件物品中选择若干件放入背包中，使得放入的重量之和正好为S。 如果有满足条件的选择，则此背包有解，否则此背包问题无解。 输入 输入数据有多行，假设背包可以放入的物品重量为S，物品的件数n，以及每件物品的重量（输入数据均为正整数）。多组测试数据。 输出 对于每个测试实例，若满足条件则输出“YES”，若不满足则输出“NO“。 样例输入 20 51 3 5 7 9 样例输出 YES 题目解读思想就是先把所有的物品都放入背包，然后再一件一件的往外拿，当拿出之后： 当背包被取空了时，就表明有解； 当拿完所有物品后，背包质量还不等于weight，就无解； 当第n个物品没有取出，而n-1个被取出时，背包的质量等于weight，就有解。 假设第n－1个物品取出来了，依然往下取，这时背包的weight变成weight-data[n]。 代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int data[1005];int bag(int weight,int n)&#123; if(weight==0) return 1; if(n==0 &amp;&amp; weight!=0) return 0; if(bag(weight,n-1)==1) return 1; return bag(weight-data[n],n-1);&#125;int main()&#123; int weight,n; while(scanf("%d %d",&amp;weight,&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;data[i]); &#125; if(bag(weight,n)==1) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; Buyer哆啦A梦班级举办个party，当然吃的东西必不可少，哆啦A梦负责采购任务，他得到了一份清单，上面注明不同食品的受欢迎程度，哆啦A梦需要用一定的价钱尽可能达到的更大的受欢迎程度！例如，瓜子的受欢迎程度为20，瓜子的价钱是50元，那么如果哆啦A梦选择买瓜子，将花费50元，但受欢迎程度增加了20。为了避免食品单调性，每种食品只能买一份，不能重复购买。 现在哆啦A梦需要知道如何采购才能达到最大的受欢迎程度，你能帮助他吗？ 输入 输入数据为多组，每组输入的第一行有两个正整数M和N(M&lt;100&amp;&amp;N&lt;1000)，分别为哆啦A梦可以支配的钱数和清单上的可选择的物品种类。 接下来的N行每行有两个正整数,分别为每种物品的价钱和它的受欢迎程度（编号为1到N）。 输出 如果存在物品购买，那么输出的第一行为能够达到的最大的受欢迎程度。第二行为需要购买的物品的编号（如果有多种可能，输出字典序靠前的那种），空格分隔每个数字；如没有物品可以购买，输出只有一行，为数字0。 样例输入 10 4100 55 55 510 10 样例输出 102 3 题目解读这道题就是01背包问题，金额限定M代表背包的容量，每种物品的价格代表物品的重量w[ ]，每种物品的价值用v[ ]表示。 动态规划求解构造一个二维数组dp[N][M]，N行（N个物品),M列（M为容量能使用的最大金额)。二维数组dp[i][j]的含义是：当拿到第i个物品，不超过金额 j 时的最大价值。一行一行的循环填表： 如果当前的限额超过了该物品的价值，表示可以取该物品,需要选择最优解： 如果不取，当前价值为dp[i-1][j] 如果取，当前价值为dp[i-1][ j-w[i] ]+v[i]（指考虑了i-1件物品，背包容量为 j-w[i] 时的价值加上拿取的这件物品的价值） 如果当前的限额低于这件物品的价值，就不能拿取这个物品： 当前价值为dp[i-1][j] 12345678910for(i=1;i&lt;=N;i++)&#123; for(j=1;j&lt;=M;j++) &#123; if(j&gt;=w[i]) dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); else dp[i][j]=dp[i-1][j]; &#125;&#125; 回溯检验是否取了物品另外创建一个一维数组x[N]，下标代表物品对应的编号，0代表没有取，1代表取了。 由于dp[i][M]为最优解，如果dp[i][M]=dp[i-1][M]，那就说明有没有第i件物品都一样，那么x[i]=0，否则x[i]=1。 1234567891011121314void traceback(int M,int N) &#123; for(int i=N;i&gt;1;i--) &#123; if(dp[i][M]==dp[i-1][M]) x[i]=0; else &#123; x[i]=1; M-=w[i]; &#125; &#125; x[1]=(dp[1][M]&gt;0)?1:0; &#125; 输出问题（小心PE） 首先输出一行最大价值，换行； 然后输出取出来的物品，中间用一个空格隔开，注意最后一个数后面没有空格，而是换行； 多组输入，所以当最大价值为0时，输出0然后continue再次进入新的循环 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int dp[1005][1005]=&#123;0&#125;;int x[1005];int v[1005],w[1005];void traceback(int M,int N) &#123; for(int i=N;i&gt;1;i--) &#123; if(dp[i][M]==dp[i-1][M]) x[i]=0; else &#123; x[i]=1; M-=w[i]; &#125; &#125; x[1]=(dp[1][M]&gt;0)?1:0; &#125; int main()&#123; int M,N,i,j; while(scanf("%d %d",&amp;M,&amp;N)!=EOF) &#123; for(i=1;i&lt;=N;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(i=1;i&lt;=N;i++) &#123; for(j=1;j&lt;=M;j++) &#123; if(j&gt;=w[i]) dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); else dp[i][j]=dp[i-1][j]; &#125; &#125; traceback(M,N); int sum=0; for(i=1;i&lt;=N;i++) &#123; if(x[i]==1) sum+=v[i]; &#125; if(sum==0) &#123; cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; cout&lt;&lt;sum&lt;&lt;endl; int flag=0; for(i=1;i&lt;=N;i++) &#123; if(x[i]==1 &amp;&amp; flag==0) &#123; cout&lt;&lt;i; flag=1; &#125; else if(x[i]==1 &amp;&amp; flag==1) cout&lt;&lt;" "&lt;&lt;i; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 售货员的难题某乡有n个村庄（1&lt; n &lt; 20），有一个售货员，他要到各个村庄去售货，各村庄之间的路程s（0 &lt; s &lt; 1000）是已知的，且A村到B村与B村到A村的路大多不同。为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，假设商店所在的村庄为 1，他不知道选择什么样的路线才能使所走的路程最短。请你帮他选择一条最短的路。 输入 村庄数n和各村之间的路程（均是整数）。 输出 最短的路径 样例输入 3 {村庄数}0 2 1 {村庄1到各村的路程}1 0 2 {村庄2到各村的路程}2 1 0 {村庄3到各村的路程} 样例输出 3 题目解读代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define maxn 25int INF=12345678;int n,maps[maxn][maxn];int d[maxn][maxn];int vis[1005];void Floyd()&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(d[i][j]&gt;d[i][k]+d[k][j]) d[i][j]=d[i][k]+d[k][j];&#125;void dfs(int x,int dis,int cnt)//x:current position&#123; if(x==1 &amp;&amp; cnt==n) &#123; INF=min(INF,dis); return; &#125; vis[x]=1; for(int i=1;i&lt;=n;i++) if((dis+maps[x][i]+d[i][1]&lt;INF) &amp;&amp; ((vis[i]==0) || (cnt==n-1 &amp;&amp; i==1))) dfs(i,dis+maps[x][i],cnt+1); vis[x]=0;&#125;int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;maps[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=maps[i][j]; memset(vis,0,sizeof(vis)); Floyd(); dfs(1,0,0); printf("%d\n",INF); &#125; return 0;&#125; 跑跑卡丁车跑跑卡丁车是时下一款流行的网络休闲游戏，你可以在这虚拟的世界里体验驾驶的乐趣。这款游戏的特别之处是你可以通过漂移来获得一种 加速卡，用这种加速卡可以在有限的时间里提高你的速度。为了使问题简单化，我们假设一个赛道分为L段，并且给你通过每段赛道的普通耗时Ai和用加速卡的耗时Bi。加速卡的获得机制是：普通行驶的情况下，每通过1段赛道,可以获得20%的能量(N2O).能量集满后获得一个加速卡(同时能量清0).加速卡最多可以储存2个,也就是说当你有2个加速卡而能量再次集满,那么能量清零但得不到加速卡。一个加速卡只能维持一段赛道，游戏开始时没有加速卡。问题是，跑完n圈最少用时为多少？ 输入 每组输入数据有3行，第一行有2个整数L( 0 &lt; L &lt; 100),N(0 &lt; N &lt; 100)分别表示一圈赛道分为L段和有N圈赛道，接下来两行分别有L个整数Ai和Bi (Ai &gt; Bi). 输出 对于每组输入数据，输出一个整数表示最少的用时. 样例输入 18 19 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 98 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 样例输出 145 题目解读代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int dp[10005][15],a[105],b[105],n,m;int main() &#123; while(cin&gt;&gt;n&gt;&gt;m) &#123; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; for(int i=0; i&lt;n; i++) cin&gt;&gt;b[i]; for(int i=0; i&lt;n*m; i++) &#123; a[i]=a[i%n]; b[i]=b[i%n]; &#125; memset(dp,INF,sizeof(dp)); dp[1][1]=a[0]; for(int i=1; i&lt;n*m; i++) &#123; for(int j=0; j&lt;15; j++) &#123; int k=j+1; if(k==15) k=10; dp[i+1][k]=min(dp[i+1][k],dp[i][j]+a[i]); if(j&gt;=5) dp[i+1][j-5]=min(dp[i+1][j-5],dp[i][j]+b[i]); &#125; &#125; int ans=INF; for(int i=0; i&lt;15; i++) ans=min(ans,dp[n*m][i]); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Renting Boats长江游艇俱乐部在长江上设置了n 个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt; =i&lt; j &lt; =n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n 所需的最少租金。 输入 第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的n-1 行是r(i,j),1&lt; =i&lt; j &lt; =n。 输出 从游艇出租站1 到游艇出租站n所需的最少租金 样例输入 35 157 样例输出 12 题目解读此题可以用Floyd-Warshall算法算法解决，Floyd算法是解决两点间的最短路径的一种算法。Floyd算法的原理是动态规划。 算法思想:如果存在定点k，使得以k做为中介点时，顶点i和顶点j之间的当前距离缩短，则使用顶点k做为顶点i和顶点j之间的中介点，即当dis[i][k] + dis[k][j] &lt; dis[i][j] 时，令 dis[i][j]=dis[i][k] + dis[k][j] 。 算法流程： 枚举顶点k 以顶点k做为中介点，枚举所有顶点i和j 如果dis[i][k] + dis[k][j] &lt; dis[i][j]成立，则 dis[i][j]=dis[i][k] + dis[k][j] 代码 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int dis[205][205]=&#123;0&#125;;int n;int Floyd()&#123; for(int k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(dis[i][k]!=0 &amp;&amp; dis[k][j]!=0 &amp;&amp; dis[i][k]+dis[k][j]&lt;dis[i][j]) dis[i][j]=dis[i][k]+dis[k][j];&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i=0;i&lt;n;i++) &#123; for(int j=i+1;j&lt;n;j++) &#123; cin&gt;&gt;dis[i][j]; &#125; &#125; Floyd(); cout&lt;&lt;dis[0][n-1]&lt;&lt;endl; &#125; return 0;&#125; Jack Strawsn the game of Jack Straws, a number of plastic or wooden “straws” are dumped on the table and players try to remove them one-by-one without disturbing the other straws. Here, we are only concerned with if various pairs of straws are connected by a path of touching straws. You will be given a list of the endpoints for some straws (as if they were dumped on a large piece of graph paper) and then will be asked if various pairs of straws are connected. Note that touching is connecting, but also two straws can be connected indirectly via other connected straws. 输入 A problem consists of multiple lines of input. The first line will be an integer n (1 &lt; n &lt; 13) giving the number of straws on the table. Each of the next n lines contain 4 positive integers, x1 , y1 , x2 and y2 , giving the coordinates, (x1 ; y1 ); (x2 ; y2 ) of the endpoints of a single straw. All coordinates will be less than 100. (Note that the straws will be of varying lengths.) The first straw entered will be known as straw #1, the second as straw #2, and so on. The remaining lines of input (except for the final line) will each contain two positive integers, a and b, both between 1 and n, inclusive. You are to determine if straw a can be connected to straw b. When a = 0 = b, the input is terminated. There will be no illegal input and there are no zero-length straws. 输出 You should generate a line of output for each line containing a pair a and b, except the final line where a = 0 = b. The line should say simply “CONNECTED”, if straw a is connected to straw b, or “NOT CONNECTED”, if straw a is not connected to straw b. For our purposes, a straw is considered connected to itself. 样例输入 71 6 3 34 6 4 94 5 6 71 4 3 53 5 5 55 2 6 35 4 7 21 41 63 36 72 31 30 0 样例输出 CONNECTEDNOT CONNECTEDCONNECTEDCONNECTEDNOT CONNECTEDCONNECTED 题目解读代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int set[20]; struct Point &#123; int x1,x2,y1,y2; Point(int x1 = 0, int x2 = 0, int y1 = 0, int y2 = 0) : x1(x1),x2(x2),y1(y1),y2(y2) &#123;&#125;; void read() &#123; scanf("%d %d %d %d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); &#125; &#125;p[20]; void unit(int n) &#123; for(int i = 1; i &lt;= n; i++) set[i] = i; &#125; int find(int x) &#123; return x == set[x] ? x : set[x] = find(set[x]); &#125; int cross(int x1, int y1, int x2, int y2) &#123; return x1 * y2 - x2 * y1; &#125; int intersection(Point A, Point B) //判断直线相交 &#123; int c[4]; if(max(A.x1,A.x2) &lt; min(B.x1,B.x2) || max(A.y1,A.y2) &lt; min(B.y1,B.y2) || max(B.x1,B.x2) &lt; min(A.x1,A.x2) || max(B.y1,B.y2) &lt; min(A.y1,A.y2) ) return 0; //考虑共线不相交的情况,为快速排斥定理 /*判断两条直线是否相交,即只需判断线是否在另一条线的两端*/ c[0] = cross(A.x2 - A.x1, A.y2 - A.y1, B.x1 - A.x1, B.y1 - A.y1); c[1] = cross(A.x2 - A.x1, A.y2 - A.y1, B.x2 - A.x1, B.y2 - A.y1); c[2] = cross(B.x2 - B.x1, B.y2 - B.y1, A.x1 - B.x1, A.y1 - B.y1); c[3] = cross(B.x2 - B.x1, B.y2 - B.y1, A.x2 - B.x1, A.y2 - B.y1); if(c[0] * c[1] &lt;= 0 &amp;&amp; c[2] * c[3] &lt;= 0) return 1; //运用到了向量的叉乘和点乘的知识; return 0; &#125; int main() &#123; //freopen("in.txt","r",stdin); int n; while(~scanf("%d",&amp;n) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; i++) p[i].read(); unit(n); for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) &#123; if(intersection(p[i],p[j])) &#123; int a = find(i); int b = find(j); if(a != b) set[a] = b; &#125; &#125; &#125; int a,b; while(~scanf("%d %d",&amp;a,&amp;b), a | b) &#123; a = find(a); b = find(b); if(a == b) puts("CONNECTED"); else puts("NOT CONNECTED"); &#125; &#125; return 0; &#125; Coin-collecting by robotSeveral coins are placed in cells of an n×m board. A robot, located in the upper left cell of the board, needs to collect as many of the coins as possible and bring them to the bottom right cell. On each step, the robot can move either one cell to the right or one cell down from its current location. 输入 The fist line is n,m, which 1&lt; = n,m &lt;= 1000.Then, have n row and m col, which has a coin in cell, the cell number is 1, otherwise is 0. 输出 The max number Coin-collecting by robot. 样例输入 5 60 0 0 0 1 00 1 0 1 0 00 0 0 1 0 10 0 1 0 0 11 0 0 0 1 0 样例输出 5 题目解读题目大意 在nxm的方格中有一些硬币，用1代表有硬币，0代表没有硬币。现在让一个机器人来尽可能多的捡硬币，它从左上角出发，每次只能走一步，要么向下走，要么向右走，到右下角时结束。 编号 0 1 2 3 4 5 0 0 0 0 0 1 0 1 0 1 0 1 0 0 2 0 0 0 1 0 1 3 0 0 1 0 0 1 4 1 0 0 0 1 0 建立dp二维数组，把原始数据存入二维数组中，这时从右下角往左上角依次按行列遍历，重新计算dp[i][j]的值。计算方法就是两种选择二选一，要么向下走，要么向右走： 选择下方的数：dp[i][j] += dp[i+1][j] 选择右面的数：dp[i][j] += dp[i][j+1] 状态方程就是： dp[i][j] += max( dp[i+1][j] , dp[i][j+1] ) 最后dp[0][0]就是最大值。 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define max(a,b) ((a&gt;b)?a:b)int dp[1000][1000]=&#123;0&#125;;int main()&#123; int n,m,i,j; cin&gt;&gt;n&gt;&gt;m; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; cin&gt;&gt;dp[i][j]; &#125; &#125; for(i=n-1;i&gt;=0;i--) &#123; for(j=m-1;j&gt;=0;j--) &#123; dp[i][j] += max(dp[i+1][j],dp[i][j+1]); &#125; &#125; printf("%d\r\n",dp[0][0]); return 0;&#125; Coin-row problemThere is a row of n coins whose values are some positive integers c₁, c₂,…,cn, not necessarily distinct. The goal is to pick up the maximum amount of money subject to the constraint that no two coins adjacent in the initial row can be picked up. 输入 Two lines, the first line is n (0&lt; n &lt;=10000), and the second line is value of coin(0&lt; value &lt;= 2^32). 输出 the maximum amount of money. 样例输入 65 1 2 10 6 2 样例输出 17 题目解读题目大意 有一串数字，现在需要取出一些数组，取数规则就是不能选两个相邻的数。现在需要计算在这种规则下，能取到的数字之和最大是多少。 编号 0 1 2 3 4 5 num 5 1 2 10 6 2 dp(i)代表选择到第i个硬币时，能得到的金额数。 以dp(5)为例，此时有两种选择： 选5号（那就不能选4号）：dp(3)+num(5) 不选5号（就可以选4号）：dp(4) 这样就可以推导出状态方程： dp(i) = max( dp(i-2)+num[i] , dp(i-1) ) dp(0) = num[0] dp(1) = max( num[0] , num[1] ) 这样就可以敲代码了，如果使用递归的方法，会产生很多重叠子问题，运算速度慢，效率为O(n^2)。所以不使用递归方法，而是建立一个dp数组，然后循环填表，一次把dp[0],dp[1],dp[2]……的值计算出来，最后最优解即是dp[n-1]。 代码 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define max(a,b) ((a&gt;b)?a:b)int main()&#123; int num[10000],dp[10000]=&#123;0&#125;; int n,i; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;num[i]; &#125; dp[0]=num[0]; dp[1]=max(num[0],num[1]); for(i=2;i&lt;n;i++) &#123; dp[i]=max(dp[i-2]+num[i],dp[i-1]); &#125; printf("%d\r\n",dp[n-1]); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之sklearn]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8Bsklearn%2F</url>
    <content type="text"><![CDATA[Scikit learn 也简称 sklearn, 是机器学习领域当中最知名的 python 模块之一。 Scikit learn模块Scikit learn 也简称 sklearn, 是机器学习领域当中最知名的 python 模块之一。 Sklearn 包含了很多种机器学习的方式: Classification 分类（监督学习） Regression 线性回归（监督学习） Clustering 非监督分类 Dimensionality reduction 数据降维 Model Selection 模型选择 Preprocessing 数据预处理 在股票、房价预测中可以使用线性回归。 其中蓝色圆圈内是判断条件，绿色方框内是可以选择的算法 sklearn 的使用正则化输入正则化含义解释 ： 如果输入特征属于不同范围内，可能有些特征值从0到1，有些特征值从1到1000，那么归一化（normalize）特征值就非常重要了。 具体参考吴恩达课程http://mooc.study.163.com/learn/2001281003?tid=2001391036#/learn/content?type=detail&amp;id=2001701046 12345678910# 将收盘数据正则化，全部化为-1到1之间的数import numpy as npimport pandas as pdfrom sklearn import preprocessing #标准化数据模块def normalize(): data = pd.read_csv("new_day_close.csv") data = data.iloc[:,1:] normalized = preprocessing.scale(data) print(normalized) SVR——Support Vector Regression交叉验证K-CV方法将原始数据分成K组(一般是均分),将每个子集数据分别做一次验证集,其余的K-1组子集数据作为训练集,这样会得到K个模型,用这K个模型最终的验证集的分类准确率的平均数作为此K-CV下分类器的性能指标.K一般大于等于2,实际操作时一般从3开始取,只有在原始数据集合数据量小的时候才会尝试取2.K-CV可以有效的避免过学习以及欠学习状态的发生,最后得到的结果也比较具有说服性。]]></content>
      <categories>
        <category>机器学习</category>
        <category>sklearn</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验二]]></title>
    <url>%2F2018%2F04%2F23%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验二 实验二凸包面积麦兜是个淘气的孩子。一天，他在玩钢笔的时候把墨水洒在了白色的墙上。再过一会，麦兜妈就要回来了，麦兜为了不让妈妈知道这件事情，就想用一个白色的凸多边形把墙上的墨点盖住。你能告诉麦兜最小需要面积多大的凸多边形才能把这些墨点盖住吗？ 现在，给出了这些墨点的坐标，请帮助麦兜计算出覆盖这些墨点的最小凸多边形的面积。 输入 多组测试数据。第一行是一个整数T，表明一共有T组测试数据。每组测试数据的第一行是一个正整数N(0&lt; N &lt; = 105)，表明了墨点的数量。接下来的N行每行包含了两个整数Xi和Yi（0&lt;=Xi,Yi&lt;=2000），表示每个墨点的坐标。每行的坐标间可能包含多个空格。 输出 每行输出一组测试数据的结果，只需输出最小凸多边形的面积。面积是个实数，小数点后面保留一位即可，不需要多余的空格。 样例输入 2 4 0 0 1 0 0 1 1 1 2 0 0 0 1 样例输出 1.0 0.0 题目解读代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int t,n;struct node&#123; int x,y; &#125;data[110],point[110],basic;int direction(node pi,node pj,node pk)&#123; return (pj.x-pi.x)*(pk.y-pi.y)-(pj.y-pi.y)*(pk.x-pi.x);&#125;int dis(node a,node b)&#123; return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);&#125;int cmp(node pj,node pk)&#123; int k=direction(basic,pj,pk); if(k==0) return(dis(basic,pj)&gt;dis(basic,pk)); else return k&gt;0?1:0;&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; int flag=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;data[i].x&gt;&gt;data[i].y; if(data[i].y&lt;data[flag].y||(data[i].y==data[flag].y&amp;&amp;data[i].x&lt;data[flag].x)) flag=i; &#125; if(n&lt;3) &#123; cout&lt;&lt;"0.0\n"; continue; &#125; node zz=data[0]; data[0]=data[flag]; data[flag]=zz; basic=data[0]; sort(data+1,data+n,cmp); int top=0; point[top++]=data[0]; point[top++]=data[1]; point[top++]=data[2]; for(int i=3;i&lt;n;i++) &#123; while(direction(point[top-2],point[top-1],data[i])&lt;0) top--; point[top++]=data[i]; &#125; double sum=0; for(int i=1;i&lt;top-1;i++) sum+=abs(direction(point[0],point[i],point[i+1])); printf("%.1lf\n",sum/2); &#125; return 0;&#125; 变位词如果两个单词的组成字母完全相同，只是字母的排列顺序不一样，则它们就是变位词，两个单词相同也被认为是变位词。如tea 与eat , nic 与cin, ddc与dcd, abc与abc 等。你的任务就是判断它们是否是变位词。 输入 第一行一个N,表示下面有N行测试数据。每行测试数据包括两个单词，如tea eat ,它们之间用空格割开 输出 对于每个测试数据，如果它们是变位词，输出Yes,否则输出No. 样例输入 3 tea eat ddc cdd dee dde 样例输出 Yes Yes No 题目解读策略 对于两个给定字符串，先预排序，排序之后比较是否完全一样，如果完全一样就是变位词，否则不是变位词。 代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int n; char a[105],b[105]; scanf("%d",&amp;n); while(n--) &#123; cin&gt;&gt;a&gt;&gt;b; int len1=strlen(a); int len2=strlen(b); sort(a,a+len1); sort(b,b+len2); if(strcmp(a,b)==0) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; Quick SortQuicksort is a well-known sorting algorithm developed by C. A. R. Hoare that, on average, makes Θ(n log n) comparisons to sort n items. However, in the worst case, it makes Θ(n2) comparisons. Typically, quicksort is significantly faster in practice than other Θ(n log n) algorithms, because its inner loop can be efficiently implemented on most architectures, and in most real-world data it is possible to make design choices which minimize the possibility of requiring quadratic time. Quicksort sorts by employing a divide and conquer strategy to divide a list into two sub-lists. The steps are: 1. Pick an element, called a pivot, from the list. 2. Reorder the list so that all elements which are less than the pivot come before the pivot and so that all elements greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation. 3. Recursively sort the sub-list of lesser elements and the sub-list of greater elements. The base case of the recursion are lists of size zero or one, which are always sorted. The algorithm always terminates because it puts at least one element in its final place on each iteration (the loop invariant). Quicksort in action on a list of random numbers. The horizontal lines are pivot values. Write a program to sort ascending int number by QuickSort ,n less than 50000. 输入 two lows, the first low is numbers , less and equal than 50000. the second low is a set integer numbers 输出 a set integer numbers of sort ascending 样例输入 10 4 2 1 5 7 6 9 8 0 3 样例输出 0 1 2 3 4 5 6 7 8 9 题目解读快排算法 代码 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n,i; int a[50005]; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; sort(a,a+n); for(i=0;i&lt;n;i++) &#123; printf("%d ",a[i]); &#125; printf("\n"); return 0;&#125; PostOffice在一个按照东西和南北方向划分成规整街区的城市里，n个居民点散乱地分布在不同的街区中。用x 坐标表示东西向，用y坐标表示南北向。各居民点的位置可以由坐标(x,y)表示。 街区中任意2 点(x1,y1)和(x2,y2)之间的距离可以用数值|x1-x2|+|y1-y2|度量。 居民们希望在城市中选择建立邮局的最佳位置，使n个居民点到邮局的距离总和最小。 任务：给定n 个居民点的位置,编程计算n 个居民点到邮局的距离总和的最小值。 输入 第1 行是居民点数n，1 &lt; = n &lt; =10000。接下来n 行是居民点的位置，每行2 个整数x 和y，-10000 &lt; =x，y &lt; =10000。 输出 n 个居民点到邮局的距离总和的最小值。 样例输入 5 1 2 2 2 1 3 3 -2 3 3 样例输出 10 题目解读策略 蛮力法。循环比较每两个点之间的距离。 代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n,i,midx,midy; scanf("%d",&amp;n); int x[10005],y[10005]; for(i=0;i&lt;n;i++) &#123; scanf("%d %d",&amp;x[i],&amp;y[i]); &#125; int sum=0; sort(x,x+n); sort(y,y+n); if(n%2==0) &#123; midx=(x[n/2]+x[n/2-1])/2; midy=(y[n/2]+y[n/2-1])/2; &#125; if(n%2!=0) &#123; midx=x[n/2]; midy=y[n/2]; &#125; for(i=0;i&lt;n;i++) &#123; int dis=abs(x[i]-midx)+abs(y[i]-midy); sum+=dis; &#125; printf("%d\n",sum); return 0;&#125; 俄式乘法俄式乘法，又被称为俄国农夫法，它是对两个正整数相乘的非主流算法。假设m和n是两个正整数，我们要计算它们的积。它的主要原理如下： if n is 偶数 n m=n/2 2m else n m=(n-1)/2 2m + m 该算法只包括折半，加倍，相加等几个简单操作，因此实现速度非常快。 输入 两个正整数 n,m。 输出 n和m的乘积。 输出整个求和表达式，运算符与数字之间用一个空格隔开。 样例输入 50 65 样例输出 130 + 1040 + 2080 = 3250 题目解读代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,m,i,k=0; int a[100]=&#123;0&#125;; scanf("%d %d",&amp;n,&amp;m); while(n&gt;1) &#123; if(n%2==0) &#123; n=n/2; m=m*2; &#125; else &#123; n=(n-1)/2; m=2*m; a[k]=m/2; k++; &#125; &#125; int sum=0; for(i=0;i&lt;k;i++) &#123; printf("%d",a[i]); printf(" + "); sum+=a[i]; &#125; printf("%d",m); printf(" = "); printf("%d\n",sum+m); return 0;&#125; 最近对问题设p1=(x1, y1), p2=(x2, y2), …, pn=(xn, yn)是平面上n个点构成的集合S，设计算法找出集合S中距离最近的点对。 输入 多组测试数据，第一行为测试数据组数n（0&lt;n≤100），每组测试数据由两个部分构成，第一部分为一个点的个数m（0&lt;m≤1000），紧接着是m行，每行为一个点的坐标x和y，用空格隔开，（0&lt;x，y≤100000） 输出 每组测试数据输出一行，为该组数据最近点的距离，保留4为小数。 样例输入 2 2 0 0 0 1 3 0 0 1 1 1 0 样例输出 1.0000 1.0000 题目解读策略 蛮力法。循环比较。 代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); while(n--) &#123; int m,i,j,k; scanf("%d",&amp;m); int x[1005],y[1005]; for(k=0;k&lt;m;k++) &#123; scanf("%d %d",&amp;x[k],&amp;y[k]); &#125; double min=10000; for(i=0;i&lt;m;i++) &#123; for(j=i+1;j&lt;m;j++) &#123; double a=(x[j]-x[i])*(x[j]-x[i]); double b=(y[j]-y[i])*(y[j]-y[i]); double dis=sqrt(a+b); if(dis&lt;min) min=dis; &#125; &#125; printf("%.4lf\n",min); &#125; return 0;&#125; 约瑟夫问题的实现n个人围成一个圈，每个人分别标注为1、2、…、n，要求从1号从1开始报数，报到k的人出圈，接着下一个人又从1开始报数，如此循环，直到只剩最后一个人时，该人即为胜利者。例如当n=10,k=4时，依次出列的人分别为4、8、2、7、3、10，9、1、6、5，则5号位置的人为胜利者。给定n个人，请你编程计算出最后胜利者标号数。（要求用单循环链表完成。） 输入 第一行为人数n; 第二行为报数k。 输出 输出最后胜利者的标号数。 样例输入 10 4 样例输出 5 题目解读代码 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int josephus(int n, int m)&#123; int i; int sum=0; for(i=1;i&lt;=n;i++) &#123; sum=(sum+m)%i; &#125; return sum+1;&#125;int main()&#123; int n,k; scanf("%d %d",&amp;n,&amp;k); int ans=josephus(n,k); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验一]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验一 实验一Euclid’s GameStarts with two unequal positive numbers (M,N and M&gt;N) on the board. Two players move in turn. On each move, a player has to write on the board a positive number equal to the difference of two numbers already on the board; this number must be new, i.e., different from all the numbers already on the board. The player who cannot move loses the game. Should you choose to move first or second in this game? According to the above rules, there are two players play tihs game. Assumptions A write a number on the board at first, then B write it. Your task is write a program to judge the winner is A or B. 输入 Two unequal positive numbers M and N , M&gt;N (M&lt;1000000) 输出 A or B 样例输入 3 1 样例输出 A 题目解读翻译 黑板上已经有两个正数M和N（M&gt;N），两个人轮流在黑板上写数组，要求写上的数字必须是黑板上已有数字只差，而且不能重复写已经在黑板上的数字，最后一个不能写数字的人就输了。请问赢家应该先写还是后写？ 策略 如果开始时，两个数字不是倍数关系，那么从M到1所有的数都可以出现，也就是黑板上总共可以出现M个数，减掉原先写在黑板上的两个数，就可以写 M-2 个数； 如果开始时，两个数字是整数倍关系，那么只能出现[M-1N , M-2N, M-3N…]这些数，也就是黑板上总共可以出现M/N个数，减掉原来写在黑板上的两个数，就可以写 M/N-2 个数。 代码 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int a,b,sum; scanf("%d %d",&amp;a,&amp;b); if(a%b==0) sum=a/b-2; else sum=a-2; if(sum%2==0) printf("B\n"); else printf("A\n"); return 0;&#125; 翻煎饼麦兜最喜欢的食物是煎饼，每次在街上看到煎饼摊的时候都会在那里停留几分钟。最吸引麦兜还是煎饼师傅那一手熟练的翻煎饼的技术，一堆煎饼在那里，师傅只需要用铲子翻几下，就让煎饼整齐的叠在了一起。 这天，为了庆祝麦兜被保送上研究生，他从煎饼师傅那里买回来一些煎饼请客。但是麦兜买回的煎饼大小不一，麦兜太想吃煎饼了，他想吃这些煎饼中最大的那个。麦兜还知道同学们也很喜欢煎饼，为了表示他的诚意，他想让同学们先吃，麦兜最后吃，因此，麦兜想把煎饼按照从小到大的顺序叠放在一起，大的在最下面。这样麦兜就可以在最后拿到最大的那一块煎饼了。 现在请你帮助麦兜用煎饼师傅翻煎饼的方法把麦兜买的煎饼从小到大的叠在一起。煎饼师傅的方法是用铲子插入两块煎饼之间，然后将铲子上的煎饼翻一转，这样铲子上第一个煎饼就被翻到了顶上，而原来顶上的煎饼则被翻到了刚才插入铲子的地方。麦兜希望这样翻煎饼的次数最少。 输入 输入包括两行，第一行是一个整数n(1&lt;=n&lt;=1000)，表示煎饼的个数，接下来的一行有n个不相同的整数，整数间用空格隔开，每个整数表示煎饼的大小（直径），左边表示顶部，右边表示底部。 输出 输出为一行，翻煎饼的最少次数 样例输入 5 5 4 2 3 1 样例输出 4 题目解读策略 每次先找最大的，然后把最大的翻到上面，再整体翻一次，最大的就到最下面了。 一个函数找数组中最大数对应的角标； 一个函数实现翻煎饼（把num[a]到num[b]逆序排列）； 一个递归函数反复找最大值和实现翻煎饼的过程。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int num[1005];int times=0;int turn(int a,int b)&#123; int i,j; for(i=a,j=b;i&lt;j;i++,j--) &#123; int t=num[i]; num[i]=num[j]; num[j]=t; &#125; times++;&#125;int FindMax(int a,int b)&#123; int i,max=a; for(i=a;i&lt;=b;i++) &#123; if(num[i]&gt;num[max]) max=i; &#125; return max;&#125;void change(int n)&#123; if(n==0) return; int maxn=FindMax(0,n); if(maxn!=0 &amp;&amp; maxn!=n) &#123; turn(0,maxn); turn(0,n); &#125; if(maxn==0) turn(0,n); change(n-1);&#125;int main()&#123; int n,i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) &#123; scanf("%d",&amp;num[i]); &#125; change(n-1); printf("%d\n",times); return 0;&#125; Locker doorsThere are n lockers in a hallway numbered sequentially from 1 to n. Initially, all the locker doors are closed. You make n passes by the lockers, each time starting with locker #1. On the ith pass, i = 1, 2, …, n, you toggle the door of every ith locker: if the door is closed, you open it, if it is open, you close it. For example, after the first pass every door is open; on the second pass you only toggle the even-numbered lockers (#2, #4, …) so that after the second pass the even doors are closed and the odd ones are opened; the third time through you close the door of locker #3 (opened from the first pass), open the door of locker #6 (closed from the second pass), and so on. After the last pass, which locker doors are open and which are closed? How many of them are open? Your task is write a program to output How many doors are open after the last pass? Assumptions all doors are closed at first. 输入 a positive numbers n, total doors. n&lt;=100000 输出 a positive numbers ，the total of doors opened after the last pass. 样例输入 10 样例输出 3 题目解读翻译 假设走廊上有n把锁，标号为0~n，全部都是锁上的，现在你经过走廊n次，第一次把1的倍数（1,2,3…）的锁打开，第二次把2的倍数（2,4,6…）的锁打开，如果已经打开了就关上，第三次对3的倍数的锁进行类似的操作。请问最后有几把锁是开着的？ 策略 直白的来看，就是从1到n，求每个数的公因数的个数（比如数字6，有1,2,3,6四个公因数，经过4次操作后就是关闭的状态），但是如果循环求n次公因数的个数，就会超时…… 换个角度想一想，什么样的数会有奇数个公因子呢？只有遇到1x1, 2x2, 3x3，… 才会出现奇数个公因子，所以只需要求$\sqrt{n}$的整数部分就可以啦！ 代码 123456789101112#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); int sum=sqrt(n); printf("%d\n",sum); return 0;&#125; The Josephus ProblemThe problem is named after Flavius Josephus, a Jewish historian who participated in and chronicled the Jewish revolt of 66-70C.E. against the Romans. Josephus, as a general, managed to hold the fortress of Jotapata for 47days, but after the fall of the city he took refuge with 40 diehards in a nearby cave. There the rebels voted to perish rather than surrender. Josephus proposed that each man in turn should dispatch his neighbor, the order to be determined by casting lots. Josephus contrived to draw the last lot, and as one of the two surviving men in the cave, he prevailed upon his intended victim to surrender to the Romans. Your task:computint the position of the survivor when there are initially n people. 输入 a Positive Integer n is initially people. n&lt; = 50000 输出 the position of the survivor 样例输入 6 样例输出 5 题目解读翻译 n个人围成一圈报数，报到2的人就会死掉，然后下一个人再接着从1开始报数，直到最后剩下一个人活着，请问最开始应该在几号位才能活到最后？ 策略 一种方法就是模拟，定义一个数组，从1到n全部置为1，对应编号的人死掉就置为0，用另一个数组表示当前报数的数字，等于2时，就从头再来。 还有一种公式法，循环取模。 代码 模拟法 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int n,i; scanf("%d",&amp;n); int s=0,t=0,count=0; int a[50005]=&#123;0&#125;; while(1) &#123; t++; if(t&gt;n) t=1; if(a[t]==0) s++; if(s==2) &#123; s=0; count++; a[t]=1; &#125; if(count==n-1) break; &#125; for(i=1;i&lt;=n;i++) &#123; if(a[i]==0) printf("%d\n",i); &#125; return 0;&#125; 公式法 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int josephus(int n, int m)&#123; int i; int sum=0; for(i=1;i&lt;=n;i++) &#123; sum=(sum+m)%i; &#125; return sum+1;&#125;int main()&#123; int n; scanf("%d",&amp;n); int ans=josephus(n,2); printf("%d\n",ans); return 0;&#125; Binary searchA binary search algorithm (or binary chop) is a technique for finding a particular value in a sorted list. It makes progressively better guesses, and closes in on the sought value, by comparing an element halfway with what has been determined to be an element too low in the list and one too high in the list. A binary search finds the median element in a list, compares its value to the one you are searching for, and determines if it’s greater than, less than, or equal to the one you want. A guess that turns out to be too high becomes the new top of the list, and one too low the new bottom of the list. The binary search’s next guess is halfway between the new list’s top and bottom. Pursuing this strategy iteratively, it narrows the search by a factor 2 each time, and finds your value. A binary search is an example of a divide and conquer algorithm (more specifically a decrease and conquer algorithm) and a dichotomic search (more at Search algorithm). The most common application of binary search is to find a specific value in a sorted list. To cast this in the frame of the guessing game (see Example below), realize that we are now guessing the index, or numbered place, of the value in the list. This is useful because, given the index, other data structures will contain associated information. Suppose a data structure containing the classic collection of name, address, telephone number and so forth has been accumulated, and an array is prepared containing the names, numbered from one to N. A query might be: what is the telephone number for a given name X. To answer this the array would be searched and the index (if any) corresponding to that name determined, whereupon it would be used to report the associated telephone number and so forth. Appropriate provision must be made for the name not being in the list (typically by returning an index value of zero), indeed the question of interest might be only whether X is in the list or not. If the list of names is in sorted order, a binary search will find a given name with far fewer probes than the simple procedure of probing each name in the list, one after the other in a linear search, and the procedure is much simpler than organising a hash table though that would be faster still, typically averaging just over one probe. This applies for a uniform distribution of search items but if it is known that some few items are much more likely to be sought for than the majority then a linear search with the list ordered so that the most popular items are first may do better. The binary search begins by comparing the sought value X to the value in the middle of the list; because the values are sorted, it is clear whether the sought value would belong before or after that middle value, and the search then continues through the correct half in the same way. Only the sign of the difference is inspected: there is no attempt at an interpolation search based on the size of the differences. Your task is to write a program that, given a set numbers of ascending and a key, finding a particular postion in a sorted list. 输入 The input contains one total numbers（N&lt;=5000000） and a find key,followed by a line containing the integer numbers ascending sets. 输出 if find the key in the sorted list, output containing postion in a sorted list, else ouput -1. 样例输入 10 7 0 1 2 3 4 5 6 7 8 9 样例输出 8 题目解读翻译 二分搜索（折半查找）：是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 特别注意 数组要开到5000005，写在函数外面，用iostream，c++提交。 代码 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int num[5000005];int binary(int n,int key)&#123; int first=0,last=n,mid; while(first&lt;=last) &#123; mid=(first+last)/2; if(num[mid]&gt;key) last=mid-1; if(num[mid]&lt;key) first=mid+1; if(num[mid]==key) return mid+1; &#125; return -1;&#125;int main()&#123; int n,i,key; scanf("%d %d",&amp;n,&amp;key); for(i=0;i&lt;n;i++) &#123; scanf("%d",&amp;num[i]); &#125; int ans=binary(n-1,key); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TF在MNIST中的应用]]></title>
    <url>%2F2018%2F04%2F18%2FTF%E5%9C%A8MNIST%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[TensorFlow在MNIST中的应用MNIST数据集简介常用的函数API r1.5tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(logits=prediction, labels=y))tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)tf.layers.conv2d(x_image, 32, 5, 1, ‘same’, activation=tf.nn.relu)tf.layers.max_pooling2d(conv1, 2, 2)tf.layers.dense(flat,10)tf.layers.dropout(output)]]></content>
  </entry>
</search>
