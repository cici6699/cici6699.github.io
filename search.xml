<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT刷题记录（下）]]></title>
    <url>%2F2019%2F02%2F14%2FPAT%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这部分是PAT编号1046—1095的题目。 1046—10551046 划拳划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。 输入格式：输入第一行先给出一个正整数 N（≤100），随后 N 行，每行给出一轮划拳的记录，格式为： 1甲喊 甲划 乙喊 乙划 其中喊是喊出的数字，划是划出的数字，均为不超过 100 的正整数（两只手一起划）。 输出格式：在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。 输入样例：12345658 10 9 125 10 5 103 8 5 1212 18 1 134 16 12 15 输出样例：11 2 要么甲赢乙输，乙喝酒；要么甲输乙赢，甲喝酒。 代码12345678910111213141516#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,a,b,c,d,p1=0,p2=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; if(a+c==b &amp;&amp; a+c!=d) p2++; if(a+c!=b &amp;&amp; a+c==d) p1++; &#125; cout&lt;&lt;p1&lt;&lt;" "&lt;&lt;p2&lt;&lt;endl; return 0;&#125; 1047 编程团体赛编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。 现给定所有队员的比赛成绩，请你编写程序找出冠军队。 输入格式：输入第一行给出一个正整数 N（≤104），即所有参赛队员总数。随后 N 行，每行给出一位队员的成绩，格式为：队伍编号-队员编号 成绩，其中队伍编号为 1 到 1000 的正整数，队员编号为 1 到 10 的正整数，成绩为 0 到 100 的整数。 输出格式：在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。 输入样例：123456763-10 9911-5 87102-1 0102-3 10011-9 893-2 61 输出样例：111 176 前面一部分当做字符串读入，后面一部分当做数组读入，读一个累加一次比较一次。 代码12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int a[10005]=&#123;0&#125;; int n,score,max_s=0,max_t=0; string s; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;s&gt;&gt;score; int t=s.find('-'); int team=stoi(s.substr(0,t)); a[team]+=score; if(a[team]&gt;=max_s) &#123; max_s=a[team]; max_t=team; &#125; &#125; cout&lt;&lt;max_t&lt;&lt;" "&lt;&lt;max_s&lt;&lt;endl; return 0;&#125; 1048 数字加密本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 输入格式：输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 输出格式：在一行中输出加密后的结果。 输入样例：11234567 368782971 输出样例：13695Q8118 a和b的长度可能不一样长，如果不一样长，短的那个前面需要补零，补齐之后再进行运算。 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string a,b,c; cin&gt;&gt;a&gt;&gt;b; reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); if(a.size()&gt;b.size()) b.append(a.size()-b.size(),'0'); if(a.size()&lt;b.size()) a.append(b.size()-a.size(),'0'); for(int i=0;i&lt;b.size();i++) &#123; if(i%2==0) &#123; int temp=((a[i]-'0')+(b[i]-'0'))%13; if(temp==10) c+='J'; else if(temp==11) c+='Q'; else if(temp==12) c+='K'; else c+=to_string(temp); &#125; else &#123; int temp=(b[i]-'0')-(a[i]-'0'); if(temp&lt;0) temp+=10; c+=to_string(temp); &#125; &#125; for(int i=c.size()-1;i&gt;=0;i--) cout&lt;&lt;c[i]; return 0;&#125; 1049 数列的片段和给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。 给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。 输入格式：输入第一行给出一个不超过 105 的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。 输出格式：在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。 输入样例：1240.1 0.2 0.3 0.4 输出样例：15.00 这题用float有两组样例竟然过不了，用double就可以通过。 代码12345678910111213141516#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; double x,sum=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;x; sum+=x*i*(n-i+1); &#125; printf("%.2f",sum); return 0;&#125; 1050 螺旋矩阵本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n列，满足条件：m×n 等于 N；m≥n；且 m−n 取所有可能值中的最小值。 输入格式：输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 104，相邻数字以空格分隔。 输出格式：输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。 输入样例：121237 76 20 98 76 42 53 95 60 81 58 93 输出样例：123498 95 9342 37 8153 20 7658 60 76 这一题好麻烦，螺旋输出需要两个循环，外层循环是有多少轮，内层循环是每次横竖横竖的顺序。最后一组样例很容易超时，找m和n的取值时，只用一层循环就够了；不能开数组，换成vector。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;stdio.h&gt;using namespace std;bool cmp(int a, int b) &#123;return a &gt; b;&#125;int main()&#123; int x,n,m,t=0; cin&gt;&gt;x; for(n=sqrt(double(x));n&gt;=1;n--) &#123; if(x%n==0) &#123; m=x/n; break; &#125; &#125; vector&lt;int&gt; a(x); for(int i=0;i&lt;x;i++) scanf("%d",&amp;a[i]); sort(a.begin(),a.end(),cmp); int level=m/2+m%2; vector&lt;vector&lt;int&gt; &gt; b(m, vector&lt;int&gt;(n)); for(int i=0;i&lt;level;i++) &#123; for(int j=i;j&lt;=n-1-i &amp;&amp; t&lt;=x-1;j++) b[i][j] = a[t++]; for(int j=i+1;j&lt;=m-2-i &amp;&amp; t&lt;=x-1;j++) b[j][n-1-i] = a[t++]; for(int j=n-i-1;j&gt;=i&amp;&amp;t&lt;=x-1;j--) b[m-1-i][j]=a[t++]; for(int j=m-2-i;j&gt;=i+1 &amp;&amp; t&lt;=x-1;j--) b[j][i]=a[t++]; &#125; for (int i=0;i&lt;m;i++) &#123; for (int j=0;j&lt;n;j++) &#123; printf("%d",b[i][j]); if (j!=n-1) printf(" "); &#125; printf("\n"); &#125; return 0;&#125; 1051 复数乘法 （15 分）复数可以写成 (A+Bi) 的常规形式，其中 A 是实部，B 是虚部，i 是虚数单位，满足 i2=−1；也可以写成极坐标下的指数形式 (R×e(Pi))，其中 R 是复数模，P 是辐角，i 是虚数单位，其等价于三角形式 (R(cos(P)+isin(P))。 现给定两个复数的 R 和 P，要求输出两数乘积的常规形式。 输入格式：输入在一行中依次给出两个复数的 R1, P1, R2, P2，数字间以空格分隔。 输出格式：在一行中按照 A+Bi 的格式输出两数乘积的常规形式，实部和虚部均保留 2 位小数。注意：如果 B 是负数，则应该写成 A-|B|i 的形式。 输入样例：12.3 3.5 5.2 0.4 输出样例：1-8.68-8.23i 这一题有一个坑，就是当A或者B大于等于-0.005，小于0的时候，会四舍五入成-0.00，而正确答案应该是0.00，所以这个区间的取值需要单独输出。 代码123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; double r1,p1,r2,p2,a1,a2,b1,b2,A,B; cin&gt;&gt;r1&gt;&gt;p1&gt;&gt;r2&gt;&gt;p2; a1=r1*cos(p1); a2=r2*cos(p2); b1=r1*sin(p1); b2=r2*sin(p2); A=a1*a2-b1*b2; B=a1*b2+a2*b1; if(A+0.005&gt;=0 &amp;&amp; A&lt;0) printf("0.00"); else printf("%.2f",A); if(B&gt;=0) printf("+%.2fi",B); else if(B+0.005&gt;=0 &amp;&amp; B&lt;0) printf("+0.00i"); else printf("%.2fi",B); return 0;&#125; 1052 卖个萌 （20 分）萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的： 1[左手]([左眼][口][右眼])[右手] 现给出可选用的符号集合，请你按用户的要求输出表情。 输入格式：输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 []内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。 之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。 输出格式：对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 Are you kidding me? @\/@。 输入样例：12345678[╮][╭][o][~\][/~] [&lt;][&gt;] [╯][╰][^][-][=][&gt;][&lt;][@][⊙][Д][▽][_][ε][^] ...41 1 2 2 26 8 1 5 53 3 4 3 32 10 3 9 3 输出样例：1234╮(╯▽╰)╭&lt;(@Д=)/~o(^ε^)oAre you kidding me? @\/@ 这题太骚了！首先不知道每一种表情各有多少个，每个表情符号的位数也不确定，所以用2维vector存储。然后入读的过程也很麻烦，需要找到“[”和”]”然后把这中间的子字符存入vector中。输出的时候，要判断每个数字是否大于0而且小于对应vector的长度，如果有一个不满足就要输出那句话，那句话里面还有一个斜杠是转义字符，需要输2次才可以避免转义。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; vector&lt;vector&lt;string&gt; &gt;v; for(int i=0;i&lt;3;i++) &#123; string s; getline(cin,s); vector&lt;string&gt; row; int j=0,k=0; while(j&lt;s.size()) &#123; if(s[j]=='[') &#123; while(k++&lt;s.size()) &#123; if(s[k]==']') &#123; row.push_back(s.substr(j+1,k-j-1)); break; &#125; &#125; &#125; j++; &#125; v.push_back(row); &#125; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; int a,b,c,d,e; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e; if(a&gt;v[0].size() || b&gt;v[1].size() || c&gt;v[2].size() || d&gt;v[1].size() || e&gt;v[0].size() || a&lt;1 || b&lt;1 ||c&lt;1 || d&lt;1 || e&lt;1) &#123; cout&lt;&lt;"Are you kidding me? @\\/@"&lt;&lt;endl; continue; &#125; else cout&lt;&lt;v[0][a-1]&lt;&lt;"("&lt;&lt;v[1][b-1]&lt;&lt;v[2][c-1]&lt;&lt;v[1][d-1]&lt;&lt;")"&lt;&lt;v[0][e-1]&lt;&lt;endl; &#125; return 0;&#125; 1053 住房空置率 （20 分）在不打扰居民的前提下，统计住房空置率的一种方法是根据每户用电量的连续变化规律进行判断。判断方法如下： 在观察期内，若存在超过一半的日子用电量低于某给定的阈值 e，则该住房为“可能空置”； 若观察期超过某给定阈值 D 天，且满足上一个条件，则该住房为“空置”。 现给定某居民区的住户用电量数据，请你统计“可能空置”的比率和“空置”比率，即以上两种状态的住房占居民区住房总套数的百分比。 输入格式：输入第一行给出正整数 N（≤1000），为居民区住房总套数；正实数 e，即低电量阈值；正整数 D，即观察期阈值。随后 N 行，每行按以下格式给出一套住房的用电量数据： K E1 E2 … EK 其中 K 为观察的天数，Ei 为第 i 天的用电量。 输出格式：在一行中输出“可能空置”的比率和“空置”比率的百分比值，其间以一个空格分隔，保留小数点后 1 位。 输入样例：1234565 0.5 106 0.3 0.4 0.5 0.2 0.8 0.610 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.55 0.4 0.3 0.5 0.1 0.711 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.111 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1 输出样例：140.0% 20.0% （样例解释：第2、3户为“可能空置”，第4户为“空置”，其他户不是空置。） 总算遇到一个简单的题目，和上一题一样都是20分，难度完全不一样好吗！ 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int N,D,cnt1=0,cnt2=0; double e; cin&gt;&gt;N&gt;&gt;e&gt;&gt;D; for(int i=0;i&lt;N;i++) &#123; int n,cnt=0; double t; cin&gt;&gt;n; for(int j=0;j&lt;n;j++) &#123; cin&gt;&gt;t; if(t&lt;e) cnt++; &#125; if(cnt&gt;n/2 &amp;&amp; n&gt;D) cnt2++; else if(cnt&gt;n/2) cnt1++; &#125; double rate1=cnt1/(N*1.0); double rate2=cnt2/(N*1.0); printf("%.1f",rate1*100);cout&lt;&lt;"%"&lt;&lt;" "; printf("%.1f",rate2*100);cout&lt;&lt;"%"&lt;&lt;endl; return 0;&#125; 1054 求平均值 （20 分）本题的基本要求非常简单：给定 N 个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。 输入格式：输入第一行给出正整数 N（≤100）。随后一行给出 N 个实数，数字间以一个空格分隔。 输出格式：对每个非法输入，在一行中输出 ERROR: X is not a legal number，其中 X 是输入。最后在一行中输出结果：The average of K numbers is Y，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 Undefined 替换 Y。如果 K 为 1，则输出 The average of 1 number is Y。 输入样例 1：1275 -3.2 aaa 9999 2.3.4 7.123 2.35 输出样例 1：12345ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38 输入样例 2：122aaa -9999 输出样例 2：123ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefined 先开始想的是每一个都读成string类型，然后分别写两个函数，判断输入进来的string类型数据是否是整数或者是2位小数的浮点数，发现太麻烦，做不下去了。网上查的sscanf和sprintf，指定格式的输入输出，现在还没有太懂。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,cnt=0; char a[105],b[105]; double temp,sum=0.0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; scanf("%s",a); sscanf(a,"%lf",&amp;temp); sprintf(b,"%.2f",temp); int flag=0; for(int j=0;j&lt;strlen(a);j++) &#123; if(a[j]!=b[j]) flag=1; &#125; if(flag==1 || temp&gt;1000 || temp&lt;-1000) &#123; printf("ERROR: %s is not a legal number\n", a); continue; &#125; else &#123;sum+=temp;cnt++;&#125; &#125; if(cnt==1) printf("The average of 1 number is %.2f", sum); else if(cnt&gt;0) printf("The average of %d numbers is %.2f",cnt,sum/cnt); else printf("The average of 0 numbers is Undefined"); return 0;&#125; 1056—10651056 组合数的和 （15 分）给定 N 个非 0 的个位数字，用其中任意 2 个数字都可以组合成 1 个 2 位的数字。要求所有可能组合出来的 2 位数字的和。例如给定 2、5、8，则可以组合出：25、28、52、58、82、85，它们的和为330。 输入格式：输入在第一行中给出 N（1 &lt; N &lt; 10），随后一行给出 N 个不同的非 0 个位数字。数字间以空格分隔。 输出格式：输出所有可能组合出来的2位数字的和。 输入样例：1232 8 5 输出样例：1330 每个数做为十位数会出现n-1次，做为个位数也会出现n-1次。 代码123456789101112131415#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,num,sum=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;num; sum+=num*11*(n-1); &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 1057 数零壹 （20 分）给定一串长度不超过 105 的字符串，本题要求你将其中所有英文字母的序号（字母 a-z 对应序号 1-26，不分大小写）相加，得到整数 N，然后再分析一下 N 的二进制表示中有多少 0、多少 1。例如给定字符串 PAT (Basic)，其字母序号之和为：16+1+20+2+1+19+9+3=71，而 71 的二进制是 1000111，即有 3 个 0、4 个 1。 输入格式：输入在一行中给出长度不超过 105、以回车结束的字符串。 输出格式：在一行中先后输出 0 的个数和 1 的个数，其间以空格分隔。 输入样例：1PAT (Basic) 输出样例：13 4 一个一个检查并翘课。 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string s; int sum=0,num=0,cnt0=0,cnt1=0; int ans[10005]; getline(cin,s); for(int i=0;i&lt;s.size();i++) &#123; if(s[i]&gt;='a' &amp;&amp; s[i]&lt;='z') sum+=(s[i]-'a')+1; if(s[i]&gt;='A' &amp;&amp; s[i]&lt;='Z') sum+=(s[i]-'A')+1; &#125; while(sum!=0) &#123; if(sum%2==0) cnt0++; else cnt1++; sum=sum/2; &#125; cout&lt;&lt;cnt0&lt;&lt;" "&lt;&lt;cnt1&lt;&lt;endl; return 0;&#125; 1059 C语言竞赛 （20 分）C 语言竞赛是浙江大学计算机学院主持的一个欢乐的竞赛。既然竞赛主旨是为了好玩，颁奖规则也就制定得很滑稽： 0、冠军将赢得一份“神秘大奖”（比如很巨大的一本学生研究论文集……）。 1、排名为素数的学生将赢得最好的奖品 —— 小黄人玩偶！ 2、其他人将得到巧克力。 给定比赛的最终排名以及一系列参赛者的 ID，你要给出这些参赛者应该获得的奖品。 输入格式：输入第一行给出一个正整数 N（≤104），是参赛者人数。随后 N 行给出最终排名，每行按排名顺序给出一位参赛者的 ID（4 位数字组成）。接下来给出一个正整数 K 以及 K 个需要查询的 ID。 输出格式：对每个要查询的 ID，在一行中输出 ID: 奖品，其中奖品或者是 Mystery Award（神秘大奖）、或者是 Minion（小黄人）、或者是 Chocolate（巧克力）。如果所查 ID 根本不在排名里，打印 Are you kidding?（耍我呢？）。如果该 ID 已经查过了（即奖品已经领过了），打印 ID: Checked（不能多吃多占）。 输入样例：123456789101112131461111666688881234555500016888800011111222288882222 输出样例：1234568888: Minion0001: Chocolate1111: Mystery Award2222: Are you kidding?8888: Checked2222: Are you kidding? 这题我一开始是用数组a[i]=j，没读入一个 i 递增一个代表排序，j 代表 i 序号对应的选手，但是查找的时候就需要循环，然后最后两组用例就超时过不了。后来换成把数组下标（a[i]中的 i 作为选手id），对应的值为1,2,3,4就对应四种情况的输出。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int rankk[10005]=&#123;0&#125;;int prim(int n)&#123; if(n&lt;=1) return 0; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123;return 0;break;&#125; &#125; return 1;&#125;int main()&#123; int n,m,id; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;id; if(i==1) rankk[id]=1; else if(prim(i)) rankk[id]=2; else rankk[id]=3; &#125; cin&gt;&gt;m; for(int j=0;j&lt;m;j++) &#123; cin&gt;&gt;id; if(rankk[id]==0) printf("%04d: Are you kidding?\n",id); else if(rankk[id]==1) &#123;printf("%04d: Mystery Award\n",id);rankk[id]=4;&#125; else if(rankk[id]==2) &#123;printf("%04d: Minion\n",id);rankk[id]=4;&#125; else if(rankk[id]==3) &#123;printf("%04d: Chocolate\n",id);rankk[id]=4;&#125; else if(rankk[id]==4) &#123;printf("%04d: Checked\n",id);&#125; &#125; return 0;&#125; 1060 爱丁顿数 （25 分）英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。 现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。 输入格式：输入第一行给出一个正整数 N (≤105)，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。 输出格式：在一行中给出 N 天的爱丁顿数。 输入样例：12106 7 6 9 3 10 8 2 7 8 输出样例：16 这题相比于前面几个20分的题目甚至还简单一些……只要题目读懂了，暴力就可以过（我一开始就对题目有些误解，误解在于这个“有”字，也就是说天数可以大于e，我以为只能等于e，如果是等于e的话，只能得18分，改成大于等于e就可以满分了。）后来看网上别人的代码，都是先排序，我真的是纯粹的暴力模拟…… 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int a[100005]=&#123;0&#125;;int main()&#123; int n,e,flag=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int k=n;k&gt;=0;k--) &#123; int cnt=0; e=k; for(int i=1;i&lt;=n;i++) &#123; if(a[i]&gt;e) cnt++; &#125; if(cnt&gt;=e) &#123;flag=1;cout&lt;&lt;e&lt;&lt;endl;break;&#125; &#125; if(flag==0) &lt;&lt;"0"&lt;&lt;endl; return 0;&#125; 1061 判断题 （15 分）判断题的评判很简单，本题就要求你写个简单的程序帮助老师判题并统计学生们判断题的得分。 输入格式：输入在第一行给出两个不超过 100 的正整数 N 和 M，分别是学生人数和判断题数量。第二行给出 M 个不超过 5 的正整数，是每道题的满分值。第三行给出每道题对应的正确答案，0 代表“非”，1 代表“是”。随后 N 行，每行给出一个学生的解答。数字间均以空格分隔。 输出格式：按照输入的顺序输出每个学生的得分，每个分数占一行。 输入样例：1234563 62 1 3 3 4 50 0 1 0 1 10 1 1 0 0 11 0 1 0 1 01 1 0 0 1 1 输出样例：123131112 循环入读到数组，再循环判断累加。 代码12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int score[105],right[105],stu[105]; int N,M,ans; cin&gt;&gt;N&gt;&gt;M; for(int i=0;i&lt;M;i++) cin&gt;&gt;score[i]; for(int i=0;i&lt;M;i++) cin&gt;&gt;right[i]; for(int i=0;i&lt;N;i++) &#123; int sum=0; for(int j=0;j&lt;M;j++) &#123; cin&gt;&gt;ans; if(ans==right[j]) sum+=score[j]; &#125; stu[i]=sum; &#125; for(int i=0;i&lt;N;i++) cout&lt;&lt;stu[i]&lt;&lt;endl; return 0;&#125; 1062 最简分数 （20 分）一个分数一般写成两个整数相除的形式：N/M，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。 现给定两个不相等的正分数 N1/M1 和 N2/M2，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。 输入格式：输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。 输出格式：在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。 输入样例：17/18 13/20 12 输出样例：15/12 7/12 又被那个double精度的问题坑到了。左边界的范围是强转int后+1的值，右边界是强转int后-0.001的值，我又没有-0.001，哭了。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int fun(int a,int b)&#123; while(a!=b) &#123; if(a&gt;b) a=a-b; else if(a&lt;b) b=b-a; &#125; if(a==b &amp;&amp; a!=1) return 1; else return 0;&#125;int main()&#123; int num[10005]; int n1,n2,m1,m2,k,p=0; scanf("%d/%d %d/%d %d",&amp;n1,&amp;m1,&amp;n2,&amp;m2,&amp;k); float x1=(n1/(m1*1.0))*k; float x2=(n2/(m2*1.0))*k; if(x1&gt;x2) &#123;double t=x1;x1=x2;x2=t;&#125; for(int i=x1+1;i&lt;x2-0.001;i++) &#123; if(fun(i,k)==0) num[p++]=i; &#125; cout&lt;&lt;num[0]&lt;&lt;"/"&lt;&lt;k; if(p&gt;0) &#123; for(int i=1;i&lt;p;i++) cout&lt;&lt;" "&lt;&lt;num[i]&lt;&lt;"/"&lt;&lt;k; &#125; return 0;&#125; 1063 计算谱半径 （20 分）在数学中，矩阵的“谱半径”是指其特征值的模集合的上确界。换言之，对于给定的 n 个复数空间的特征值 { a1+b1i,⋯,an+bni }，它们的模为实部与虚部的平方和的开方，而“谱半径”就是最大模。 现在给定一些复数空间的特征值，请你计算并输出这些特征值的谱半径。 输入格式：输入第一行给出正整数 N（≤ 10 000）是输入的特征值的个数。随后 N 行，每行给出 1 个特征值的实部和虚部，其间以空格分隔。注意：题目保证实部和虚部均为绝对值不超过 1000 的整数。 输出格式：在一行中输出谱半径，四舍五入保留小数点后 2 位。 输入样例：12345650 12 0-1 03 30 -3 输出样例：14.24 没话说，送分题。 代码123456789101112131415161718#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,a,b; double max=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; double res=sqrt(a*a+b*b); if(res&gt;max) max=res; &#125; printf("%.2f",max); return 0;&#125; 1064 朋友数 （20 分）如果两个整数各位数字的和是一样的，则被称为是“朋友数”，而那个公共的和就是它们的“朋友证号”。例如 123 和 51 就是朋友数，因为 1+2+3 = 5+1 = 6，而 6 就是它们的朋友证号。给定一些整数，要求你统计一下它们中有多少个不同的朋友证号。 输入格式：输入第一行给出正整数 N。随后一行给出 N 个正整数，数字间以空格分隔。题目保证所有数字小于 104。 输出格式：首先第一行输出给定数字中不同的朋友证号的个数；随后一行按递增顺序输出这些朋友证号，数字间隔一个空格，且行末不得有多余空格。 输入样例：128123 899 51 998 27 33 36 12 输出样例：1243 6 9 26 简单题，没有什么坑。 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,cnt=0; cin&gt;&gt;n; string a; int b[100005]=&#123;0&#125;; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a; int temp=0; for(int j=0;j&lt;a.size();j++) &#123; temp+=(a[j]-'0'); &#125; b[i]=temp; &#125; sort(b,b+n); for(int i=1;i&lt;n;i++) &#123; if(b[i]!=b[i-1]) cnt++; &#125; cout&lt;&lt;cnt+1&lt;&lt;endl; cout&lt;&lt;b[0]; for(int i=1;i&lt;n;i++) &#123; if(b[i]!=b[i-1]) cout&lt;&lt;" "&lt;&lt;b[i]; &#125; return 0;&#125; 1065 单身狗 （25 分）“单身狗”是中文对于单身人士的一种爱称。本题请你从上万人的大型派对中找出落单的客人，以便给予特殊关爱。 输入格式：输入第一行给出一个正整数 N（≤ 50 000），是已知夫妻/伴侣的对数；随后 N 行，每行给出一对夫妻/伴侣——为方便起见，每人对应一个 ID 号，为 5 位数字（从 00000 到 99999），ID 间以空格分隔；之后给出一个正整数 M（≤ 10 000），为参加派对的总人数；随后一行给出这 M 位客人的 ID，以空格分隔。题目保证无人重婚或脚踩两条船。 输出格式：首先第一行输出落单客人的总人数；随后第二行按 ID 递增顺序列出落单的客人。ID 间用 1 个空格分隔，行的首尾不得有多余空格。 输入样例：123456311111 2222233333 4444455555 66666755555 44444 10000 88888 22222 11111 23333 输出样例：12510000 23333 44444 55555 88888 这一次做为25分的题目其实没有很难，有个点一开始没注意到就是如果输入的是int，然后是0开头，输出的时候就会把0省略掉，所以应该用“05d”输出，这个0也不能少，否则就会变成空格。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int a[100005]=&#123;0&#125;;int b[100005];int main()&#123; int n,m,id,id1,id2,cnt=0,cntt=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;id1&gt;&gt;id2; a[id1]=1;a[id2]=1; b[id1]=id2;b[id2]=id1; &#125; cin&gt;&gt;m; vector&lt;int&gt; c; vector&lt;int&gt; d; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;id; if(a[id]==0) &#123;cnt++;c.push_back(id);&#125; else d.push_back(id); &#125; for(int i=0;i&lt;d.size();i++) &#123; int flag=0; int temp=b[d[i]]; for(int j=0;j&lt;d.size();j++) &#123; if(temp==d[j]) flag=1; &#125; if(flag==0) &#123;cntt++;c.push_back(d[i]);&#125; &#125; cout&lt;&lt;cnt+cntt&lt;&lt;endl; sort(c.begin(),c.end()); if(cnt+cntt==0) return 0; else if(cnt+cntt==1) printf("%05d",c[0]); else &#123; printf("%05d",c[0]); for(int i=1;i&lt;c.size();i++) &#123; printf(" %05d",c[i]); &#125; &#125; return 0;&#125; 1066—10751066 图像过滤 （15 分）图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。 输入格式：输入在第一行给出一幅图像的分辨率，即两个正整数 M 和 N（0&lt;M,N≤500），另外是待过滤的灰度值区间端点 A 和 B（0≤A&lt;B≤255）、以及指定的替换灰度值。随后 M 行，每行给出 N 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。 输出格式：输出按要求过滤后的图像。即输出 M 行，每行 N 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 000），其间以一个空格分隔。行首尾不得有多余空格。 输入样例：12343 5 100 150 03 189 254 101 119150 233 151 99 10088 123 149 0 255 输出样例：123003 189 254 000 000000 233 151 099 000088 000 000 000 255 二维数组。 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int pic[505][505];int main()&#123; int m,n,a,b,k; cin&gt;&gt;m&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;k; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; cin&gt;&gt;pic[i][j]; if(pic[i][j]&gt;=a &amp;&amp; pic[i][j]&lt;=b) pic[i][j]=k; &#125; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(j==0) printf("%03d",pic[i][j]); else printf(" %03d",pic[i][j]); &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 1067 试密码 （20 分）当你试图登录某个系统却忘了密码时，系统一般只会允许你尝试有限多次，当超出允许次数时，账号就会被锁死。本题就请你实现这个小功能。 输入格式：输入在第一行给出一个密码（长度不超过 20 的、不包含空格、Tab、回车的非空字符串）和一个正整数 N（≤ 10），分别是正确的密码和系统允许尝试的次数。随后每行给出一个以回车结束的非空字符串，是用户尝试输入的密码。输入保证至少有一次尝试。当读到一行只有单个 # 字符时，输入结束，并且这一行不是用户的输入。 输出格式：对用户的每个输入，如果是正确的密码且尝试次数不超过 N，则在一行中输出 Welcome in，并结束程序；如果是错误的，则在一行中按格式输出 Wrong password: 用户输入的错误密码；当错误尝试达到 N 次时，再输出一行 Account locked，并结束程序。 输入样例 1：123456Correct%pw 3correct%pwCorrect@PWwhatisthepassword!Correct%pw# 输出样例 1：1234Wrong password: correct%pwWrong password: Correct@PWWrong password: whatisthepassword!Account locked 输入样例 2：123456cool@gplt 3coolman@gpltcoollady@gpltcool@gplttry again# 输出样例 2：123Wrong password: coolman@gpltWrong password: coollady@gpltWelcome in 循环用getline读入字符串的时候，如果前面还有读入的其他东西，需要加上一个getchar()函数吸收回车。这道题在while循环里面满足条件了就会break，所以在编译器里测试的时候看到输出后立马就终止了，但是提交上去没有影响。 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string right,password; int n,cnt=0; cin&gt;&gt;right&gt;&gt;n; getchar(); while(1) &#123; getline(cin,password); if(password=="#") break; cnt++; if(password==right &amp;&amp; cnt&lt;=n) &#123;cout&lt;&lt;"Welcome in"&lt;&lt;endl;break;&#125; else if(password!=right &amp;&amp; cnt&lt;=n) &#123; cout&lt;&lt;"Wrong password: "&lt;&lt;password&lt;&lt;endl; if(cnt==n) &#123;cout&lt;&lt;"Account locked"&lt;&lt;endl;break;&#125; &#125; &#125; return 0;&#125; 1069 微博转发抽奖 （20 分）小明 PAT 考了满分，高兴之余决定发起微博转发抽奖活动，从转发的网友中按顺序每隔 N 个人就发出一个红包。请你编写程序帮助他确定中奖名单。 输入格式：输入第一行给出三个正整数 M（≤ 1000）、N 和 S，分别是转发的总量、小明决定的中奖间隔、以及第一位中奖者的序号（编号从 1 开始）。随后 M 行，顺序给出转发微博的网友的昵称（不超过 20 个字符、不包含空格回车的非空字符串）。 注意：可能有人转发多次，但不能中奖多次。所以如果处于当前中奖位置的网友已经中过奖，则跳过他顺次取下一位。 输出格式：按照输入的顺序输出中奖名单，每个昵称占一行。如果没有人中奖，则输出 Keep going...。 输入样例 1：123456789109 3 2Imgonnawin!PickMePickMeMeMeeeLookHereImgonnawin!TryAgainAgainTryAgainAgainImgonnawin!TryAgainAgain 输出样例 1：123PickMeImgonnawin!TryAgainAgain 输入样例 2：1232 3 5Imgonnawin!PickMe 输出样例 2：1Keep going... 用vector存储所有人的名字和抽中的人，然后遇到抽中的位置就检查抽中的人中是否存在，不存在就push进去，存在的话，i的值就变成 i-(n-1)，相当于就是下一次循环的时候增加了一个。如果中奖名单的size为0，就表示没有人抽中，输出指定内容。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int m,n,s; string name; vector &lt;string&gt; all_name; vector &lt;string&gt; lucky; cin&gt;&gt;m&gt;&gt;n&gt;&gt;s; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;name; all_name.push_back(name); &#125; for(int i=s-1;i&lt;m;i=i+n) &#123; int flag=0; string temp=all_name[i]; for(int j=0;j&lt;lucky.size();j++) &#123; if(lucky[j]==temp) &#123;flag=1;break;&#125; &#125; if(flag==0) lucky.push_back(temp); else if(flag==1) i=i-(n-1); &#125; for(int i=0;i&lt;lucky.size();i++) cout&lt;&lt;lucky[i]&lt;&lt;endl; if(lucky.size()==0) cout&lt;&lt;"Keep going..."&lt;&lt;endl; return 0;&#125; 1070 结绳 （25 分）给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。 给定 N 段绳子的长度，你需要找出它们能串成的绳子的最大长度。 输入格式：每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 N (2≤N≤104)；第 2 行给出 N 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过104。 输出格式：在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。 输入样例：12810 15 12 3 4 13 1 15 输出样例：114 每次都是已有的长度加上新来的绳子的总和的一半，所以要尽量把长的绳子放到后面，先排序，再循环相加除以2。 代码123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; int a[10005]; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); int res=a[0]; for(int i=1;i&lt;n;i++) res=(res+a[i])/2; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; 1071 小赌怡情 （15 分）常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。 注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。 输入格式：输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字： 1n1 b t n2 其中 n1 和 n2 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。b 为 0 表示玩家赌小，为 1 表示玩家赌大。t 表示玩家下注的筹码数，保证在整型范围内。 输出格式：对每一次游戏，根据下列情况对应输出（其中 t 是玩家下注量，x 是玩家当前持有的筹码量）： 玩家赢，输出 Win t! Total = x.； 玩家输，输出 Lose t. Total = x.； 玩家下注超过持有的筹码量，输出 Not enough tokens. Total = x.； 玩家输光后，输出 Game Over. 并结束程序。 输入样例 1：12345100 48 0 100 23 1 50 15 1 200 67 0 200 8 输出样例 1：1234Win 100! Total = 200.Lose 50. Total = 150.Not enough tokens. Total = 150.Not enough tokens. Total = 150. 输入样例 2：12345100 48 0 100 23 1 200 15 1 200 67 0 200 8 输出样例 2：123Win 100! Total = 200.Lose 200. Total = 0.Game Over. 循环读入并判断。 代码1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int T,K,n1,b,t,n2; cin&gt;&gt;T&gt;&gt;K; for(int i=0;i&lt;K;i++) &#123; cin&gt;&gt;n1&gt;&gt;b&gt;&gt;t&gt;&gt;n2; if(T&lt;=0) &#123;cout&lt;&lt;"Game Over."&lt;&lt;endl;break;&#125; else if(t&gt;T) cout&lt;&lt;"Not enough tokens. Total = "&lt;&lt;T&lt;&lt;"."&lt;&lt;endl; else if((n2&lt;n1 &amp;&amp; b==0) || (n2&gt;n1 &amp;&amp; b==1)) &#123; T+=t; cout&lt;&lt;"Win "&lt;&lt;t&lt;&lt;"! Total = "&lt;&lt;T&lt;&lt;"."&lt;&lt;endl; &#125; else if((n2&lt;n1 &amp;&amp; b==1) || (n2&gt;n1 &amp;&amp; b==0)) &#123; T-=t; if(T&gt;=0) cout&lt;&lt;"Lose "&lt;&lt;t&lt;&lt;". Total = "&lt;&lt;T&lt;&lt;"."&lt;&lt;endl; else &#123;cout&lt;&lt;"Game Over."&lt;&lt;endl;break;&#125; &#125; &#125; return 0;&#125; 1072 开学寄语 （20 分）下图是上海某校的新学期开学寄语：天将降大任于斯人也，必先删其微博，卸其 QQ，封其电脑，夺其手机，收其 ipad，断其 wifi，使其百无聊赖，然后，净面、理发、整衣，然后思过、读书、锻炼、明智、开悟、精进。而后必成大器也！ 本题要求你写个程序帮助这所学校的老师检查所有学生的物品，以助其成大器。 输入格式：输入第一行给出两个正整数 N（≤ 1000）和 M（≤ 6），分别是学生人数和需要被查缴的物品种类数。第二行给出 M 个需要被查缴的物品编号，其中编号为 4 位数字。随后 N 行，每行给出一位学生的姓名缩写（由 1-4 个大写英文字母组成）、个人物品数量 K（0 ≤ K ≤ 10）、以及 K 个物品的编号。 输出格式：顺次检查每个学生携带的物品，如果有需要被查缴的物品存在，则按以下格式输出该生的信息和其需要被查缴的物品的信息（注意行末不得有多余空格）： 1姓名缩写: 物品编号1 物品编号2 …… 最后一行输出存在问题的学生的总人数和被查缴物品的总数。 输入样例：1234564 22333 6666CYLL 3 1234 2345 3456U 4 9966 6666 8888 6666GG 2 2333 7777JJ 3 0012 6666 2333 输出样例：1234U: 6666 6666GG: 2333JJ: 6666 23333 5 又被四位数的问题坑到了，不能用cout，而要用printf(%04d)的形式，避免要输出的数第一位是0的情况。 代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int a[10005]=&#123;0&#125;;int main()&#123; int N,M,t,K,cnt_name=0,cnt_thing=0; string name; cin&gt;&gt;N&gt;&gt;M; for(int i=0;i&lt;M;i++) &#123; cin&gt;&gt;t; a[t]=1; &#125; for(int i=0;i&lt;N;i++) &#123; cin&gt;&gt;name&gt;&gt;K; int flag=0; for(int j=0;j&lt;K;j++) &#123; cin&gt;&gt;t; if(a[t]==1) &#123; cnt_thing++; if(flag==0) &#123;cout&lt;&lt;name&lt;&lt;": ";printf("%04d",t);flag=1;cnt_name++;&#125; else if(flag==1) printf(" %04d",t); &#125; &#125; if(flag==1) cout&lt;&lt;endl; &#125; cout&lt;&lt;cnt_name&lt;&lt;" "&lt;&lt;cnt_thing&lt;&lt;endl; return 0;&#125; 1074 宇宙无敌加法器 （20 分）地球人习惯使用十进制数，并且默认一个数字的每一位都是十进制的。而在 PAT 星人开挂的世界里，每个数字的每一位都是不同进制的，这种神奇的数字称为“PAT数”。每个 PAT 星人都必须熟记各位数字的进制表，例如“……0527”就表示最低位是 7 进制数、第 2 位是 2 进制数、第 3 位是 5 进制数、第 4 位是 10 进制数，等等。每一位的进制 d 或者是 0（表示十进制）、或者是 [2，9] 区间内的整数。理论上这个进制表应该包含无穷多位数字，但从实际应用出发，PAT 星人通常只需要记住前 20 位就够用了，以后各位默认为 10 进制。 在这样的数字系统中，即使是简单的加法运算也变得不简单。例如对应进制表“0527”，该如何计算“6203 + 415”呢？我们得首先计算最低位：3 + 5 = 8；因为最低位是 7 进制的，所以我们得到 1 和 1 个进位。第 2 位是：0 + 1 + 1（进位）= 2；因为此位是 2 进制的，所以我们得到 0 和 1 个进位。第 3 位是：2 + 4 + 1（进位）= 7；因为此位是 5 进制的，所以我们得到 2 和 1 个进位。第 4 位是：6 + 1（进位）= 7；因为此位是 10 进制的，所以我们就得到 7。最后我们得到：6203 + 415 = 7201。 输入格式：输入首先在第一行给出一个 N 位的进制表（0 &lt; N ≤ 20），以回车结束。 随后两行，每行给出一个不超过 N 位的非负的 PAT 数。 输出格式：在一行中输出两个 PAT 数之和。 输入样例：1233052706203415 输出样例：17201 这一题我提交了n遍才过，枯了！有两个坑，一个是如果没有需要输出的内容，需要输出0，这个占1分。还有一个坑是，有可能有进位的情况，那就需要先输出一个1（最多进位是1啦），进位问题占4分。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int val[25]; int sum[25]; sum[0]=0; string mapp,a,b; getline(cin,mapp); getline(cin,a); getline(cin,b); reverse(mapp.begin(),mapp.end()); reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); if(a.size()&gt;b.size()) b.insert(b.end(),a.size()-b.size(),'0'); if(a.size()&lt;b.size()) a.insert(a.end(),b.size()-a.size(),'0'); int p=0; for(int i=0;i&lt;a.size();i++) &#123; int temp=(a[i]-'0')+(b[i]-'0'); int t=mapp[i]-'0'; if(t==0) t=10; val[i]=(temp+sum[i])%t; sum[i+1]=(temp+sum[i])/t; p=i+1; &#125; if(sum[p]!=0) val[p]=1; else p-=1; int flag=0; for(int i=p;i&gt;=0;i--) &#123; if(flag==0 &amp;&amp; val[i]==0) continue; cout&lt;&lt;val[i];flag=1; &#125; if(flag==0) cout&lt;&lt;"0"&lt;&lt;endl; return 0;&#125; 1076—10851076 Wifi密码 （15 分）下面是微博上流传的一张照片：“各位亲爱的同学们，鉴于大家有时需要使用 wifi，又怕耽误亲们的学习，现将 wifi 密码设置为下列数学题答案：A-1；B-2；C-3；D-4；请同学们自己作答，每两日一换。谢谢合作！！~”—— 老师们为了促进学生学习也是拼了…… 本题就要求你写程序把一系列题目的答案按照卷子上给出的对应关系翻译成 wifi 的密码。这里简单假设每道选择题都有 4 个选项，有且只有 1 个正确答案。 输入格式：输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行按照 编号-答案 的格式给出一道题的 4 个选项，T 表示正确选项，F 表示错误选项。选项间用空格分隔。 输出格式：在一行中输出 wifi 密码。 输入样例：1234567898A-T B-F C-F D-FC-T B-F A-F D-FA-F D-F C-F B-TB-T A-F C-F D-FB-F D-T A-F C-FA-T C-F B-F D-FD-T B-F C-F A-FC-T A-F B-F D-F 输出样例：113224143 直接比较指定位置的值是T还是F，在把前面的选项存入数组。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; string ans; int wifi[105]; cin&gt;&gt;n; getchar(); for(int i=0;i&lt;n;i++) &#123; getline(cin,ans); if(ans[2]=='T') wifi[i]=(ans[0]-'A')+1; if(ans[6]=='T') wifi[i]=(ans[4]-'A')+1; if(ans[10]=='T') wifi[i]=(ans[8]-'A')+1; if(ans[14]=='T') wifi[i]=(ans[12]-'A')+1; &#125; for(int i=0;i&lt;n;i++) cout&lt;&lt;wifi[i]; return 0;&#125; 1077 互评成绩计算 （20 分）在浙大的计算机专业课中，经常有互评分组报告这个环节。一个组上台介绍自己的工作，其他组在台下为其表现评分。最后这个组的互评成绩是这样计算的：所有其他组的评分中，去掉一个最高分和一个最低分，剩下的分数取平均分记为 G1；老师给这个组的评分记为 G2。该组得分为 (G1+G2)/2，最后结果四舍五入后保留整数分。本题就要求你写个程序帮助老师计算每个组的互评成绩。 输入格式：输入第一行给出两个正整数 N（&gt; 3）和 M，分别是分组数和满分，均不超过 100。随后 N 行，每行给出该组得到的 N 个分数（均保证为整型范围内的整数），其中第 1 个是老师给出的评分，后面 N−1 个是其他组给的评分。合法的输入应该是 [0,M] 区间内的整数，若不在合法区间内，则该分数须被忽略。题目保证老师的评分都是合法的，并且每个组至少会有 3 个来自同学的合法评分。 输出格式：为每个组输出其最终得分。每个得分占一行。 输入样例：12345676 5042 49 49 35 38 4136 51 50 28 -1 3040 36 41 33 47 4930 250 -25 27 45 3148 0 0 50 50 123443 41 36 29 42 29 输出样例：123456423341313739 需要用double类型累加和求平均，然后四舍五入。 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,g2,full; double g1,res; cin&gt;&gt;n&gt;&gt;full; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;g2; int temp,max=0,min=105,cnt=0; double sum=0; for(int j=0;j&lt;n-1;j++) &#123; cin&gt;&gt;temp; if(temp&lt;=full &amp;&amp; temp&gt;=0) &#123; sum+=temp; cnt++; if(temp&gt;max) max=temp; if(temp&lt;min) min=temp; &#125; &#125; g1=(sum-max-min)/((cnt-2)*1.0); res=(g1+g2)/(2.0); if(res-int(res)&gt;=0.5) res+=1; printf("%d\n",int(res)); &#125; return 0;&#125; 1078 字符串压缩与解压 （20 分）文本压缩有很多种方法，这里我们只考虑最简单的一种：把由相同字符组成的一个连续的片段用这个字符和片段中含有这个字符的个数来表示。例如 ccccc 就用 5c 来表示。如果字符没有重复，就原样输出。例如 aba 压缩后仍然是 aba。 解压方法就是反过来，把形如 5c 这样的表示恢复为 ccccc。 本题需要你根据压缩或解压的要求，对给定字符串进行处理。这里我们简单地假设原始字符串是完全由英文字母和空格组成的非空字符串。 输入格式：输入第一行给出一个字符，如果是 C 就表示下面的字符串需要被压缩；如果是 D 就表示下面的字符串需要被解压。第二行给出需要被压缩或解压的不超过 1000 个字符的字符串，以回车结尾。题目保证字符重复个数在整型范围内，且输出文件不超过 1MB。 输出格式：根据要求压缩或解压字符串，并在一行中输出结果。 输入样例 1：12CTTTTThhiiiis isssss a tesssst CAaaa as 输出样例 1：15T2h4is i5s a3 te4st CA3a as 输入样例 2：12D5T2h4is i5s a3 te4st CA3a as10Z 输出样例 2：1TTTTThhiiiis isssss a tesssst CAaaa asZZZZZZZZZZ 解压的时候，我一开始直接在循环里判断b[i]是否是数字，然后判断b[i+1]和b[i+2]是不是数字（因为可能出现大于9长度的同一个字母），但是循环里调用b[i+1]和b[i+2]可能会超出数组大小，最后一个样例过不了。所以如果遇到当前字符是数字，先记录下来，然后看下一次循环再检验构成的数字是否增加。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string a,b,ans; cin&gt;&gt;a; getchar(); string num; int times=1; if(a=="C") &#123; getline(cin,b); for(int i=0;i&lt;b.size();i++) &#123; int cnt=0; for(int j=i;j&lt;b.size();j++) &#123; if(b[j]==b[i]) cnt++; else break; &#125; if(cnt&gt;1) ans+=to_string(cnt); ans+=b[i]; i=i+cnt-1; if(i&gt;=b.size()) break; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; else if(a=="D") &#123; getline(cin,b); for(int i=0;i&lt;b.size();i++) &#123; if(b[i]&gt;='0' &amp;&amp; b[i]&lt;='9') &#123; num+=b[i]; &#125; else &#123; if(num.size()&gt;0) &#123; times=stoi(num); for(int j=0;j&lt;times-1;j++) ans+=b[i]; &#125; ans+=b[i]; times=1; num=""; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 1081 检查密码 （15 分）本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 .，还必须既有字母也有数字。 输入格式：输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。 输出格式：对每个用户的密码，在一行中输出系统反馈信息，分以下5种： 如果密码合法，输出Your password is wan mei.； 如果密码太短，不论合法与否，都输出Your password is tai duan le.； 如果密码长度合法，但存在不合法字符，则输出Your password is tai luan le.； 如果密码长度合法，但只有字母没有数字，则输出Your password needs shu zi.； 如果密码长度合法，但只有数字没有字母，则输出Your password needs zi mu.。 输入样例：1234565123szheshi.wodepw1234.5678WanMei23333pass*word.6 输出样例：12345Your password is tai duan le.Your password needs shu zi.Your password needs zi mu.Your password is wan mei.Your password is tai luan le. string类型的判断。 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; getchar(); string password; for(int i=0;i&lt;n;i++) &#123; getline(cin,password); int flag1=0,flag2=0,flag3=0,flag4=0; if(password.size()&lt;6) cout&lt;&lt;"Your password is tai duan le."&lt;&lt;endl; else &#123; for(int j=0;j&lt;password.size();j++) &#123; if((password[j]&gt;='a' &amp;&amp; password[j]&lt;='z') || (password[j]&gt;='A' &amp;&amp; password[j]&lt;='Z')) flag1=1; else if(password[j]&gt;='0' &amp;&amp; password[j]&lt;='9') flag2=1; else if(password[j]=='.') flag3=1; else flag4=1; &#125; if(flag4==1) cout&lt;&lt;"Your password is tai luan le."&lt;&lt;endl; else if(flag1==1 &amp;&amp; flag2==1 &amp;&amp; flag4==0) cout&lt;&lt;"Your password is wan mei."&lt;&lt;endl; else if(flag1==0 &amp;&amp; flag2==1 &amp;&amp; flag4==0) cout&lt;&lt;"Your password needs zi mu."&lt;&lt;endl; else if(flag1==1 &amp;&amp; flag2==0 &amp;&amp; flag4==0) cout&lt;&lt;"Your password needs shu zi."&lt;&lt;endl; &#125; &#125; return 0;&#125; 1082 射击比赛 （20 分）本题目给出的射击比赛的规则非常简单，谁打的弹洞距离靶心最近，谁就是冠军；谁差得最远，谁就是菜鸟。本题给出一系列弹洞的平面坐标(x,y)，请你编写程序找出冠军和菜鸟。我们假设靶心在原点(0,0)。 输入格式：输入在第一行中给出一个正整数 N（≤ 10 000）。随后 N 行，每行按下列格式给出： 1ID x y 其中 ID 是运动员的编号（由 4 位数字组成）；x 和 y 是其打出的弹洞的平面坐标(x,y)，均为整数，且 0 ≤ |x|, |y| ≤ 100。题目保证每个运动员的编号不重复，且每人只打 1 枪。 输出格式：输出冠军和菜鸟的编号，中间空 1 格。题目保证他们是唯一的。 输入样例：123430001 5 71020 -1 30233 0 -1 输出样例：10233 0001 循环读入并计算判断。 代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,id,x,y; cin&gt;&gt;n; double max=0,min=10005; int max_name,min_name; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;id&gt;&gt;x&gt;&gt;y; double dis=sqrt(x*x+y*y); if(dis&gt;max) &#123;max_name=id;max=dis;&#125; if(dis&lt;min) &#123;min_name=id;min=dis;&#125; &#125; printf("%04d %04d",min_name,max_name); return 0;&#125; 1083 是否存在相等的差 （20 分）给定 N 张卡片，正面分别写上 1、2、……、N，然后全部翻面，洗牌，在背面分别写上 1、2、……、N。将每张牌的正反两面数字相减（大减小），得到 N 个非负差值，其中是否存在相等的差？ 输入格式：输入第一行给出一个正整数 N（2 ≤ N ≤ 10 000），随后一行给出 1 到 N 的一个洗牌后的排列，第 i 个数表示正面写了 i 的那张卡片背面的数字。 输出格式：按照“差值 重复次数”的格式从大到小输出重复的差值及其重复的次数，每行输出一个结果。 输入样例：1283 5 8 6 2 1 4 7 输出样例：1235 23 32 2 虽然是需要排序，但是一个数组就可以搞定啦。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;stdio.h&gt;using namespace std;int a[10005]=&#123;0&#125;;int main()&#123; int n,num,max=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;num; int dis=abs(num-i); a[dis]++; if(dis&gt;max) max=dis; &#125; for(int i=max;i&gt;=0;i--) &#123; if(a[i]&gt;1) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;a[i]&lt;&lt;endl; &#125; return 0;&#125; 1084 外观数列 （20 分）外观数列是指具有以下特点的整数序列： 1d, d1, d111, d113, d11231, d112213111, ... 它从不等于 1 的数字 d 开始，序列的第 n+1 项是对第 n 项的描述。比如第 2 项表示第 1 项有 1 个 d，所以就是 d1；第 2 项是 1 个 d（对应 d1）和 1 个 1（对应 11），所以第 3 项就是 d111。又比如第 4 项是 d113，其描述就是 1 个 d，2 个 1，1 个 3，所以下一项就是 d11231。当然这个定义对 d = 1 也成立。本题要求你推算任意给定数字 d 的外观数列的第 N 项。 输入格式：输入第一行给出 [0,9] 范围内的一个整数 d、以及一个正整数 N（≤ 40），用空格分隔。 输出格式：在一行中给出数字 d 的外观数列的第 N 项。 输入样例：11 8 输出样例：11123123111 感觉很复杂，题目读懂之后一点点模拟其实也不难，一次就通过了，二重循环的时候检查和当前这个数是否相同，如果相同计数增加1，然后结束内层循环之后，外层循环的指针就指向 i+cnt-1，然后还要判断一下当前指针的位置是否还在输入数据长度内。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int d,n; cin&gt;&gt;d&gt;&gt;n; string ans,res; ans=to_string(d); for(int i=1;i&lt;n;i++) &#123; for(int j=0;j&lt;ans.size();j++) &#123; int cnt=0; for(int k=j;k&lt;ans.size();k++) &#123; if(ans[k]==ans[j]) &#123;cnt++;&#125; else break; &#125; res+=ans[j]; res+=to_string(cnt); if(j+cnt&lt;ans.size()) j=j+cnt-1; else if(j+cnt&gt;=ans.size()) break; &#125; //cout&lt;&lt;res&lt;&lt;endl; ans=res; res=""; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 1085 PAT单位排行 （25 分）每次 PAT 考试结束后，考试中心都会发布一个考生单位排行榜。本题就请你实现这个功能。 输入格式：输入第一行给出一个正整数 N（≤105），即考生人数。随后 N 行，每行按下列格式给出一个考生的信息： 1准考证号 得分 学校 其中准考证号是由 6 个字符组成的字符串，其首字母表示考试的级别：B代表乙级，A代表甲级，T代表顶级；得分是 [0, 100] 区间内的整数；学校是由不超过 6 个英文字母组成的单位码（大小写无关）。注意：题目保证每个考生的准考证号是不同的。 输出格式：首先在一行中输出单位个数。随后按以下格式非降序输出单位的排行榜： 1排名 学校 加权总分 考生人数 其中排名是该单位的排名（从 1 开始）；学校是全部按小写字母输出的单位码；加权总分定义为乙级总分/1.5 + 甲级总分 + 顶级总分*1.5的整数部分；考生人数是该属于单位的考生的总人数。 学校首先按加权总分排行。如有并列，则应对应相同的排名，并按考生人数升序输出。如果仍然并列，则按单位码的字典序输出。 输入样例：123456789101110A57908 85 AuB57908 54 LanXA37487 60 auT28374 67 CMUT32486 24 hypuA66734 92 cmuB76378 71 AUA47780 45 lanxA72809 100 pkuA03274 45 hypu 输出样例：12345651 cmu 192 21 au 192 33 pku 100 14 hypu 81 24 lanx 81 2 这题用vector加结构体只得了20分，最后两组测试数据超时了，看网上其他人还用了map，map我基本不会用，等有空了再来填坑好了。底下这版代码的逻辑没错，但是最后两组数据超时。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;struct pats&#123; string name; double scores; int cnt;&#125;;bool cmp(const pats &amp;a,const pats &amp;b)&#123; if(a.scores!=b.scores) return a.scores&gt;b.scores; else if(a.cnt!=b.cnt) return a.cnt&lt;b.cnt; else return a.name&lt;b.name;&#125;int main()&#123; vector&lt;pats&gt; pat; int n; double score; cin&gt;&gt;n; string id,school; for(int i=0;i&lt;n;i++) &#123; pats temp; cin&gt;&gt;id&gt;&gt;score&gt;&gt;school; for(int j=0;j&lt;school.size();j++) school[j]=tolower(school[j]); if(id[0]=='B') score=score/1.5; if(id[0]=='T') score=score*1.5; temp.name=school;temp.scores=score;temp.cnt=1; int flag=0; for(int k=0;k&lt;pat.size();k++) &#123; if(pat[k].name==school) &#123;pat[k].scores+=score;pat[k].cnt++;flag=1;&#125; &#125; if(flag==0) pat.push_back(temp); &#125; cout&lt;&lt;pat.size()&lt;&lt;endl; sort(pat.begin(),pat.end(),cmp); cout&lt;&lt;1&lt;&lt;" "&lt;&lt;pat[0].name&lt;&lt;" "&lt;&lt;int(pat[0].scores)&lt;&lt;" "&lt;&lt;pat[0].cnt&lt;&lt;endl; for(int i=1;i&lt;pat.size();i++) &#123; if(int(pat[i].scores)==int(pat[i-1].scores)) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;pat[i].name&lt;&lt;" "&lt;&lt;int(pat[i].scores)&lt;&lt;" "&lt;&lt;pat[i].cnt&lt;&lt;endl; else cout&lt;&lt;i+1&lt;&lt;" "&lt;&lt;pat[i].name&lt;&lt;" "&lt;&lt;int(pat[i].scores)&lt;&lt;" "&lt;&lt;pat[i].cnt&lt;&lt;endl; &#125; return 0;&#125; 1086—10951086 就不告诉你 （15 分）做作业的时候，邻座的小盆友问你：“五乘以七等于多少？”你应该不失礼貌地围笑着告诉他：“五十三。”本题就要求你，对任何一对给定的正整数，倒着输出它们的乘积。 输入格式：输入在第一行给出两个不超过 1000 的正整数 A 和 B，其间以空格分隔。 输出格式：在一行中倒着输出 A 和 B 的乘积。 输入样例：15 7 输出样例：153 100*100是返回1，前面的0要省略。 代码123456789101112131415#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int a,b; string res; cin&gt;&gt;a&gt;&gt;b; res=to_string(a*b); reverse(res.begin(),res.end()); printf("%d",stoi(res)); return 0;&#125; 1087 有多少不同的值 （20 分）当自然数 n 依次取 1、2、3、……、N 时，算式 ⌊n/2⌋+⌊n/3⌋+⌊n/5⌋ 有多少个不同的值？（注：⌊x⌋ 为取整函数，表示不超过 x 的最大自然数，即 x 的整数部分。） 输入格式：输入给出一个正整数 N（2≤N≤104）。 输出格式：在一行中输出题面中算式取到的不同值的个数。 输入样例：12017 输出样例：11480 这题还是很简单的，用vector存一下所有已经记录过的数。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,cnt=0; cin&gt;&gt;n; vector&lt;int &gt; a; for(int i=1;i&lt;=n;i++) &#123; int sum=int(i/2)+int(i/3)+int(i/5); int flag=0; for(int j=0;j&lt;a.size();j++) &#123; if(a[j]==sum) flag=1; &#125; if(flag==0) &#123;a.push_back(sum);cnt++;&#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; 1088 三人行 （20 分）子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。” 本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位正整数；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。 输入格式：输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。 输出格式：在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出 Cong；平等则输出 Ping；比你弱则输出 Gai。其间以 1 个空格分隔，行首尾不得有多余空格。 注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 No Solution。 输入样例 1：148 3 7 输出样例 1：148 Ping Cong Gai 输入样例 2：148 11 6 输出样例 2：1No Solution 这一题我一看就感觉是解方程的题目，然而有两个未知数和一个方程，所以解可能不唯一，我还算的是a和b的比值，然而只能得13分，应该是有些情况没考虑到。看了别人的答案，才发现自己简直太傻逼了，直接循环啊，a从99循环10，然后看b和c的情况是否满足题目要求就可以了。以后遇到类似于方程的问题要想到循环。 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;stdio.h&gt;using namespace std;void print(int m,double x)&#123; if(x&gt;m) cout&lt;&lt;" Cong"; if(x==m) cout&lt;&lt;" Ping"; if(x&lt;m) cout&lt;&lt;" Gai";&#125;int main()&#123; int m,x,y; cin&gt;&gt;m&gt;&gt;x&gt;&gt;y; for(int i=99;i&gt;=10;i--) &#123; int j=(i%10)*10+i/10; double k=abs(i-j)*1.0/x; if(j==k*y) &#123; cout&lt;&lt;i; print(m,i);print(m,j);print(m,k); return 0; &#125; &#125; cout&lt;&lt;"No Solution"&lt;&lt;endl; return 0;&#125; 1089 狼人杀-简单版 （20 分）以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？ 本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？ 输入格式：输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。 输出格式：如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M]和 B=b[1],…,b[M]，若存在 0≤k&lt;M 使得 a[i]=b[i] （i≤k），且 a[k+1]&lt;b[k+1]，则称序列 A 小于序列 B。若无解则输出 No Solution。 输入样例 1：1234565-2+3-4+5+4 输出样例 1：11 4 输入样例 2：12345676+6+3+1-5-2+4 输出样例 2（解不唯一）：11 5 输入样例 3：1234565-2-3-4-5-1 输出样例 3：1No Solution 这题一开始没有什么思路，然后看了别人的才明白，直接二重循环一次一次的验证就可以了，假设循环中的两个代号是狼人，其他人是好人，检查每个人说的是否是真话，如果是假话就jishu增加，如果检查完后，正好有2条假话，而且这两个说谎的人一个是好人一个是狼人，就可以证明当前循环中的这两个人就是狼人。 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; vector&lt;int &gt; v(n+1); for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]; for(int i=1;i&lt;=n;i++) &#123; for(int j=i+1;j&lt;=n;j++) &#123; vector&lt;int&gt; lie,a(n+1,1); a[i]=-1;a[j]=-1; for(int k=1;k&lt;=n;k++) &#123; if(v[k]*a[abs(v[k])]&lt;0) lie.push_back(k); &#125; if(lie.size()==2 &amp;&amp; a[lie[0]]+a[lie[1]]==0) &#123;cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j;return 0;&#125; &#125; &#125; cout&lt;&lt;"No Solution"&lt;&lt;endl; return 0;&#125; 1091 N-自守数 （15 分）如果某个数 K 的平方乘以 N 以后，结果的末尾几位数等于 K，那么就称这个数为“N-自守数”。例如 3×922=25392，而 25392 的末尾两位正好是 92，所以 92 是一个 3-自守数。 本题就请你编写程序判断一个给定的数字是否关于某个 N 是 N-自守数。 输入格式：输入在第一行中给出正整数 M（≤20），随后一行给出 M 个待检测的、不超过 1000 的正整数。 输出格式：对每个需要检测的数字，如果它是 N-自守数就在一行中输出最小的 N 和 NK2 的值，以一个空格隔开；否则输出 No。注意题目保证 N&lt;10。 输入样例：12392 5 233 输出样例：1233 253921 25No 这题做为15分的题目有点复杂啊，既然要找n的值，就循环从1遍历到9，检验是否满足题目要求，需要把输入的数字和乘积结果都转换为string类型，然后比较最后几位是否相等。 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,num; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;num; string snum,res; snum=to_string(num); int num_size=snum.size(); int flag=0; for(int j=1;j&lt;=9;j++) &#123; int temp=j*num*num; res=to_string(temp); int res_size=res.size(); if(res.substr(res_size-num_size,res_size)==snum) &#123;cout&lt;&lt;j&lt;&lt;" "&lt;&lt;(num*num*j)&lt;&lt;endl;flag=1;break;&#125; &#125; if(flag==0) cout&lt;&lt;"No"&lt;&lt;endl; &#125; return 0;&#125; 1092 最好吃的月饼 （20 分）月饼是久负盛名的中国传统糕点之一，自唐朝以来，已经发展出几百品种。 若想评比出一种“最好吃”的月饼，那势必在吃货界引发一场腥风血雨…… 在这里我们用数字说话，给出全国各地各种月饼的销量，要求你从中找出销量冠军，认定为最好吃的月饼。 输入格式：输入首先给出两个正整数 N（≤1000）和 M（≤100），分别为月饼的种类数（于是默认月饼种类从 1 到 N 编号）和参与统计的城市数量。 接下来 M 行，每行给出 N 个非负整数（均不超过 1 百万），其中第 i 个整数为第 i 种月饼的销量（块）。数字间以空格分隔。 输出格式：在第一行中输出最大销量，第二行输出销量最大的月饼的种类编号。如果冠军不唯一，则按编号递增顺序输出并列冠军。数字间以 1 个空格分隔，行首尾不得有多余空格。 输入样例：12345 31001 992 0 233 68 0 2018 0 200836 18 0 1024 4 输出样例：1220183 5 开一个数组负责累加统计即可。 代码1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int a[1005]=&#123;0&#125;;int main()&#123; int n,m,temp,max=0; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; cin&gt;&gt;temp; a[j]+=temp; if(a[j]&gt;=max) max=a[j]; &#125; &#125; cout&lt;&lt;max&lt;&lt;endl; int flag=0; for(int i=1;i&lt;=n;i++) &#123; if(a[i]==max &amp;&amp; flag==0) &#123;cout&lt;&lt;i;flag=1;&#125; else if(a[i]==max &amp;&amp; flag==1) cout&lt;&lt;" "&lt;&lt;i; &#125; return 0;&#125; 1093 字符串A+B （20 分）给定两个字符串 A 和 B，本题要求你输出 A+B，即两个字符串的并集。要求先输出 A，再输出 B，但重复的字符必须被剔除。 输入格式：输入在两行中分别给出 A 和 B，均为长度不超过 106的、由可见 ASCII 字符 (即码值为32~126)和空格组成的、由回车标识结束的非空字符串。 输出格式：在一行中输出题面要求的 A 和 B 的和。 输入样例：12This is a sample testto show you_How it works 输出样例：1This ampletowyu_Hrk 这一题双重循环的话最后一组测试用例会超时，在数组里面标记就可以了。 代码1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int s[205]=&#123;0&#125;; string a,b,c; getline(cin,a); getline(cin,b); c=a+b; for(int i=0;i&lt;c.size();i++) &#123; if(s[c[i]]==0) &#123;cout&lt;&lt;c[i];s[c[i]]=1;&#125; &#125; return 0;&#125; 1094 谷歌的招聘 （20 分）2004 年 7 月，谷歌在硅谷的 101 号公路边竖立了一块巨大的广告牌（如下图）用于招聘。内容超级简单，就是一个以 .com 结尾的网址，而前面的网址是一个 10 位素数，这个素数是自然常数 e 中最早出现的 10 位连续数字。能找出这个素数的人，就可以通过访问谷歌的这个网站进入招聘流程的下一步。 自然常数 e 是一个著名的超越数，前面若干位写出来是这样的：e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921… 其中粗体标出的 10 位数就是答案。 本题要求你编程解决一个更通用的问题：从任一给定的长度为 L 的数字中，找出最早出现的 K 位连续数字所组成的素数。 输入格式：输入在第一行给出 2 个正整数，分别是 L（不超过 1000 的正整数，为数字长度）和 K（小于 10 的正整数）。接下来一行给出一个长度为 L 的正整数 N。 输出格式：在一行中输出 N 中最早出现的 K 位连续数字所组成的素数。如果这样的素数不存在，则输出 404。注意，原始数字中的前导零也计算在位数之内。例如在 200236 中找 4 位素数，0023 算是解；但第一位 2 不能被当成 0002 输出，因为在原始数字中不存在这个 2 的前导零。 输入样例 1：1220 523654987725541023819 输出样例 1：149877 输入样例 2：1210 32468024680 输出样例 2：1404 这一题应该还是很简单的，只要会string的一些基本函数就好说。我在做题的时候把substr的参数记错了，里面的参数应该是起始位置和长度，而不是起始位置和终止位置。一开始没读懂那个提示，提交之后只有18分，有一个测试点没通过，然后再读了一下这个提示，才明白意思是如果数字结果是“0023”，就应该输出0023，而不能把前面没有意义的0省略，所以输出是要判断一下数据位数。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int isprim(int n)&#123; int flag=0; if(n==1) return 0; if(n==2) return 1; for(int i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123;flag=1;return 0;&#125; &#125; if(flag==0) return 1;&#125;int main()&#123; int l,k,temp=0; string number,sub; cin&gt;&gt;l&gt;&gt;k; cin&gt;&gt;number; for(int i=0;i&lt;l-k+1;i++) &#123; sub=number.substr(i,k); temp=stoi(sub); if(isprim(temp)==1) &#123; string s=to_string(temp); if(s.size()!=k) &#123; for(int j=0;j&lt;k-s.size();j++) cout&lt;&lt;0; &#125; cout&lt;&lt;temp&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;"404"&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT刷题记录(上)]]></title>
    <url>%2F2019%2F01%2F24%2FPAT%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2019年准备参加PAT的认证，记录一下官网刷题的情况。 因为题目太多，分成上下两部分，这部分是1001—1045。 1001—10101004 成绩排名读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含 1 个测试用例，格式为 12345第 1 行：正整数 n第 2 行：第 1 个学生的姓名 学号 成绩第 3 行：第 2 个学生的姓名 学号 成绩 ... ... ...第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 输入样例：12343Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例：12Mike CS991301Joe Math990112 很简单，定义一个结构体，然后根据分数排序就行了 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct student&#123; string name; string subject; int score;&#125;;student stu[1000];bool compare(const student &amp;a,const student &amp;b)&#123; return a.score&gt;b.score;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;stu[i].name&gt;&gt;stu[i].subject&gt;&gt;stu[i].score; &#125; sort(stu,stu+n,compare); cout&lt;&lt;stu[0].name&lt;&lt;" "&lt;&lt;stu[0].subject&lt;&lt;endl; cout&lt;&lt;stu[n-1].name&lt;&lt;" "&lt;&lt;stu[n-1].subject&lt;&lt;endl; return 0;&#125; 1005 继续（3n+1）猜想卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式：每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。 输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 输入样例：1263 5 6 7 8 11 输出样例：17 6 我的想法应该算是暴力吧，把每一个数的（3n+1）猜想都求一次，然后将求出的所有结果记录在一个集合里（set集合可以按从小到大排序，提出重复元素），然后将这个集合和原始集合求差集，即可找出“关键数”。注意：需要掌握set集合的声明和调用方法，必须用迭代器遍历，正向迭代器的声明和函数调用都不一样！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;int&gt; x1,x2,x; int num[105]; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; int number; cin&gt;&gt;number; num[i]=number; x1.insert(number); &#125; for(int i=0;i&lt;n;i++) &#123; while(1) &#123; if(num[i]==1) break; if(num[i]%2==0) &#123; num[i]=num[i]/2; x2.insert(num[i]); &#125; else if(num[i]%2==1) &#123; num[i]=(3*num[i]+1)/2; x2.insert(num[i]); &#125; &#125; &#125; set_difference(x1.begin(),x1.end(),x2.begin(),x2.end(),inserter(x,x.begin())); //x1相对于x2的差集 set&lt;int&gt;::reverse_iterator it; int flag=0; for(it=x.rbegin();it!=x.rend();it++) //使用迭代器进行遍历 &#123; if(flag==0) &#123; cout&lt;&lt;*it; flag=1; &#125; else if(flag==1) cout&lt;&lt;" "&lt;&lt;*it; &#125; return 0;&#125; 1006 换个格式输出整数让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12...n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。 输入格式：每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。 输出格式：每个测试用例的输出占一行，用规定的格式输出 n。 输入样例 1：1234 输出样例 1：1BBSSS1234 输入样例 2：123 输出样例 2：1SS123 反正最大长度就是3，干脆分3中情况直接写算啦！ 代码12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; string number; cin&gt;&gt;number; if(number.size()==3) &#123; for(int i=0;i&lt;int(number[0]-48);i++) cout&lt;&lt;"B"; for(int i=0;i&lt;int(number[1]-48);i++) cout&lt;&lt;"S"; for(int i=0;i&lt;int(number[2]-48);i++) cout&lt;&lt;(i+1); &#125; if(number.size()==2) &#123; for(int i=0;i&lt;int(number[0]-48);i++) cout&lt;&lt;"S"; for(int i=0;i&lt;int(number[1]-48);i++) cout&lt;&lt;(i+1); &#125; if(number.size()==1) &#123; for(int i=0;i&lt;int(number[0]-48);i++) cout&lt;&lt;(i+1); &#125; return 0;&#125; 1007 素数对猜想让我们定义dn为：dn=pn+1−pn，其中pi是第i个素数。显然有d1=1，且对于n&gt;1有dn是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。 现给定任意正整数N(&lt;105)，请计算不超过N的满足猜想的素数对的个数。 输入格式:输入在一行给出正整数N。 输出格式:在一行中输出不超过N的满足猜想的素数对的个数。 输入样例:120 输出样例:14 一开始我先写了一个函数，用vector存储n以内的所有素数，然后再双循环比较两者只差是否为2，但是当n为10的5次方时超时了，被扣了2分。后来看了网上的答案才发现，二重循环的时候不用验证到i，验证到&lt;=i*i就可以了。因为，比如要判断10是不是素数，只用看它能不能被2,3,4整除就可以了，5乘以比5大的数都超过10了，乘以比5小的数才可能是10。 代码123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int main()&#123; int n,counts=0; cin&gt;&gt;n; int a=2,b=3; for(int i=5;i&lt;=n;i++) &#123; int flag=0; for(int j=2;j*j&lt;=i;j++) &#123; if(i%j==0) flag=1; &#125; if(flag==0) &#123; a=b; b=i; if(b-a==2) counts++; &#125; &#125; cout&lt;&lt;counts&lt;&lt;endl; return 0;&#125; 1008 数组元素循环右移问题一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A0A1⋯AN−1）变换为（AN−M⋯AN−1A0A1⋯AN−M−1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式:每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例:126 21 2 3 4 5 6 输出样例:15 6 1 2 3 4 感觉很简单，按照题目要求交了，结果有两组样例没通过，又检查了半天发现，m的范围是大于0，如果超过n，就需要移动好几轮，所以m应该取成m%n。 代码123456789101112131415#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int num[105];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; m=m%n; for(int i=0;i&lt;n;i++) cin&gt;&gt;num[i]; for(int i=n-m;i&lt;n;i++) cout&lt;&lt;num[i]&lt;&lt;" "; for(int i=0;i&lt;n-m-1;i++) cout&lt;&lt;num[i]&lt;&lt;" "; cout&lt;&lt;num[n-m-1]; return 0;&#125; 1009 说反话给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。 输出格式：每个测试用例的输出占一行，输出倒序后的句子。 输入样例：1Hello World Here I Come 输出样例：1Come I Here World Hello C++里面的cin不能读入空格，就算用getline读入，也还要分割，有点麻烦。不如用python，只需要四行代码~按空格分割开来存入list，然后反序输出，关键是输出格式，最后一个单词后面不能有空格，在网上找的方法，使用 join函数，意思是把输出字符之间用空格分隔开输出。 代码1234s = input()li = s.split(" ")li.reverse()print(" ".join(i for i in li)) 1010 一元多项式求导设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为nxn−1。） 输入格式:以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。 输出格式:以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 0 0。 输入样例:13 4 -5 2 6 1 -2 0 输出样例:112 3 -10 1 6 0 感觉最大的难点就是输入和输出的格式问题，还有一开始没读懂题目意思，不知道啥时候要输出“0 0”，其实就是如果整个多项式求导之后的结果是0，就输出“0 0”，如果某一项的系数是0，这一项就不用输出了。今天才发现用while(cin&gt;&gt;a&gt;&gt;b)，这种方式不会自己停下来，不过没有关系，只要主函数有return 0就不影响得分。 代码12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,flag=0; while(cin&gt;&gt;a&gt;&gt;b) &#123; if(b!=0) &#123; if(flag==0) cout&lt;&lt;a*b&lt;&lt;" "&lt;&lt;b-1; else cout&lt;&lt;" "&lt;&lt;a*b&lt;&lt;" "&lt;&lt;b-1;flag=1; &#125; &#125; if(flag==0) cout&lt;&lt;"0 0"&lt;&lt;endl; return 0;&#125; 2011—10202011 A+B和C给定区间 [−231,231] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。 输入格式：输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。 输出格式：对每组测试用例，在一行中输出 Case #X: true 如果 A+B&gt;C，否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。 输入样例：1234541 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647 输出样例：1234Case #1: falseCase #2: trueCase #3: trueCase #4: false 简单！没有一次过，竟然是因为“Case”的c没有大写！注意细节！ 代码12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; long long a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;"Case #"&lt;&lt;i+1&lt;&lt;": "; if(a+b&gt;c) cout&lt;&lt;"true"&lt;&lt;endl; else cout&lt;&lt;"false"&lt;&lt;endl; &#125; return 0;&#125; 1012 数字分类给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A1 = 能被 5 整除的数字中所有偶数的和； A2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1−n2+n3−n4⋯； A3 = 被 5 除后余 2 的数字的个数； A4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A5 = 被 5 除后余 4 的数字中最大数字。 输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式：对给定的 N 个正整数，按题目要求计算 A1~A5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出 N。 输入样例 1：113 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例 1：130 11 2 9.7 9 输入样例 2：18 1 2 4 5 6 7 9 16 输出样例 2：1N 11 2 N 9 简单，就是一大推if，分类讨论，按照格式输出。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int x[1005]; int n,res1=0,res2=0,res3=0,res5=0; int flag1=0,flag2=0,flag3=0,flag4=0,flag5=0,counts=0; float res4=0; cin&gt;&gt;n; int flag=1; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;x[i]; if(x[i]%10==0) &#123;res1+=x[i];flag1=1;&#125; if(x[i]%5==1) &#123;res2=res2+flag*x[i];flag=-flag;flag2=1;&#125; if(x[i]%5==2) &#123;res3++;flag3=1;&#125; if(x[i]%5==3) &#123;res4+=x[i];counts++;flag4=1;&#125; if(x[i]%5==4) &#123; if(x[i]&gt;res5) res5=x[i]; flag5=1; &#125; &#125; if(flag1==0) cout&lt;&lt;"N "; if(flag1!=0) cout&lt;&lt;res1&lt;&lt;" "; if(flag2==0) cout&lt;&lt;"N "; if(flag2!=0) cout&lt;&lt;res2&lt;&lt;" "; if(flag3==0) cout&lt;&lt;"N "; if(flag3!=0) cout&lt;&lt;res3&lt;&lt;" "; if(flag4==0) cout&lt;&lt;"N "; if(flag4!=0) &#123;printf("%.1f",res4/counts);cout&lt;&lt;" ";&#125; if(flag5==0) cout&lt;&lt;"N"&lt;&lt;endl; if(flag5!=0) cout&lt;&lt;res5&lt;&lt;endl; return 0;&#125; 1013 数素数令 Pi 表示第 i 个素数。现任给两个正整数 M≤N≤104，请输出 PM 到 PN 的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从 PM 到 PN 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 输入样例：15 27 输出样例：12311 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 素数的判断依然是j*j&lt;=i，然后暴力计数就可以过啦。 代码12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int counts=0; for(int i=2;i&lt;=104730;i++) &#123; int flag=0; for(int j=2;j*j&lt;=i;j++) &#123; if(i%j==0) flag=1; &#125; if(flag==0) &#123; counts++; if(counts&gt;=a &amp;&amp; counts&lt;=b &amp;&amp; (counts-a+1)%10==1) &#123;cout&lt;&lt;i;&#125; if(counts&gt;=a &amp;&amp; counts&lt;=b &amp;&amp; (counts-a+1)%10&gt;1 &amp;&amp; (counts-a+1)%10&lt;=9) &#123;cout&lt;&lt;" "&lt;&lt;i;&#125; if(counts&gt;=a &amp;&amp; counts&lt;=b &amp;&amp; (counts-a+1)%10==0) &#123;cout&lt;&lt;" "&lt;&lt;i&lt;&lt;endl;&#125; &#125; &#125; return 0;&#125; 1014 福尔摩斯的约会大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式：在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 输入样例：12343485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例：1THU 14:04 这一题很繁琐，各种条件都要考虑到，还有输出格式，小于0的数前面要补0。还有个问题是判断小时的那里，是判断天数之后的下一对相同的数字或大写字母。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string str1,str2,str3,str4; cin&gt;&gt;str1&gt;&gt;str2&gt;&gt;str3&gt;&gt;str4; int i,j,k,hour; for(i=0;i&lt;str1.size();i++) &#123; if(str1[i]==str2[i] &amp;&amp; str1[i]&gt;='A' &amp;&amp; str1[i]&lt;='G') &#123; switch(str1[i]) &#123; case 'A':cout&lt;&lt;"MON ";break; case 'B':cout&lt;&lt;"TUE ";break; case 'C':cout&lt;&lt;"WED ";break; case 'D':cout&lt;&lt;"THU ";break; case 'E':cout&lt;&lt;"FRI ";break; case 'F':cout&lt;&lt;"SAT ";break; case 'G':cout&lt;&lt;"SUN ";break; &#125; break; &#125; &#125; int flag=0; for(j=i+1;j&lt;str1.size();j++) &#123; if(str1[j]==str2[j] &amp;&amp; str1[j]&gt;='0' &amp;&amp; str1[j]&lt;='9') &#123; hour=str1[j]-'0'; cout&lt;&lt;"0"&lt;&lt;hour&lt;&lt;":"; flag=1; break; &#125; &#125; if(flag==0) &#123; for(j=i+1;j&lt;str1.size();j++) &#123; if(str1[j]==str2[j] &amp;&amp; str1[j]&gt;='A' &amp;&amp; str1[j]&lt;='N') &#123; hour=str1[j]-'A'+10; cout&lt;&lt;hour&lt;&lt;":"; break; &#125; &#125; &#125; for(k=0;k&lt;str3.size();k++) &#123; if(str3[k]==str4[k] &amp;&amp; (str3[k]&gt;='a' &amp;&amp; str3[k]&lt;='z') || (str3[k]&gt;='A' &amp;&amp; str3[k]&lt;='Z')) &#123; if(k&lt;10) &#123;cout&lt;&lt;"0"&lt;&lt;k&lt;&lt;endl;break;&#125; if(k&gt;=10) &#123;cout&lt;&lt;k&lt;&lt;endl;break;&#125; &#125; &#125; return 0;&#125; 1015 德才论宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式：输入第一行给出 3 个正整数，分别为：N（≤105），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式：输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例：12345678910111213141514 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60 输出样例：123456789101112131210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90 结构体排序问题，还需要熟悉一下结构体排序规则的那个bool类型的函数呀，其他的问题不大。还有个问题就是一开始结构体数组开小了，会提示“段错误”，像这种10的5次方的结构体数组还是开在main函数外面比较保险。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;struct students&#123; string id; int score1; int score2; int level;&#125;;bool Cmpare(const students &amp;a, const students &amp;b)&#123; if(a.level!=b.level) &#123; return a.level&lt;b.level; &#125; else if(a.level==b.level) &#123; if(a.score1+a.score2!=b.score1+b.score2) return a.score1+a.score2 &gt; b.score1+b.score2; else if(a.score1+a.score2==b.score1+b.score2) &#123; if(a.score1!=b.score1) return a.score1&gt;b.score1; else return a.id&lt;b.id; &#125; &#125;&#125;students stu[100005];int main()&#123; int n,l,h; cin&gt;&gt;n&gt;&gt;l&gt;&gt;h; int counts=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;stu[i].id&gt;&gt;stu[i].score1&gt;&gt;stu[i].score2; if(stu[i].score1&gt;=l &amp;&amp; stu[i].score2&gt;=l) &#123; if(stu[i].score1&gt;=h &amp;&amp; stu[i].score2&gt;=h) stu[i].level=1; else if(stu[i].score1&gt;=h &amp;&amp; stu[i].score2&lt;h) stu[i].level=2; else if(stu[i].score1&lt;h &amp;&amp; stu[i].score2&lt;h &amp;&amp; stu[i].score1&gt;=stu[i].score2) stu[i].level=3; else stu[i].level=4; &#125; else &#123;stu[i].level=5;counts++;&#125; &#125; sort(stu,stu+n,Cmpare); cout&lt;&lt;n-counts&lt;&lt;endl; for(int i=0;i&lt;n-counts;i++) cout&lt;&lt;stu[i].id&lt;&lt;" "&lt;&lt;stu[i].score1&lt;&lt;" "&lt;&lt;stu[i].score2&lt;&lt;endl; return 0;&#125; 1016 部分A+B正整数 A 的“DA（为 1 位整数）部分”定义为由 A 中所有 DA 组成的新整数 PA。例如：给定 A=3862767，DA=6，则 A 的“6 部分”PA 是 66，因为 A 中有 2 个 6。 现给定 A、DA、B、DB，请编写程序计算 PA+PB。 输入格式：输入在一行中依次给出 A、DA、B、DB，中间以空格分隔，其中 0&lt;A,B&lt;1010。 输出格式：在一行中输出 PA+PB 的值。 输入样例 1：13862767 6 13530293 3 输出样例 1：1399 输入样例 2：13862767 1 13530293 8 输出样例 2：10 先定义了一个函数，用来求10的n次方，然后分别数数字出现的个数，最后求和。后来想起来可以用c++的pow函数直接求x的y次方，但是需要注意的是，pow函数传入的是double类型，输出也是double类型，如果用int输入可能会不准确。 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int ten(int n)&#123; int sum=1; for(int i=1;i&lt;=n;i++) &#123; sum=sum*10; &#125; return sum;&#125;int main()&#123; string a,b; char x1,x2; int count1=0,count2=0,sum1=0,sum2=0; cin&gt;&gt;a&gt;&gt;x1&gt;&gt;b&gt;&gt;x2; for(int i=0;i&lt;a.size();i++) &#123;if(a[i]==x1) count1++;&#125; for(int i=0;i&lt;b.size();i++) &#123;if(b[i]==x2) count2++;&#125; for(int i=1;i&lt;=count1;i++) &#123;sum1+=ten(i-1)*(x1-'0');&#125; for(int i=1;i&lt;=count2;i++) &#123;sum2+=ten(i-1)*(x2-'0');&#125; cout&lt;&lt;sum1+sum2&lt;&lt;endl; return 0;&#125; 1017 A除以B本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。 输入格式：输入在一行中依次给出 A 和 B，中间以 1 空格分隔。 输出格式：在一行中依次输出 Q 和 R，中间以 1 空格分隔。 输入样例：1123456789050987654321 7 输出样例：117636684150141093474 3 大整数除法的题目。之前没敲过，看了一下网上的代码，就是手算除法的思路，做了一个模拟。用python可以不用模拟，直接使用“//“运算符，除法取整数，只要两行代码，十分简单。 代码C++： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string a; int b,flag=0,temp=0; cin&gt;&gt;a&gt;&gt;b; for(int i=0;i&lt;a.size();i++) &#123; temp=temp*10+a[i]-'0'; if(temp&gt;=b) &#123;cout&lt;&lt;temp/b;flag=1;&#125; else if(flag==1) cout&lt;&lt;"0"; temp=temp%b; &#125; if(flag==0) cout&lt;&lt;"0"; cout&lt;&lt;" "&lt;&lt;temp&lt;&lt;endl; return 0;&#125; Python： 123if __name__ == '__main__': a = [int(i) for i in input().split()] print(str(a[0] // a[1]) + " " + str(a[0] % a[1])) 1018 锤子剪刀布大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示： 现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式：输入第 1 行给出正整数 N（≤105），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式：输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例：123456789101110C JJ BC BB BB CC CC BJ BB CJ J 输出样例：1235 3 22 3 5B B 没啥难点，却做了很久，一开始想复杂了，没想清楚那个统计出现最多的次数要怎么搞，其实用两个数组记录就可以了。 代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,win1=0,win2=0,same=0,j=0,k=0; int player1[3]=&#123;0&#125;; int player2[3]=&#123;0&#125;; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; char a,b; cin&gt;&gt;a&gt;&gt;b; if(a=='C' &amp;&amp; b=='J') &#123;win1++;player1[1]++;&#125; if(a=='C' &amp;&amp; b=='B') &#123;win2++;player2[0]++;&#125; if(a=='J' &amp;&amp; b=='C') &#123;win2++;player2[1]++;&#125; if(a=='J' &amp;&amp; b=='B') &#123;win1++;player1[2]++;&#125; if(a=='B' &amp;&amp; b=='C') &#123;win1++;player1[0]++;&#125; if(a=='B' &amp;&amp; b=='J') &#123;win2++;player2[2]++;&#125; if(a==b) &#123;same++;&#125; &#125; int max1=player1[0]&gt;=player1[1]?0:1; max1=player1[max1]&gt;=player1[2]?max1:2; int max2=player2[0]&gt;=player2[1]?0:1; max2=player2[max2]&gt;=player2[2]?max2:2; char str[4]=&#123;"BCJ"&#125;; cout&lt;&lt;win1&lt;&lt;" "&lt;&lt;same&lt;&lt;" "&lt;&lt;n-win1-same&lt;&lt;endl; cout&lt;&lt;win2&lt;&lt;" "&lt;&lt;same&lt;&lt;" "&lt;&lt;n-win2-same&lt;&lt;endl; cout&lt;&lt;str[max1]&lt;&lt;" "&lt;&lt;str[max2]&lt;&lt;endl; return 0;&#125; 1019 数字黑洞给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。 例如，我们从6767开始，将得到 1234567766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 61747641 - 1467 = 6174... ... 现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。 输入格式：输入给出一个 (0,104) 区间内的正整数 N。 输出格式：如果 N 的 4 位数字全相等，则在一行内输出 N - N = 0000；否则将计算的每一步在一行内输出，直到 6174 作为差出现，输出格式见样例。注意每个数字按 4 位数格式输出。 输入样例 1：16767 输出样例 1：12347766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 6174 输入样例 2：12222 输出样例 2：12222 - 2222 = 0000 关键问题就是字符串格式和数字之间的转换、排序、补零，一开始用数组做的，一直没有满分，后来看了网上的代码，string 数据类型也可以排序，然后用to_string()函数把数组转成字符串，用stoi()函数把字符串转成数字。 代码12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(char a, char b) &#123;return a &gt; b;&#125;int main()&#123; string s; cin &gt;&gt; s; s.insert(0, 4 - s.length(), '0'); while(1) &#123; string a = s, b = s; sort(a.begin(), a.end(), cmp); sort(b.begin(), b.end()); int result = stoi(a) - stoi(b); s = to_string(result); s.insert(0, 4 - s.length(), '0'); cout &lt;&lt; a &lt;&lt; " - " &lt;&lt; b &lt;&lt; " = " &lt;&lt; s &lt;&lt; endl; if(s=="6174" || s=="0000") break; &#125; return 0;&#125; 1020 月饼月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。 注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。 输入格式：每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式：对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。 输入样例：1233 2018 15 1075 72 45 输出样例：194.50 结构体和排序的问题，需要注意的是除法计算出来的单价不是很准确，求和的时候尽量不要用单价，避免有误差。 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;struct mooncake&#123; float number; float money; float price;&#125;;bool cmp(const mooncake &amp;a,const mooncake &amp;b) &#123;return a.price&gt;=b.price;&#125;mooncake cakes[1005];int main()&#123; int j,n,d,total=0; float m=0; cin&gt;&gt;n&gt;&gt;d; for(int i=0;i&lt;n;i++) cin&gt;&gt;cakes[i].number; for(int i=0;i&lt;n;i++) cin&gt;&gt;cakes[i].money; for(int i=0;i&lt;n;i++) cakes[i].price=cakes[i].money/cakes[i].number; sort(cakes,cakes+n,cmp); for(j=0;j&lt;n;j++) &#123; total+=cakes[j].number; m+=cakes[j].money; if(total&gt;=d) break; &#125; if(total&gt;d) &#123; total-=cakes[j].number; m-=cakes[j].money; int temp=d-total; m+=cakes[j].money/(cakes[j].number/temp); //m-=cakes[j].price/(cakes[j].number/(total-d)); &#125; printf("%.2f",m); return 0;&#125; 1021—10301021 个位数统计给定一个 k 位整数 N=dk−110k−1+⋯+d1101+d0 (0≤di≤9, i=0,⋯,k−1, dk−1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。 输入格式：每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。 输出格式：对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。 输入样例：1100311 输出样例：1230:21:33:1 用一个数组存储每一个数字出现的次数即可。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int sum[15]=&#123;0&#125;; string number; cin&gt;&gt;number; for(int i=0;i&lt;number.size();i++) &#123; sum[number[i]-'0']++; &#125; for(int i=0;i&lt;=9;i++) &#123; if(sum[i]!=0) &#123; cout&lt;&lt;i&lt;&lt;":"&lt;&lt;sum[i]&lt;&lt;endl; &#125; &#125; return 0;&#125; 1022 D进制的A+B输入两个非负 10 进制整数 A 和 B (≤230−1)，输出 A+B 的 D (1&lt;D≤10)进制数。 输入格式：输入在一行中依次给出 3 个整数 A、B 和 D。 输出格式：输出 A+B 的 D 进制数。 输入样例：1123 456 8 输出样例：11103 进制转换类型我做的还不是很熟练，几进制就是除以几的余数，然后不断除以这个数直到商是0为止。 代码12345678910111213141516#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int a,b,d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;d; int sum=a+b; int ans[31],num=0; do&#123; ans[num++]=sum%d; sum=sum/d; &#125;while(sum!=0); for(int i=num-1;i&gt;=0;i--) cout&lt;&lt;ans[i]; return 0;&#125; 1023 组个最小数给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。 现给定数字，请编写程序输出能够组成的最小的数。 输入格式：输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。 输出格式：在一行中输出能够组成的最小的数。 输入样例：12 2 0 0 0 3 0 0 1 0 输出样例：110015558 先找到非0的最小数并输出，然后输入所有的0（如果有的话），然后按从小到大的顺序输出其他数。 代码123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int t; int a[10]=&#123;0&#125;; for(int i=0;i&lt;10;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;10;i++) &#123; if(a[i]!=0) &#123; cout&lt;&lt;i; t=i;break; &#125; &#125; for(int i=0;i&lt;a[0];i++) cout&lt;&lt;0; for(int i=0;i&lt;a[t]-1;i++) cout&lt;&lt;t; for(int i=t+1;i&lt;10;i++) for(int j=0;j&lt;a[i];j++) cout&lt;&lt;i; return 0;&#125; 1024 科学计数法科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9].[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。 现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。 输入格式：每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。 输出格式：对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。 输入样例 1：1+1.23400E-03 输出样例 1：10.00123400 输入样例 2：1-1.2E+10 输出样例 2：1-12000000000 先保存E前面的字符串，然后把E后面的字符串用stoi函数转换成数字，如果是负数表示向前移动，先输出“0.”然后再看需要补多少0，如果是正数需要判断是移动小数点还是补零。 代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int i = 0; while (s[i] != 'E') i++; string t = s.substr(1, i-1); int n = stoi(s.substr(i+1)); if (s[0] == '-') cout &lt;&lt; "-"; if (n &lt; 0) &#123; cout &lt;&lt; "0."; for (int j = 0; j &lt; abs(n) - 1; j++) cout &lt;&lt; '0'; for (int j = 0; j &lt; t.length(); j++) if (t[j] != '.') cout &lt;&lt; t[j]; &#125; else &#123; cout &lt;&lt; t[0]; int cnt, j; for (j = 2, cnt = 0; j &lt; t.length() &amp;&amp; cnt &lt; n; j++, cnt++) cout &lt;&lt; t[j]; if (j == t.length()) &#123; for (int k = 0; k &lt; n - cnt; k++) cout &lt;&lt; '0'; &#125; else &#123; cout &lt;&lt; '.'; for (int k = j; k &lt; t.length(); k++) cout &lt;&lt; t[k]; &#125; &#125; return 0;&#125; 1026 程序运行时间要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。 这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。 输入格式：输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,107]。 输出格式：在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。 输入样例：1123 4577973 输出样例：112:42:59 挺简单的，就是时间差除以100之后要做一个四舍五入的处理。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int c1,c2,hour,minute,second; int time; float t; cin&gt;&gt;c1&gt;&gt;c2; time=(c2-c1)/100; t=(c2-c1)*1.0/100; if(t-time&gt;=0.5) time+=1; hour=time/3600; printf("%.2d",hour); cout&lt;&lt;":"; minute=(time%3600)/60; printf("%.2d",minute); cout&lt;&lt;":"; second=(time%3600)%60; printf("%.2d",second); return 0;&#125; 1027 打印沙漏本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 12345***** *** * ******** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式:输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。 输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例:119 * 输出样例:123456***** *** * ********2 计算不难，在居中打印那里卡了一下，原本想着用C++居中打印太麻烦，干脆用python的center函数直接居中打印，也不用双循环，结果交上去竟然显示格式不对，看了它的输出格式才发现只用每行前面部门补空格就行，后半部分不用补空格，最后还是用C++双循环输出。 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,j,k,sum,num=1,s=0; string a; cin&gt;&gt;n&gt;&gt;a; sum=(n-1)/2; while(1) &#123; num+=2; s+=num; if(s&gt;sum) break; &#125; for(i=num-2;i&gt;=1;i-=2) &#123; for(k=1;k&lt;=(num-2-i)/2;k++) cout&lt;&lt;" "; for(j=1;j&lt;=i;j++) cout&lt;&lt;a; cout&lt;&lt;endl; &#125; for(i=3;i&lt;=num-2;i+=2) &#123; for(k=1;k&lt;=(num-2-i)/2;k++) cout&lt;&lt;" "; for(j=1;j&lt;=i;j++) cout&lt;&lt;a; cout&lt;&lt;endl; &#125; cout&lt;&lt;n-((s-num)*2+1)&lt;&lt;endl; return 0;&#125; 1028 人口普查某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。 这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。 输入格式：输入在第一行给出正整数 N，取值在(0,105]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 yyyy/mm/dd（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。 输出格式：在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。 输入样例：1234565John 2001/05/12Tom 1814/09/06Ann 2121/01/30James 1814/09/05Steve 1967/11/20 输出样例：13 Tom John 我是读入字符串，然后拆分了换算成年月日，然后计算2014年9月6日到出生日之间的天数来判断谁的年龄大，然后根据出生日期来判断是否符合规定，结果最后一组样例一直过不了，不知道为啥。看了网上的答案，发现可以用字符串直接比较大小……太牛逼了。 代码1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main() &#123; int n, cnt = 0; cin &gt;&gt; n; string name, birth, maxname, minname, maxbirth = "1814/09/06", minbirth = "2014/09/06"; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; birth; if (birth &gt;= "1814/09/06" &amp;&amp; birth &lt;= "2014/09/06") &#123; cnt++; if (birth &gt;= maxbirth) &#123;maxbirth = birth;maxname = name;&#125; if (birth &lt;= minbirth) &#123;minbirth = birth;minname = name;&#125; &#125; &#125; cout &lt;&lt; cnt; if (cnt != 0) cout &lt;&lt; " " &lt;&lt; minname &lt;&lt; " " &lt;&lt; maxname; return 0;&#125; 1029 旧键盘旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。 输入格式：输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 _（代表空格）组成。题目保证 2 个字符串均非空。 输出格式：按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。 输入样例：127_This_is_a_test_hs_s_a_es 输出样例：17TI 感觉C++的标准模板库中STL，string用的很多，但我掌握的还不够熟练，用string定义的字符串可以直接用“+”连接增加，用toupper()函数将小写字母转成大写字母，find()函数用于查找一个字符串中的子字符串。 代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int k=0; string str1,str2,ans; cin&gt;&gt;str1&gt;&gt;str2; for(int i=0;i&lt;str1.size();i++) &#123; if(str1[i]!=str2[k] &amp;&amp; ans.find(toupper(str1[i]))==string::npos) &#123; ans+=toupper(str1[i]); &#125; if(str1[i]==str2[k]) k++; &#125; cout&lt;&lt;ans; return 0;&#125; 1030 完美数列给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。 现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。 输入格式：输入第一行给出两个正整数 N 和 p，其中 N（≤105）是输入的正整数的个数，p（≤109）是给定的参数。第二行给出 N 个正整数，每个数不超过 109。 输出格式：在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。 输入样例：1210 82 3 20 4 5 1 6 7 8 9 输出样例：18 一开始我还以为mp就是m*10+p，看了半天算出来都是9才想起mp应该是mxp……暴力模拟有一组样例会超时，看了一下别人的答案，第二次循环的时候从i+res开始到n结束就可以了，因为是要找最大的res，如果i+res后面还有更多数，才可能更新res。 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int v[100005];int main()&#123; int n,i,j,counts,res=0; long long p; cin&gt;&gt;n&gt;&gt;p; for(i=0;i&lt;n;i++) cin&gt;&gt;v[i]; sort(v,v+n); for(i=0;i&lt;n;i++) &#123; for(j=i+res;j&lt;n;j++) &#123; if(v[j]&lt;=v[i]*p) &#123; counts=j-i+1; if(counts&gt;res) res=counts; &#125; else break; &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; 1031—10401031 查验身份证一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下： 首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： 12Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2 现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式：输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式：按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。 输入样例1：12345432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1：12312010X19890101123411010819671130186637070419881216001X 输入样例2：1232320124198808240056110108196711301862 输出样例2：1All passed 可以用两个数组来保存权重和需要比较的值，先写一个函数判断是否满足要求，然后一个一个读入判断。 代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int a[17] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;;int b[11] = &#123;1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2&#125;;string id;bool istrue()&#123; int sum=0; for(int i=0;i&lt;17;i++) &#123; if(id[i]&lt;'0' || id[i]&gt;'9') return false; sum+=(id[i]-'0')*a[i]; &#125; int temp=(id[17]=='X')?10:(id[17]-'0'); return b[sum%11]==temp;&#125;int main()&#123; int n,flag=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;id; if(!istrue()) &#123;cout&lt;&lt;id&lt;&lt;endl;flag=1;&#125; &#125; if(flag==0) cout&lt;&lt;"All passed"; return 0;&#125; 1032 挖掘机技术哪家强为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。 输入格式：输入在第 1 行给出不超过 105 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。 输出格式：在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。 输入样例：123456763 652 801 1002 703 403 0 输出样例：12 150 一个数组就可以搞定，千万别想着上结构体或者两个数组…… 代码123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int score[100005]=&#123;0&#125;;int main()&#123; int n,a,b,max_score=0,max_id=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; score[a]+=b; if(score[a]&gt;=max_score) &#123;max_score=score[a];max_id=a;&#125; &#125; cout&lt;&lt;max_id&lt;&lt;" "&lt;&lt;max_score&lt;&lt;endl; return 0;&#125; 1033 旧键盘打字旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 输入格式：输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 105 个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 _（代表空格）、,、.、-、+（代表上档键）。题目保证第 2 行输入的文字串非空。 注意：如果上档键坏掉了，那么大写的英文字母无法被打出。 输出格式：在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。 输入样例：127+IE.7_This_is_a_test. 输出样例：1_hs_s_a_tst 第一次交上去有一个测试点没过，被扣了一分，原因是有可能第一个字符串是空串（太坑了！）于是就不能用cin读入两个字符串，而是用getline(cin,str)的方式读入，只要读到换行就算读入了一个字符串。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string broken,str,ans; getline(cin,broken); getline(cin,str); for(int i=0;i&lt;str.size();i++) &#123; int flag=1; for(int j=0;j&lt;broken.size();j++) &#123; if(str[i]==broken[j] || str[i]==tolower(broken[j])) flag=0; if(str[i]&gt;='A' &amp;&amp; str[i]&lt;='Z' &amp;&amp; broken.find('+')!=string::npos) flag=0; &#125; if(flag==1) ans+=str[i]; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 1036 跟奥巴马一起编程美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式：输入在一行中给出正方形边长 N（3≤N≤20）和组成正方形边的某种字符 C，间隔一个空格。 输出格式：输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。 输入样例：110 a 输出样例：12345aaaaaaaaaaa aa aa aaaaaaaaaaa 双循环输出，四周输入字符，中间输出空格。注意是四舍五入，因为是除以2，所以如果有余数肯定就得加1。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,m; string s; cin&gt;&gt;n&gt;&gt;s; if(n%2!=0) m=(n/2)+1; if(n%2==0) m=n/2; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(i&gt;=1 &amp;&amp; i&lt;(m-1) &amp;&amp; j&gt;=1 &amp;&amp; j&lt;n-1) cout&lt;&lt;" "; else cout&lt;&lt;s; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 1037 在霍格沃茨找零钱如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 P 和他实付的钱 A，你的任务是写一个程序来计算他应该被找的零钱。 输入格式：输入在 1 行中分别给出 P 和 A，格式为 Galleon.Sickle.Knut，其间用 1 个空格分隔。这里 Galleon 是 [0, 107] 区间内的整数，Sickle 是 [0, 17) 区间内的整数，Knut 是 [0, 29) 区间内的整数。 输出格式：在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。 输入样例 1：110.16.27 14.1.28 输出样例 1：13.2.1 输入样例 2：114.1.28 10.16.27 输出样例 2：1-3.2.1 为了避免出现进位的问题，我直接全部转换成最小的单位，相减之后再除和取模。 代码1234567891011121314151617#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int pg,ps,pk,ag,as,ak; scanf("%d.%d.%d %d.%d.%d",&amp;pg,&amp;ps,&amp;pk,&amp;ag,&amp;as,&amp;ak); int P=pg*17*29+ps*29+pk; int A=ag*17*29+as*29+ak; int res=A-P; int resg=res/(17*29); int ress=(res%(17*29))/29; int resk=(res%(17*29*29))%29; if(res&gt;=0) cout&lt;&lt;resg&lt;&lt;"."&lt;&lt;ress&lt;&lt;"."&lt;&lt;resk&lt;&lt;endl; else cout&lt;&lt;"-"&lt;&lt;-resg&lt;&lt;"."&lt;&lt;-ress&lt;&lt;"."&lt;&lt;-resk&lt;&lt;endl; return 0;&#125; 1038 统计同成绩学生本题要求读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。 输入格式：输入在第 1 行给出不超过 105 的正整数 N，即学生总人数。随后一行给出 N 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 K（不超过 N 的正整数），随后是 K 个分数，中间以空格分隔。 输出格式：在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。 输入样例：1231060 75 90 55 75 99 82 90 75 503 75 90 88 输出样例：13 2 0 非常简单的题目，竟然最后一个测试点运行超时（……）结果把读入换成scanf就可以通过了，什么垃圾题目。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int s[105]=&#123;0&#125;; int n,m,a,b; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; scanf("%d",&amp;a); s[a]++; &#125; cin&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; scanf("%d",&amp;b); if(i==0) cout&lt;&lt;s[b]; else cout&lt;&lt;" "&lt;&lt;s[b]; &#125; return 0;&#125; 1039 到底买不买小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。 为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。 图 1 输入格式：每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。 输出格式：如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格分隔。 输入样例 1：12ppRYYGrrYBR2258YrR8RrY 输出样例 1：1Yes 8 输入样例 2：12ppRYYGrrYB225YrR8RrY 输出样例 2：1No 2 还是数组的问题，第一个字符串中出现一个，就在数组中对应存储一个，然后遍历第二个字符串中的每一个看数组里存的是几，大于0就说明有，用掉之后就减1，小于等于0就说明没有，就把缺少的个数增加1。 代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int book[256]=&#123;0&#125;;int main()&#123; string a,b; int lose=0; cin&gt;&gt;a&gt;&gt;b; for(int i=0;i&lt;a.size();i++) book[a[i]]++; for(int i=0;i&lt;b.size();i++) &#123; if(book[b[i]]&gt;0) book[b[i]]--; else lose++; &#125; if(lose==0) cout&lt;&lt;"Yes"&lt;&lt;" "&lt;&lt;a.size()-b.size()&lt;&lt;endl; else cout&lt;&lt;"No"&lt;&lt;" "&lt;&lt;lose&lt;&lt;endl; return 0;&#125; 1040 有几个PAT字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。 现给定字符串，问一共可以形成多少个 PAT？ 输入格式：输入只有一行，包含一个字符串，长度不超过105，只包含 P、A、T 三种字母。 输出格式：在一行中输出给定字符串中包含多少个 PAT。由于结果可能比较大，只输出对 1000000007 取余数的结果。 输入样例：1APPAPT 输出样例：12 拿到题目之后毫无头绪，看了别人的答案，瞬间搞懂：PAT的个数就等于每个A前面P的个数乘以T的个数，最后求和就可以了。所以先统计整个字符串中有多少个T，然后依次遍历字符串，遇到P就countp++，遇到T就countt–，然后遇到A就求乘积并累加取模。 代码12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string str; getline(cin,str); int countt=0,countp=0,res=0,mod=1000000007; for(int i=0;i&lt;str.size();i++) &#123; if(str[i]=='T') countt++; &#125; for(int i=0;i&lt;str.size();i++) &#123; if(str[i]=='P') countp++; if(str[i]=='T') countt--; if(str[i]=='A') res=(res+(countp*countt)%mod)%mod; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; 1041—10451041 考试座位号每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式：输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 14 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。 考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。 输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。 输入样例：1234567410120150912233 2 410120150912119 4 110120150912126 1 310120150912002 3 223 4 输出样例：1210120150912002 210120150912119 1 结构体。 代码12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;struct student&#123; string id; int num1; int num2;&#125;;int main()&#123; student students[1005]; int n,m,num; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;students[i].id&gt;&gt;students[i].num1&gt;&gt;students[i].num2; &#125; cin&gt;&gt;m; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;num; for(int j=0;j&lt;n;j++) &#123; if(students[j].num1==num) &#123; cout&lt;&lt;students[j].id&lt;&lt;" "&lt;&lt;students[j].num2&lt;&lt;endl; break; &#125; &#125; &#125; return 0;&#125; 1042 字符统计请编写程序，找出一段给定文字中出现最频繁的那个英文字母。 输入格式：输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。 输出格式：在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。 输入样例：1This is a simple TEST. There ARE numbers and other symbols 1&amp;2&amp;3........... 输出样例：1e 7 用string的tolower函数将大写字母转成小写字母然后统计，每新统计一个就进行一次比较，是当前最大的就进行替换。 代码1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int word[30]=&#123;0&#125;; int max_num=0; string str; char max_word='z'; getline(cin,str); for(int i=0;i&lt;str.size();i++) &#123; str[i]=tolower(str[i]); if(str[i]&gt;='a' &amp;&amp; str[i]&lt;='z') &#123; word[str[i]-'a']++; if(word[str[i]-'a']&gt;max_num || word[str[i]-'a']==max_num &amp;&amp; str[i]&lt;max_word) &#123; max_num=word[str[i]-'a']; max_word=str[i]; &#125; &#125; &#125; cout&lt;&lt;max_word&lt;&lt;" "&lt;&lt;max_num&lt;&lt;endl; return 0;&#125; 1043 输出PATest给定一个长度不超过 104 的、仅由英文字母构成的字符串。请将字符重新调整顺序，按 PATestPATest.... 这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。 输入格式：输入在一行中给出一个长度不超过 104 的、仅由英文字母构成的非空字符串。 输出格式：在一行中按题目要求输出排序后的字符串。题目保证输出非空。 输入样例：1redlesPayBestPATTopTeePHPereatitAPPT 输出样例：1PATestPATestPTetPTePePee 统计给出的字符串中P、A、T、e、s、t 的个数，出现次数最多的个数就是要循环输出的次数，然后每输出一个字符，对应的计数就减1。 代码12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string str; getline(cin,str); int num[6]=&#123;0&#125;; for(int i=0;i&lt;str.size();i++) &#123; if(str[i]=='P') num[0]++; if(str[i]=='A') num[1]++; if(str[i]=='T') num[2]++; if(str[i]=='e') num[3]++; if(str[i]=='s') num[4]++; if(str[i]=='t') num[5]++; &#125; int m=*max_element(num,num+6); for(int i=0;i&lt;m;i++) &#123; if(num[0]&gt;0) &#123;cout&lt;&lt;"P";num[0]--;&#125; if(num[1]&gt;0) &#123;cout&lt;&lt;"A";num[1]--;&#125; if(num[2]&gt;0) &#123;cout&lt;&lt;"T";num[2]--;&#125; if(num[3]&gt;0) &#123;cout&lt;&lt;"e";num[3]--;&#125; if(num[4]&gt;0) &#123;cout&lt;&lt;"s";num[4]--;&#125; if(num[5]&gt;0) &#123;cout&lt;&lt;"t";num[5]--;&#125; &#125; return 0;&#125; 1044 火星数字火星人是以 13 进制计数的： 地球人的 0 被火星人称为 tret。 地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。 火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。 例如地球人的数字 29 翻译成火星文就是 hel mar；而火星文 elo nov 对应地球数字 115。为了方便交流，请你编写程序实现地球和火星数字之间的互译。 输入格式：输入第一行给出一个正整数 N（&lt;100），随后 N 行，每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文。 输出格式：对应输入的每一行，在一行中输出翻译后的另一种语言的数字。 输入样例：123454295elo novtam 输出样例：1234hel marmay11513 这一个有点麻烦，首先读入必须得是字符串，因为不知道是地球文还是火星文，而且要用getline读入，因为可能是两个单词中间有空格。然后不管是火星文转地球文还是地球文转火星文，当火星文只有1位时，可能它正好是13的倍数，属于第二个字符串数组，也可能是小于13的数，属于第一个字符串数组。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string a[13]=&#123;"tret","jan","feb","mar","apr","may","jun","jly","aug","sep","oct","nov","dec"&#125;; string b[13]=&#123;"0","tam","hel","maa","huh","tou","kes","hei","elo","syy","lok","mer","jou"&#125;; int n; string str; cin&gt;&gt;n; for(int i=0;i&lt;=n;i++) &#123; getline(cin,str); if(str[0]&gt;='0' &amp;&amp; str[0]&lt;='9') &#123; int num=stoi(str); if(num/13&gt;0) &#123; int x1=num/13; int x2=(num%13)%13; if(x2==0) cout&lt;&lt;b[x1]&lt;&lt;endl; else cout&lt;&lt;b[x1]&lt;&lt;" "&lt;&lt;a[x2]&lt;&lt;endl; &#125; else cout&lt;&lt;a[num%13]&lt;&lt;endl; &#125; else &#123; int n1,n2; if(str[3]==' ') &#123; string s1=str.substr(0,3); string s2=str.substr(4,6); for(int i=0;i&lt;=13;i++) &#123; if(s1==b[i]) n1=i; &#125; for(int i=0;i&lt;=13;i++) &#123; if(s2==a[i]) n2=i; &#125; cout&lt;&lt;13*n1+n2&lt;&lt;endl; &#125; else &#123; int flag=0; for(int i=0;i&lt;=13;i++) &#123; if(str==a[i]) &#123;flag=1;cout&lt;&lt;i&lt;&lt;endl;&#125; &#125; if(flag==0) &#123; for(int i=0;i&lt;=13;i++) &#123; if(str==b[i]) cout&lt;&lt;13*i&lt;&lt;endl; &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1045 快速排序著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？ 例如给定 $N = 5$, 排列是1、3、2、4、5。则： 1 的左边没有元素，右边的元素都比它大，所以它可能是主元； 尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元； 尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元； 类似原因，4 和 5 都可能是主元。 因此，有 3 个元素可能是主元。 输入格式：输入在第 1 行中给出一个正整数 N（≤105）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 109。 输出格式：在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。 输入样例：1251 3 2 4 5 输出样例：1231 4 5 暴力的话会超时，于是不知道怎么做…..看了网上的答案，先将数组排序，如果排序前两个数字的位置没有变，而且这个数字比前面数中最大的数都大，就证明这个数是主元。这个题目的格式有点坑，可能出现0个主元的情况，如果只输出0就会报格式错误，必须再加一个空行的输出才可以。 代码1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int a[100005],b[100005],v[100005];int main()&#123; int n,max=0,cnt=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; b[i]=a[i]; &#125; sort(a,a+n); for(int i=0;i&lt;n;i++) &#123; if(a[i]==b[i] &amp;&amp; b[i]&gt;max) v[cnt++]=b[i]; if(b[i]&gt;max) max=b[i]; &#125; if(cnt==0) cout&lt;&lt;cnt&lt;&lt;endl; else &#123; cout&lt;&lt;cnt&lt;&lt;endl; cout&lt;&lt;v[0]; for(int i=1;i&lt;cnt;i++) cout&lt;&lt;" "&lt;&lt;v[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实验汇总]]></title>
    <url>%2F2018%2F11%2F24%2FPython%E5%AE%9E%E9%AA%8C%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Python实验课的实验内容汇总…… 实验一 Python环境及基础题目1：字符串拼接接受用户输入的两个字符串，将它们组合后输出。 123str1 = input("请输入第一个字符串：")str2 = input("请输入第二个字符串：")print(str1 + str2) 两个字符串可以用“+”连接成为一个新的字符串。 题目2：整数序列求和用户输入一个正整数N,计算从1到N(包含1和N)相加之后的结果。 12345num = eval(input("请输入一个整数："))sum = 0for i in range(num+1): sum = sum + iprint(sum) range(n)是从0到n-1 题目3：健康食谱输出列出5种不同的食材，输出它们可能组成的所有菜式名称。 12345diet = ['土豆','萝卜','牛肉','白菜','鸡肉']for x in diet: for y in diet: if x != y: print(x+y) 数组循环，可以使用for i in （数组名）的方式循环遍历。 题目4：太阳花的绘制绘制一个太阳花图形，效果如图： 12345678910import turtleturtle.color('red', 'yellow') turtle.begin_fill() while True: turtle.forward(200) turtle.left(170) if abs(turtle.pos()) &lt; 1: break turtle.end_fill() turtle.done() turtle库的用法 实验二 字符串运算及字符串格式化题目1：格式化输出字符串堆积的三角形其中，str.center()方法用于字符串两边填充：str.rjust(width[,fillchar])方法用于字符串右填充。 123456print("1".center(20)) # 1行20个字符，居中对齐print(format("121", "^20")) # 1行20个字符，居中对齐print(format("12321", "^20")) # 1行20个字符，居中对齐print("1".rjust(20, "*")) # 1行20个字符，右对齐，加*号print(format("121", "*&gt;20")) # 1行20个字符，右对齐，加*号print(format("12321", "*&gt;20")) # 1行20个字符，右对齐，加*号 字符串的格式化，须熟悉掌握 题目2：天天向上一年365天，以第1天的能力值为基数，记为1.0，当好好学习时能力值相比前一天提高1‰，当没有学习是由于遗忘等原因能力值相比前一天下降1‰，每天努力和每天放任，一年下来的能力值相差多少呢？ 1234567dayup = 1daydown = 1power = 0.001for i in range(365+1): dayup = dayup * (1 + power) daydown = daydown * (1 - power)print(dayup,daydown) 一年365天，一周5个工作日，如果每个工作日都很努力，可以提高1%，仅在周末放任一下，能力值下降1%，效果如何呢？ 12345678daypower = 1power = 0.01for i in range(0,365 + 1): if i % 7 in [0,6]: daypower = daypower * (1 - power) else: daypower = daypower * (1 + power)print(daypower) 题目3：凯撒密码设想在某些情况下给朋友传递字条信息，但又不希望传递中途被第三方看懂这些信息，因此需要对字条信息进行加密处理。传统加密算法很多，这里介绍一种非常简单的加密算法——凯撒密码。顾名思义，凯撒密码是古罗马凯撒大帝用来对军事情报进行加密的算法，它采用了替换算法对信息中的每一个英文字符循环替换为该字符后面第三个字符，对应关系如下： 原文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 密文：D E F G H I J K L M N O P Q R S T U V W X Y Z A B C 假设用户可能使用的信息仅包括所有英文字母，编程计算密文。 12345678910str = input("请输入明文：")answer = ""for i in str: if "a" &lt;= i &lt;= "z": answer = answer + chr((ord(i) - ord("a") + 3)%26 + ord("a")) elif "A" &lt;= i &lt;= "Z": answer = answer + chr((ord(i) - ord("A") + 3)%26 + ord("A")) else: answer = answer + iprint(answer) ord(“a”)表示字符a对应的acsii码，而chr(1)表示acsii码为1的字符。 题目4：文本进度条进度条是计算机处理任务或执行软件中增强用户体验的重要手段，它能够实时显示任务或软件的执行进度，十分常用。 编程实现如下图所示带刷新和时间监控的文本进度条： ———–执行开始———- 0 %[-&gt;…………………………………………..]0.00s 2 %[*-&gt;………………………………………….]0.05s 4 %[**-&gt;…………………………………………]0.15s 6 %[*-&gt;………………………………………..]0.30s 8 %[**-&gt;……………………………………….]0.50s 10 %[***-&gt;………………………………………]0.76s 12 %[******-&gt;……………………………………..]1.06s 14 %[*****-&gt;…………………………………….]1.41s 16 %[******-&gt;……………………………………]1.82s 18 %[*******-&gt;…………………………………..]2.27s 20 %[********-&gt;………………………………….]2.78s …… 98 %[***********************************************-&gt;.]61.95s 100%[************************************************-&gt;]64.48s ———–执行结束———- 123456789101112import timescale = 50print("执行开始".center(scale//2,"-"))t = time.clock()for i in range(scale+1): a = "*" * i b = "." * (scale - i) c = i/scale * 100 t -= time.clock() print("\r&#123;:3.0f&#125;%[&#123;&#125;-&gt;&#123;&#125;]&#123;:.3f&#125;s".format(c,a,b,-t))# 加上end=''之后可以动态更新 time.sleep(0.05)print("\n" + "执行结束".center(scale//2,"-")) 进度条问题，关键是输出格式和循环次数 实验三 控制结构（分支）题目1：身体质量指数BMIBMI 值可以“客观的”衡量个人的肥胖程度或者说健康程度。世界卫生组织（WHO）根据对全球人口体重的统计认为，BMI 值低于18.5 kg/m2 时属于“过轻”，表明个体可能营养不良或者饮食无法保障；BMI 值高于25 kg/m2 时属于“过重”。根据下表所示指标编程测试 自己的身体指数状况。 分类 国际BMI值 国内MBI值 偏瘦 &lt; 18.5 &lt; 18.5 正常 18.5 ~ 25 18.5 ~ 24 偏胖 25 ~ 30 24 ~ 28 肥胖 > = 30 >= 28 123456789101112131415161718192021height = eval(input("请输入你的身高（单位m）："))weight = eval(input("请输入你的体重（单位：kg）："))BMI = weight / pow(height, 2)if BMI &lt; 18.5: national = "偏瘦"elif BMI &lt; 25: national = "正常"elif BMI &lt; 30: national = "偏胖"else: national = "肥胖"if BMI &lt; 18.5: domestic = "偏瘦"elif BMI &lt; 24: domestic = "正常"elif BMI &lt; 28: domestic ="偏胖"else: domestic = "肥胖"print("BMI值为：",BMI)print("国际指数表明&#123;&#125;，国内指数表明&#123;&#125;".format(national,domestic)) 题目2：学生成绩等级判断编程实现输入学生成绩score，得出其等级状况grade,其对应关系如下： Score&gt;=85 grade=”A” 70&lt;=Score&lt;85 grade=”B” 60&lt;=Score&lt;70 grade=”C” Score&lt;60 grade=”D” 1234567891011score = eval(input("请输入学生成绩："))grade = ""if score &gt;= 85: grade = "A"elif 70 &lt;= score &lt;= 85: grade = "B"elif 60 &lt;= score &lt;= 70: grade = "C"elif score &lt; 60: grade = "D"print(grade) 题目3：猜数游戏在程序中预设一个0-9 之间的整数，让用户通过键盘输入所猜的数，如果大于预设的 数，显示“遗憾，太大了”；小于预设的数，显示“遗憾，太小了”，如此循环，直到猜中该数，显示“预测N 次，你猜中了！”，其中N 是用户输入的数字次数。 1234567891011121314import randomnumber = random.randint(0,9)print("正确的数值是：",number)count = 0while True: count = count + 1 guess = eval(input("请输入你猜的数值：")) if guess &gt; number: print("遗憾，太大了！") elif guess &lt; number: print("遗憾，太小了！") else: print("恭喜，猜对了！你一共猜了&#123;&#125;次".format(count)) break 实验四 控制结构（循环）题目1：统计不同字符个数用户从键盘输入一行字符，编写一个程序，统计并输出其中英文字符、数字、空格和其它字符的个数。 12345678910111213141516str = input("请输入一串字符串：")count1 = 0count2 = 0count3 = 0count4 = 0for i in str: if ord("a") &lt;= ord(i) &lt;= ord("z") or ord("A") &lt;= ord(i) &lt;= ord("Z"): count1 = count1 + 1 elif ord("0") &lt;= ord(i) &lt;= ord("9"): count2 = count2 + 1 elif i == ' ': count3 = count3 + 1 else: count4 = count4 + 1print("字母的个数是&#123;&#125;，数字的个数是&#123;&#125;，空格的个数是&#123;&#125;，其他类型的字符个数是&#123;&#125;" .format(count1,count2,count3,count4)) 题目2：猜数游戏续在上一次猜游戏实验题目的基础上，完善程序，实现如下的功能： 系统自动生成1-100以内的随机整数，让用户通过键盘输入所猜的数，如果大于预设的数，显示“遗憾，太大了”；小于预设的数，显示“遗憾，太小了”，如此循环，直到猜中该数，显示“预测N次，你猜中了！”，其中N是用户输入的数字次数。 如果用户输入的不是整数，而是小数，则提示用户“输入错误，必须输入整数！”，并让用户重新输入。如果用户输入的不是数字，则给出出错提示“输入格式错误，结束程序！” 123456789101112131415161718192021import randomnumber = random.randint(0,100)print("正确的数值是：",number)count = 0while True: count = count + 1 guess = input("请输入你猜的数值：") if guess.isalpha(): print("输入格式错误，结束程序！") break guess = eval(guess) if int(guess) == guess: if guess &gt; number: print("遗憾，太大了！") elif guess &lt; number: print("遗憾，太小了！") else: print("恭喜，猜对了！你一共猜了&#123;&#125;次".format(count)) break else: print("输入错误，必须输入整数！") str.isalpha()：如果字符串至少有一个字符并且所有字符都是字母则返回 True,否则返回 False 题目3：最大公约数计算从键盘接收两个整数，编写程序求出这两个整数的最大公约数和最小公倍数（提示：用辗转相除法求最大公约数，用两数乘积除以最大公约数求得最小公倍数） 1234567891011num1 = eval(input("请输入第一个数："))num2 = eval(input("请输入第二个数："))m = max(num1,num2)n = min(num1,num2)r = m % nwhile r != 0: m = n n = r r = m % nprint("&#123;&#125;和&#123;&#125;的最大公约数是&#123;&#125;".format(num1, num2, n))print("&#123;&#125;和&#123;&#125;的最小公倍数数是&#123;&#125;".format(num1, num2, (num1 * num2)/n)) 题目4：数字金字塔请编写程序实现如下数字金字塔的显示： 12345678910for i in range(1,10): st = "" j = i while j &gt; 1: st = st + str(j) j -= 1 while j &lt;= i: st = st + str(j) j += 1 print(st.center(17)) 实验五 组合数据类型题目1：密码生成编写程序，在 26 个字母大小写和 9 个数字组成的列表中随机生成 10个8位密码。 12345678import randomnum1 = [chr(i) for i in range(ord('0'),ord('9')+1)]num2 = [chr(i) for i in range(ord('a'),ord('z')+1)]num3 = [chr(i) for i in range(ord('A'),ord('Z')+1)]num = num1 + num2 + num3for i in range(10): code = random.sample(num,8) print(''.join(code)) random.sample()函数，从指定的list中随机选取指定长度的元素。str.join(list)表示list中间用str连接 题目2：排序通过键盘输入系列整数值，输入 0 则表示输入结束，将这些值（不含 0）建立为一个列表，并按从大到小的顺序输出该列表各元素。 12345678List = []number = eval(input("input number:"))List.append(number)while number != 0: number = eval(input("input number:")) List.append(number)List.sort(reverse=1)print(List) sort函数用于排序，默认是从小到大排序，reverse=1表示从大到小排序。 题目3：输出素数输入一个大于 2 的自然数， 输出小于该数字的所有素数组成的集合。 123456789101112def prim(number): for i in range(2,number): if number % i ==0: return False return Truenumber = eval(input("请输入一个大于2的数："))numbers = []for i in range(2,number): if prim(i): numbers.append(i)print(numbers) 题目4：英文电话号码使用字典来创建程序，提示用户输入电话号码，并用英文单词形式显示数字。例如：输入138则显示“one three eight”。 123456789def Getdict(phone): a = [i for i in range(10)] b = ['zero','one','two','three','four','five','six','seven','eight','nine'] mydict = dict(zip(a,b)) for i in phone: print(mydict[int(i)],end=' ')phone = input("请输入电话号码：")Getdict(phone) dict(zip(a,b))方法可以把a和b两个list的键和值转换为字典。print()函数默认输出后换行，如果想以其他形式结尾，可以使用end=‘ ’，表示用空格结尾。 实验六 综合题目1：抓狐狸游戏编写程序，模拟抓狐狸小游戏。假设一共有一排5个洞口，小狐狸最开始的时候在其中一个洞口，然后玩家随机打开一个洞口，如果里面有狐狸就抓到了。如果洞口里没有狐狸就第二天再来抓， 但是第二天狐狸会在玩家来抓之前跳到隔壁洞口里。 1234567891011121314import randomhole = random.randint(0,5)print("狐狸现在在&#123;&#125;号洞口".format(hole))while True: guess = eval(input("请选择洞口编号：")) if guess == hole: print("恭喜你，抓到狐狸了！") break else: print("猜错啦，再给你一次机会吧！") hole = hole + 1 if hole == 6: hole = 0 print("狐狸现在在&#123;&#125;号洞口".format(hole)) 题目2：三国演义统计《三国演义》中人物出场次数最多的前 20 人。 1234567891011121314151617181920import jiebaexcludes = &#123;"将军","却说","这样","他们","东汉","如今","然而","自己","这个","没有" ,"蜀汉","东吴","就是","已经","虽然","看到","不是","我们","立刻","一个", "汉中","公元"&#125;txt = open("F:\python选修课\三国演义.txt","r",encoding='utf-8').read()words = jieba.lcut(txt)counts = &#123;&#125;for word in words: if len(word)==1: continue else: counts[word] = counts.get(word,0) + 1for word in excludes: del(counts[word])items = list(counts.items())items.sort(key = lambda x:x[1], reverse = True)for i in range(20): word,count = items[i] print("&#123;0:&lt;10&#125;&#123;1:&gt;5&#125;".format(word,count)) 实验七 函数题目1：求和定义求 n! 的函数fact()和求和函数sum(),在此基础上编程实现 1！+2！+…m!的计算。 123456789101112131415def fact(n): answer = 1 for i in range(1,n+1): answer = answer * i return answerdef sum(number_list): s = 0 for i in number_list: s = s + fact(i) return sm = eval(input("请输入m："))number_list = [i for i in range(1,m+1)]print(sum(number_list)) 题目2：匿名函数求平方定义匿名函数实现求平方，定义判素数函数 list_prime(),该函数可以实现接受任意个数的判断，并将所有素数作为返回值。在此基础上编程实现随机输入任意个数，从中挑选出所有素数，并计算所有素数平方和。 123456789101112131415161718def prim_list(ls): prim = [] for i in ls: flag = 1 for j in range(2,i): if i % j ==0: flag = 0 if flag == 1: prim.append(i) return primmy_list = prim_list([1,2,3,4,5,6,7,8,9,10,13])print(my_list)square = lambda x:x * xsum = 0for i in my_list: sum = sum + square(i)print(sum) 普通函数的关键字是def，而匿名函数的关键字是lambda，匿名函数没有函数名，这里，lambda x: x * x 是 lambda 函数，其中 x 是参数，x * x 是表达式。这个函数没有名字，它返回一个函数对象，该对象被分配给变量 square，可以将其作为一个正常的函数来调用。 题目3：字母表字典分别定义 numlist()和 charlist()函数，numlist()功能是生成由数字1-26 构成的列表,charlist()功能是生成由字符 A-Z 构成的列表。在此基础上编写程序实现生成一个字典，具体如下：{1: ‘a’, 2: ‘b’, 3: ‘c’, 4: ‘d’, 5: ‘e’, 6: ‘f’, 7: ‘g’, 8: ‘h’, 9: ‘i’, 10: ‘j’, 11: ‘k’, 12: ‘l’, 13: ‘m’, 14: ‘n’, 15: ‘o’, 16: ‘p’, 17: ‘q’, 18: ‘r’, 19: ‘s’, 20: ‘t’, 21: ‘u’, 22: ‘v’, 23: ‘w’, 24: ‘x’, 25: ‘y’, 26: ‘z’}遍历字典，输出所有键值为偶数的元素。 123456789101112def num_list(): numbers = [i for i in range(1,27)] return numbersdef char_list(): chars = [chr(i) for i in range(ord('a'),ord('z')+1)] return charsenglish_list = dict(zip(num_list(),char_list()))for key, value in english_list.items(): if key % 2 == 0: print(value,end=' ') 字典的循环，需要使用english_list.items()迭代遍历。 实验八 文件与数据格式化题目1：csv转json将提供的 test.csv 文件，具体内容如下： 编程读入该文件，转换成 JSON 格式文件，并以文件名 out.json 输出。 1234567891011121314import jsonlines = open('test.csv','r').readlines()lines = [line.strip() for line in lines]key = lines[0].split(',')data = []for i in range(1,len(lines)): value = lines[i].split(',') data.append(dict(zip(key,value)))json_str = json.dumps(data,ensure_ascii=False,indent=len(lines))jsonfile = open('out1.json','w',encoding='utf-8')jsonfile.write(json_str)jsonfile.close() csv.DictReader(csvfile)这个函数可以直接将CSV文档读取为字典的形式。json.dump(row,jsonfile,ensure_ascii=False)这个函数用于将python对象编码成JSON字符串，第一个参数是python对象，第二个是编码格式，必须要使用ensure_ascii=False，否则会有乱码。indent参数可以加也可以不加，加了之后更加美观，否则就是一排。 扩展：json转csv12345678910import csvimport jsonjsonfile = open('out1.json',encoding='utf-8')data = json.loads(jsonfile.read())csvfile = open('outcsv.csv','w',encoding='utf-8')dw = csv.DictWriter(csvfile, data[0].keys())dw.writeheader()for row in data: dw.writerow(row) 文件读写最需要注意的问题就是编码格式！最好统一加上utf-8的编码格式。json.dumps()用于写数据，json.loads()用于读取数据。csv.DictWriter()用于把字典格式的数据写入csv。 题目2：制作英文学习字典编写程序制作英文学习字典，词典基本功能如下：(1) 程序读取源文件路径下的 txt 格式词典文件，若没有就创建一个。 词典文件存储方式为 “英文单词 中文单词”,每行仅有一对中英文释义。(2) 程序有添加功能，输入英文单词，如果没有可以添加中文释义，如果有就显示”已经存在，不能添加”(3) 程序有查询功能，如果存在，则显示其中文释义，不存在就显示不存在(4) 程序有正常退出的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344def checkWords(file,word): # file = open('dict.txt','r+') flag = True line = file.readline() while line: if word in line: flag = False print("该单词的释义是：",line.split(' ')[1]) line = file.readline() if flag: print("找不到该单词哦！")def addWords(file,word,explain): flag = True # file = open('dict.txt','r+') line = file.readline() while line: if word in line: flag = False print("该单词已经存在啦！") line = file.readline() if flag: file.write("\n" + word + " " + explain) print("添加成功！")if __name__ == '__main__': print("单词本功能如下：\n1.查询单词\n2.添加单词及解释\n3.退出单词本") while True: op = input("请输入你的选择：") if eval(op) == 1: file = open('dict.txt','r+') word = input("请输入你想查找的单词：") checkWords(file,word) file.close() elif eval(op) == 2: file = open('dict.txt','r+') word = input("请输入你想添加的单词：") explain = input("请输入释义：") addWords(file,word,explain) file.close() elif eval(op) == 3: break else: print("请输入正确的选择！") file = open(‘dict.txt’,’r+’)这个函数用于读取txt文件，“r+”模式是读写模式，既可以读也可以写。核心是line = file.readline()然后whlie line:循环使用line = file.readline()即可遍历到每一行。 大作业题目1：打地鼠编写程序，模拟打地鼠游戏。假设一共 8 个洞口，地鼠最开始的时候随机出现在其中一个洞口，然后玩家随机打开一个洞口。其中每轮打地鼠结果描述如下： （1） 如果里面有地鼠就打到了，游戏结束。 （2） 如果洞口里没有地鼠就计算离打到地鼠还距离几个洞口，如果相差 1 个洞口，就提示“很遗憾，就差一点”，然后开始第二轮打地鼠；如果相差 2 个及以上洞口的话，就再给一次打的机会，打到游戏结束，没打到则开始第下一轮打地鼠。 （3） 下一轮再打时， 地鼠会在玩家再次打之前随机跳到某个洞口里。 其它要求： （1） 游戏总共提供 10 次机会，编写进度条展示游戏进行的情况。 （2） 每轮初始输入洞口号需要进行合法性。 12345678910111213141516171819202122232425262728import randomdef game(): right = random.randint(1,8) print("地鼠现在在&#123;&#125;号洞口".format(right)) while True: guess = input("请输入洞口号：") try: if eval(guess) == right: print("恭喜你打到地鼠了！游戏结束！") break elif eval(guess) - right == 1 or right - eval(guess) == 1: print("很遗憾，就差一点了！即将进入下一局！") break else: print("没打到哦，再给你一次机会吧！") except Exception as e: print("你输入的数据不合法！请重新输入")if __name__ == '__main__': scale = 10 for i in range(1,11): a = '*' * i b = '-' * (scale - i) c = i/(scale) * 100 print("[&#123;&#125;-&gt;&#123;&#125;]&#123;&#125;%".format(a,b,c)) print("这是第&#123;&#125;次游戏".format(i).center(20,'-')) game() print("\n") 题目2：打印杨辉三角形杨辉三角形通常从第 0 行开始枚举，并且每一行的数字是上一行相邻两个数字的和。简单的杨辉三角形可以由以下方式产生：在第 0 行只写一个数字 1，然后构造下一行的元素。将上一行中数字左侧上方和右侧上方的数值相加。如果左侧上方或右侧上方数字不存在，用 0代替。例如，第一行的第一个数字是 0+1=1，而第三行的数字 1 和 3 相加得到在第 4 行的数字 4，下面给出 6 行的杨辉三角形。 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 编写程序：提示输入杨辉三角形的高度，然后生成和上面例子一样风格的三角形并打印输出。 12345678910111213141516def triangles(): a = [1] while True: yield a a=[sum(i) for i in zip([0] + a,a + [0])] for x in a: print(x,end=' ') # 每个数中间用空格隔开 print("")# 换行if __name__ == "__main__": g=triangles() number = eval(input("请输入杨辉三角形的高度:")) if number &gt; 1: print(1) for n in range(number): next(g) 题目3：密码编写程序模拟验证码的验证过程，具体要求如下： （1）程序从 26 个大小写英文字母和 10 个数字中随机生成长度为 4 的验证码。 （2）显示当前的验证码，并请用户输入；如果输入正确，则提示验证成功，退出程序；否则重新生成验证码，提示用户重新输入。如果验证错误次数大于等于 3 次，则提示用户验证失败，退出程序。 要求：随机验证码的生成用函数实现。 12345678910111213141516171819202122import randomdef code(): code1 = [chr(i) for i in range(ord('a'),ord('z'))] code2 = [chr(i) for i in range(ord('A'),ord('Z'))] code3 = [chr(i) for i in range(ord('0'),ord('9'))] codes = code1 + code2 + code3 p = "" for i in range(4): j = random.randint(0,len(codes)-1) p = p + codes[j] return pif __name__ == '__main__': right = code() print("验证码为[&#123;&#125;]".format(right)) for i in range(3): answer = input("请输入验证码：") if answer == right: print("验证成功！") break elif answer != right: print("验证失败，请重新输入！") 题目4：西游记编程读取文件“西游记.txt”，统计人物出场次数，并输出结果。 123456789101112131415161718import jiebafile = open('西游记.txt','r',encoding='gbk').read()words = jieba.lcut(file)counts = &#123;&#125;exclude = &#123;"我们","来到","一个","国王","小妖","什么","变成","菩萨", "你们","和尚","怎么","那怪","二人","就是"&#125;for word in words: if len(word) == 1: continue else: counts[word] = counts.get(word,0) + 1for word in exclude: del(counts[word])items = list(counts.items())items.sort(key=lambda x:x[1],reverse=True)for i in range(10): word,count = items[i] print(word,count) 题目5：凯撒密码升级完整版分别定义解码和编码的函数，增加移位数的选择，增加退出功能 12345678910111213141516171819202122232425262728293031323334353637def incoding(origin,k): code = "" for word in origin: if 'a' &lt;= word &lt;= 'z': word = chr((ord(word) - ord('a') + k) % 26 + ord('a')) elif 'A' &lt;= word &lt;= 'Z': word = chr((ord(word) - ord('A') + k) % 26 + ord('A')) code = code + word return codedef decoding(code,k): origin = "" for word in code: if 'a' &lt;= word &lt;= 'z': word = chr((ord(word) - ord('a') - k) % 26 + ord('a')) if 'A' &lt;= word &lt;= 'Z': word = chr((ord(word) - ord('A') - k) % 26 + ord('A')) origin = origin + word return originif __name__ == '__main__': while True: print("1.加密\n2.解密\n3.退出") op = eval(input("请选择：")) if op == 1: origin = input("请输入待加密的字符串：") k = eval(input("请输入移位的个数：")) print("加密后的密文是：&#123;&#125;".format(incoding(origin,k))) elif op == 2: code = input("请输入密文：") k = eval(input("请输入移位的个数：")) print("解密后的原文是：&#123;&#125;".format(decoding(code,k))) elif op == 3: print("再见！") break else: print("请选择正确的编号！")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMeter 压力测试教程]]></title>
    <url>%2F2018%2F08%2F21%2FJMeter-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[用badboy录制脚本，在JMeter上对服务器进行压力测试的基本教程。 安装和环境配置JMeter需要 java 环境，所以首先安装 JDK，配置 java 的环境变量。 然后在 JMeter 官网下载压缩包 JMeter官网链接： 修改环境变量，在【我的电脑】- &gt; 右键【属性】 -&gt; 【高级系统设置】 -&gt; 【高级】 -&gt; 【环境变量】 在系统变量中新建一个变量 变量名：【JMETER_HOME】 变量值：【D:\apache-jmeter-4.0\】（自己jmeter文件的解压路径） 变量名：【CLASSPATH】 变量值：【%JMETER_HOME\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;%JMETER_HOME%\lib\logkit-2.0.jar;】 这样就把 JMeter 的环境变量配置好了，在 JMeter 文件夹的 bin 目录下，找到jmeter.bat，双击运行就可以打开 jmeter 的GUI界面。 接下来需要下载 badboy （用来录制脚本），直接在官网下载，badboy官网下载地址，然后安装好就可以使用了。 用badboy录制脚本打开badboy，在上方搜索框中输入网址，我这里输入的是搜狐的官网地址，按下回车，就可以进入网页中，左侧的测试套件文件夹中，有个test1文件夹，里面的 step1 对应的就是打开搜狐官网这个操作。 接下来在搜索框中输入搜索信息，点击打开搜索信息页，这些步骤都会在badboy 的左侧文件结构中自动添加，最后效果如下： 把“+”号点开以后，可以看到每个请求低下还包含很多子请求，在badboy中，会自动把主请求和子请求分开，但是在JMeter中所有的请求都会堆在一起，为了便于区分，我们先在badboy中添加自步骤（Add Child Step）： 最后左侧的结果效果大概是这样： 录制脚本基本就是这个流程，可以回放（Play Whole Test）查看录制的响应内容，然后保存，直接Export To Jmeter。文件名的后缀是“.jmx”，也可以把这个录制好的脚本直接保存下来，文件名的后缀是“.bx”。 在JMeter上进行压力测试基本操作打开jmeter，点击左上角的【文件】- &gt; 【打开】 ，找到刚刚保存的 ”.jmx”文件，打开。 可以看到线程组，名称可以自己修改，改变线程组数，比如我填写的10，就会模拟10次访问操作（即给服务器施加压力），也可以修改间隔时间、循环次数。 再添加一个“查看结果树”便于查看运行结果： 接下来，点击上方绿色的“运行”之后，结果树里就会将子请求的访问信息增添到里面，绿色表示通过。选择HTML，查看“相应数据”即可看到一些网页的响应效果。 参数化设置参数化的压力测试运用场景：模拟多次搜索，每次搜索不同的内容时，就可以对搜索内容进行参数化自动模拟。 首先，找到搜索对应的链接，点击鼠标右键，“添加CSV数据文件设置”： 然后打开CSV数据文件设置页，需要修改一些内容： 注意要记住CSV数据文件的位置，还有变量名称右面还要用上。 在文件路径下，创建一个data.dat的文件，用 notepad++编辑，在里面输入想要搜索的参数： 然后在搜素的那个页面中，可以找到搜索的关键词，将变量值改为${query}，大括号内就是刚刚输入的变量名称： 再次运行，在结果树，选择HTML，查看响应数据，就可以看到参数化的搜索信息： 事务设置运用场景：在JMeter中，所有的请求都列在一起，生成的报告就不方面我们查看效果，所以我们用事务进行分类。 依然是点击鼠标右键，添加事务控制器 然后可以把相关的请求全部拖到一个事务中，给事务修改名称。 检查点设置应用场景：刚刚对搜索内容进行了参数化的设置，那么我们怎么知道jmeter的确搜索到了这些参数内容呢？那么就需要增加检查点，检查搜索到的内容是不是包含我们的搜索参数。 依然在搜索页面下，添加响应断言。 在响应断言的页面中修改相关内容，增加要测试的模式，即是前面增加的搜索参数，写法和参数化中的写法完全一样，这样就设置好了响应断言。 再次运行，在结果树中，如果都是绿色的，就表示断言都通过了，搜索到的内容的确就是输入的搜索参数。 集合点设置运用场景：修改同时操作的用户数。 点击鼠标右键，添加Synchronize Timer 修改对应的设置： 压力测试结果查看添加聚合报告 运行完后，聚合报告会显示压测的结果。主要观察Samples、Average、error、Throughput。 Samples:表示一共发出的请求数 Average：平均响应时间，默认情况下是单个Request 的平均响应时间（ms） Error%:测试出现的错误请求数量百分比。若出现错误就要看服务端的日志，配合开发查找定位原因 Throughput:简称tps,吞吐量，默认情况下表示每秒处理的请求数，也就是指服务器处理能力，tps 越高说明服务器处理能力越好。]]></content>
      <categories>
        <category>软件测试</category>
        <category>JMeter</category>
      </categories>
      <tags>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC学习笔记]]></title>
    <url>%2F2018%2F07%2F24%2FSpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[新手学习SpringMVC，笔记持续更新…… 路径参数controller.java123456@RequestMapping(value = "/page/&#123;name&#125;/&#123;age&#125;", method = RequestMethod.GET) public String getName(ModelMap map, @PathVariable("name") String name, @PathVariable("age") int age)&#123; map.addAttribute("name", name); map.addAttribute("age", age); return "name"; &#125; RequestMapping中的value代表页面的url路径，{name}和{age}是两个动态参数。 在getName函数中，需要声明这两个变量的变量类型（IDEA中可以用alt+enter自动补全）。 返回值是”name”，所以接下来需要创建、编辑name.jsp文件。 name.jsp123456789101112&lt;%@ page pageEncoding="utf-8" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 名字：$&#123;name&#125;&lt;br&gt; 年龄：$&#123;age&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 通过 \${name} 和 ${age} 来获取主函数中的参数。 访问页面运行项目，在浏览器中打开：localhost:8080/page/xiaoming/12，效果如下： 更改一下url中的内容，网页内容也会随之改变： url参数controller.java123456@RequestMapping(value = "/result",method = RequestMethod.GET) public String result(ModelMap map, @RequestParam String name,@RequestParam int age)&#123; map.addAttribute("name",name); map.addAttribute("age",age); return "result"; &#125; 函数中同样传入两个参数：name和age。用的是RequestParam的传参方式。 返回值是result，所以需要新增、编辑一个result.jsp文件。 result.jsp12345678910111213141516&lt;%@ page pageEncoding="utf-8" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 名字：$&#123;name&#125;&lt;br&gt; 年龄：$&#123;age&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 访问页面运行项目，在浏览器中打开localhost:8080/result，结果如下： 显示没有name参数。 这个是需要从url中传参的，传参方式是在浏览器中输入链接地址：localhost:8080/result?name=xiaoming&amp;age=12，效果如图： 这种在url中添加?参数=参数名的方式，就是url传参的方法。如果有多个参数，就用 &符号连接即可。 HTML表单controller.java123456@RequestMapping(value = "/adduser", method = RequestMethod.GET) public String addUser(ModelMap map)&#123; //html表单 return "add_user"; &#125; 函数里面暂时没有指令，返回值是“add_user”，所以接下来新建、编辑add_user.jsp。 add_user.jsp123456789101112131415161718192021222324&lt;%@page pageEncoding="UTF-8" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="result" method="get"&gt; 姓名：&lt;label&gt; &lt;input type="text" name="name"&gt;&lt;/label&gt;&lt;br&gt; 年龄：&lt;label&gt; &lt;input type="number" name="age"&gt;&lt;/label&gt;&lt;br&gt; &lt;input type="submit"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 访问页面运行项目，在浏览器中打开localhost:8080/adduser，结果如下： 可以输入内容后点击提交，就会跳转到前面编辑过的result页面： 这时get方式的效果，如果是post方式，参数就不会在url中显现。 现在改为post方式，需要把add_user.jsp中form标签中的method改为post，同时把controller.java中的result函数改为post方式： ↓ add_user.jsp 123456789&lt;form action="result" method="post"&gt; 姓名：&lt;label&gt; &lt;input type="text" name="name"&gt;&lt;/label&gt;&lt;br&gt; 年龄：&lt;label&gt; &lt;input type="number" name="age"&gt;&lt;/label&gt;&lt;br&gt; &lt;input type="submit"&gt;&lt;/form&gt; ↓ controller.java 1234567@RequestMapping(value = "/result",method = RequestMethod.POST) public String result(ModelMap map, @RequestParam String name,@RequestParam int age)&#123; //url参数 map.addAttribute("name",name); map.addAttribute("age",age); return "result"; &#125; 页面效果如下，url中不会有参数回显： 使用Spring MVC的表单使用SpringMVC的表单比HTML表单有什么优势呢？如果想创建一个表单，并且给它提供一个默认值时，使用SpringMVC的表单非常方便。可以先从数据库里面查询出特定的值，然后填充到表单里。 add_user.jsp先把刚刚写的HTML那一段form标签里面的内容注释掉，然后改写为调用SpringMVC的form： 代码如下： 123&lt;form:form action="result" method="post" modelAttribute="user"&gt; &lt;/form:form&gt; 这里相当于是从ModelMap中取值，名称为user。user值我们还没有创建，所以现在需要先创建一个user对象。在src/com.spring.mvc目录下新建一个Java Class，命名为User。 User.java设置两个参数变量：String类型的name变量，和 int 类型的age变量。然后写上初始化函数和传参函数： 123456789101112131415161718192021222324package com.spring.mvc;public class User &#123; //两个默认参数对应的值 private String name="admin"; private int age=20; //初始化和传参函数 public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125; controller.java1234567@RequestMapping(value = "/adduser", method = RequestMethod.GET) public String addUser(ModelMap map)&#123; User u = new User(); u.setName("cici"); map.addAttribute("user",u); return "add_user"; &#125; new一个user对象，setName为cici，然后通过addAttribute传入参数。目前user对应的两个变量应该是：name被改为cici了，age没有被修改，即是默认值20。（默认值定义在User.java中） 这里的user参数和add_user.jsp的form标签里写的modelAttribute=user相对应。 现在继续完成add_user.jsp： 12345&lt;form:form action="result" method="post" modelAttribute="user"&gt; &lt;form:input path="name"/&gt;&lt;br&gt; &lt;form:input path="age"/&gt;&lt;br&gt; &lt;input type="submit"/&gt;&lt;/form:form&gt; 这时表单会先进行默认的数据填充。 访问页面重新部署后，访问页面localhost:8080/adduser，可以看到表单已经按照默认数据进行了填充。 使用Hibernate连接数据库新建数据库我使用的数据库是xampp这个集成环境，运行xampp后，在浏览器中打开localhost/dashboard，再进入phpmyadmin，就可以进入到编辑数据库的地方。 现在，在phpmyadmin中新建一个数据库，数据库名为mydb，编码方式是 utf8_general_ci。 接下来创建一个数据库表，表名为users，字段数 3。 第一列的名字为 id ，类型为BIGINT，勾选自增长组建。 第二列的名字为name，类型为VARCHAR，不超过100个字符长度。 第三列的名字为age，类型为TINYINT。 保存后，就会创建这样一个mydb数据库，users表。 然后插入一条数据，name=admin，age=5： 连接数据库在IDEA中打开database，添加一个数据库，选择类型为mysql： 然后填写数据库信息，xampp默认的用户名是root，密码为空： 连接成功后，就可以看到数据库的情况了： 使用Hibernate框架在项目上点右键，选择“add Framework Support”： 勾选对应的，然后download： 然后，添加一个包名，勾选users： 点击OK，就会全自动的生成对应的文件。 在这个配置文件下，可以看到引用了一个包com.mysql.jdbc.Driver，我们的项目中并没有这个包，所以需要先下载这个包。 可以在mysql官网下载mysql-connector-java 的jar包： 然后在IDEA中导入mysql-connector-java.jar，在项目文件夹的lib中，拷贝这个jar文件。 然后在File –&gt; Project Structure，在左侧找到Libraries，添加这个jar文件。 然后发现problems里面有几个问题，都是没有添加的问题，点击【fix】就可以自动修复。 再回到配置代码中，可以看到这个包已经可以正常调用了： 获取数据库中的数据在 com.spring.mvc 包目录下新建一个包，命名为db，把Entities包移动到 com.spring.mvc 包目录下，然后把main函数移动到db包中，把main函数改名为DbConnection，其中的主函数暂时不需要，可以注释掉。 最终的目录结构以及DbConnection.java的内容如图： 在 com.spring.mvc包中，再创建一个controller包，并把Controller.java移动进去。 在 WEB-INF文件下，新建一个classes目录，并把hibernate的配置文件移动进去。 hibernate.cfg.xml12345678910111213141516&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name="connection.url"&gt;jdbc:mysql://localhost:3306/mydb?serverTimezone=UTC&lt;/property&gt; &lt;property name="connection.driver_class"&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;property name="connection.username"&gt;root&lt;/property&gt; &lt;property name="connection.password"&gt;root&lt;/property&gt; &lt;mapping class="com.spring.mvc.db.Entities.UsersEntity"/&gt; &lt;!-- DB schema will be updated if needed --&gt; &lt;!-- &lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt; --&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; UserController.java123456789101112131415161718192021222324252627package com.spring.mvc.controllers;import com.spring.mvc.db.DbConnection;import com.spring.mvc.db.Entities.UsersEntity;import org.hibernate.Session;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.List;@Controllerpublic class UserController &#123; @RequestMapping(value = "/users", method = RequestMethod.GET) public String listUsers(ModelMap map)&#123; Session session = DbConnection.getSession(); List&lt;UsersEntity&gt; list=session.createCriteria(UsersEntity.class).list(); map.addAttribute("users",list); session.close(); return "users"; &#125;&#125; users.jsp12345678910111213141516171819&lt;%@ page import="com.spring.mvc.db.Entities.UsersEntity" %&gt;&lt;%@ page import="java.util.List" %&gt;&lt;%@page pageEncoding="UTF-8" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ol&gt; &lt;%for (UsersEntity e:(List&lt;UsersEntity&gt;)request.getAttribute("users"))&#123; %&gt; &lt;li&gt;名字：&lt;%out.print(e.getName());%&gt;,年龄：&lt;%out.print(e.getAge());%&gt;&lt;/li&gt; &lt;%&#125;%&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; 访问页面localhost:8080/users页面效果如下： 成功从数据库中获取到了数据并呈现出来。 实现添加用户的函数为了使代码更合理，先把adduser函数和result函数从最初的HelloMVCController中，移动到UserController中。 123456789101112131415@RequestMapping(value = "/adduser", method = RequestMethod.GET) public String addUser(ModelMap map)&#123; //表单 User u = new User(); u.setName("cici"); map.addAttribute("user",u); return "add_user"; &#125;@RequestMapping(value = "/result",method = RequestMethod.POST) public String result(ModelMap map, @RequestParam String name,@RequestParam int age)&#123; //url参数 map.addAttribute("name",name); map.addAttribute("age",age); return "result"; &#125; 现在需要修改result函数，把获取到的参数保存到服务器，而不仅仅是ModelMap map，修改后的result函数如下，其中新传入了一个参数HttpServletRequest request和HttpServletResponse response，需要增加相关的包：import javax.servlet.http.HttpServletRequest;。 1234567891011121314151617181920@RequestMapping(value = "/result",method = RequestMethod.POST) public String result(ModelMap map, @RequestParam String name, @RequestParam int age, HttpServletRequest request, HttpServletResponse response)&#123; //url参数 map.addAttribute("name",name); map.addAttribute("age",age); Session session = DbConnection.getSession(); Transaction transaction = session.beginTransaction(); UsersEntity ue = new UsersEntity(); ue.setName(name); ue.setAge((byte)age); session.save(ue); transaction.commit(); session.close(); return "result"; &#125; 然后在result.jsp中引入一段程序，进行跳转： 123&lt;% response.sendRedirect("users");%&gt; 完整代码如下： 1234567891011121314151617181920&lt;%@ page pageEncoding="utf-8" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 名字：$&#123;name&#125;&lt;br&gt; 年龄：$&#123;age&#125; &lt;% response.sendRedirect("users"); %&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 现在在users.jsp中，加入一个跳转链接： 1&lt;a href="adduser"&gt;添加用户&lt;/a&gt; 完整代码如下： 1234567891011121314151617181920&lt;%@ page import="com.spring.mvc.db.Entities.UsersEntity" %&gt;&lt;%@ page import="java.util.List" %&gt;&lt;%@page pageEncoding="UTF-8" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ol&gt; &lt;%for (UsersEntity e:(List&lt;UsersEntity&gt;)request.getAttribute("users"))&#123; %&gt; &lt;li&gt;名字：&lt;%out.print(e.getName());%&gt;,年龄：&lt;%out.print(e.getAge());%&gt;&lt;/li&gt; &lt;%&#125;%&gt;&lt;/ol&gt;&lt;a href="adduser"&gt;添加用户&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 运行项目，打开localhost:8080/users，页面效果如下： 点击链接，进入到adduser界面，添加用户信息，点击提交： 回到了users页面，并且这条数据已经加入到用户列表中了！神奇！ 登到phpmyadmin中看一看，神奇！已经写入了mydb的数据库，users表中：]]></content>
      <categories>
        <category>spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
        <tag>java</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于SpringMVC的url-pattern]]></title>
    <url>%2F2018%2F07%2F24%2F%E5%85%B3%E4%BA%8ESpringMVC%E7%9A%84url-pattern%2F</url>
    <content type="text"><![CDATA[记录在学习spring MVC中遇到的一个坑：controller里面定义的内容无法访问，报错404。最后发现是web.xml配置文件里面的一个小错误，在这里做一个记录。 在Intelli IDEA中初始化一个springMVC项目以后，web.xml的内容如下： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 然后在controller中定义了一个页面跳转： 12345678910@Controller@RequestMapping("/")public class HelloMVCController &#123; @RequestMapping(value = "/hello", method = RequestMethod.GET) public String printWelcome(ModelMap model) &#123; model.addAttribute("msg", "Spring MVC Hello World"); model.put("content", "This is my first spring mvc web!"); return "hello"; &#125;&#125; servlet.xml中也定义了文件位置： 1234567&lt;!--对应src下的包名，需要自己新建--&gt; &lt;context:component-scan base-package="com.spring.mvc" /&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 这个配置是配置JSP页面的位置，按照你自己的配置来配 --&gt; &lt;property name="prefix" value="/WEB-INF/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; 然而每次只能访问到 localhost:8080,显示的内容是WEB-INF目录下的index.jsp，手动在url中加上“/hello”,就报错404，十分绝望。 其实是在web.xml中的 &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 出了问题，改为 &lt;url-pattern&gt;/&lt;/url-pattern&gt; 就可以了！ ①：&lt;url-pattern&gt;/&lt;/url-pattern&gt; 会匹配到/login这样的路径型url，不会匹配到模式为*.jsp这样的后缀型url②：&lt;url-pattern&gt;/*&lt;/url-pattern&gt; 会匹配所有url：路径型的和后缀型的url(包括/login,*.jsp,*.js和*.html等) ①：地址为 localhost:8080/login , /login 返回login.jsp 访问去Controller下的/login 跳转到相应的视图login.jsp ②：访问的地址为 localhost:8080/login/ ，/login 返回login.jsp 访问去Controller下的/login,跳转到login.jsp ，然后进过dispatchservlet的时候，由于是/* ，又会以localhost:8088/login/login.jsp 去请求Controller ,那么如果Controller没有 /login/login.jsp 的Mapping映射，则会报404 错误！]]></content>
      <categories>
        <category>spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
        <tag>java</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ SLT学习笔记]]></title>
    <url>%2F2018%2F07%2F19%2FC-SLT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[感觉自己敲了很久的C++，每次做算法题目的时候，依然还停留在C的水平，这次系统的学习一下C++ STL 中的数据结构和容器。 什么是STL？STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。 STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组； STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效； 从逻辑层次来看，在STL中体现了泛型化程序设计的思想，引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代子（iterator）等。与OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术；从实现层次看，整个STL是以一种类型参数化的方式实现的，这种方式基于一个在早先C++标准中没有出现的语言特性–模板（template）。 总之，C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件： 组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。 stringC++ 标准库中的string表示可变长的字符串，它在头文件string里面。 比C语言中的char用起来要方便很多！ 常用函数汇总： 12345678910111213141516171819202122getline(cin,s) //读取一行字符串赋给s，（可以带空格），返回字符串ss.empty() //s为空返回true，否则返回falses.size() //返回s中字符的个数s[n] //返回s中第n个字符的值，位置从0开始计数s1 + s2 //返回s1和s2连接后的结果s1 = s2 //用s2的副本代替s1中原来的字符s1 == s2 //判断s1和s2是否完全相等（对大小写敏感）s1 != s2 //不相等&lt;,&lt;=,&gt;,&gt;= //利用字符在字典中的顺序进行比较，且对字母的大小写敏感str.find("ab"); //返回字符串ab在str的位置str.substr(3); //返回str[3]及以后的子串str.substr(2,4); //返回str[2]~str[2+(4-1)]子串(即从[2]开始4个字符组成的字符串)str.replace(2, 4, "ab"); //返回把 [2]~[2+(4-1)] 的内容替换为 "ab" 后的新字符串str.replace(2, 4, "abcd", 3); //返回把 [2]~[2+(4-1)] 的内容替换为 "abcd" 的前3个字符后的新字符串str.insert(2, "ab"); //从 [2] 位置开始添加字符串 "ab"，并返回形成的新字符串str.insert(2, "abcd", 3); //从 [2] 位置开始添加字符串 "abcd" 的前 3 个字符，并返回形成的新字符串str.insert(2, "abcd", 1, 3); //从 [2] 位置开始添加字符串 "abcd" 的前 [2]~[2+(3-1)] 个字符，并返回形成的新字符串str.erase(3); //删除 [3] 及以后的字符，并返回新字符串str.erase(3, 5); //删除从 [3] 开始的 5 个字符，并返回新字符串str1.swap(str2); //把 str1 与 str2 交换transform(str.begin(),str.end(),str.begin(),::tolower); //把字符串全部转换为小写字母transfrom(str.begin(),str.end(),str.begin(),::toupper); //把字符串全部转换为大写字母 声明需要引入头文件&lt; string &gt; ,既然是C++，就还要引入头文件&lt; iostream &gt; 和using namespace std; 123456#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string s;//声明一个string 对象string ss[10];//声明一个string对象的数组 string的io操作使用cin读入字符串时，遇到空白就停止读取。也就是说一句话只能读到空格前面的内容。怎么读入一个句子呢？ 123string str；getline(cin,str);cout&lt;&lt;str&lt;&lt;endl; string的比较（字典顺序）12345678910111213141516string PPAP[] = &#123;"I", "have", "a", "pen", "an", "apple", "um", "apple-pen"&#125;;sort(PPAP, PPAP + 8);for(int i = 0; i &lt; 8; i++)&#123; cout &lt;&lt; PPAP[i] &lt;&lt; endl;&#125;/*输出结果：Iaanappleapple-penhavepenum*/ 遍历字符串在C语言中我都是用下标或者指针来访问数组元素，而在C++里，有个新奇的东西叫做迭代器iterator，我们可以使用它来访问容器元素。 12345678910111213141516171819string str("hello world");for(string::iterator it=str.begin();it!=str.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;endl;&#125;/*输出结果：helloworld*/ 查找子字符串问题string提供了一系列find查找子字符串的函数。最好用的还是find( )函数，返回在字符串中第一次出现的位置，位置变量的定义方式是 string::size_type ,如果没有找到，函数的返回值是string::npos，对应的位置变量是一个很大的常数。 如果用int 定义位置变量，也可以正常使用。如果没有找到，用int定义的位置变量为-1。 1234567891011121314151617#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int main()&#123; string::size_type position;//教程里面都是这样定义变量，但是我试过用int也可以正常使用 //int position; string a,b; cin&gt;&gt;a&gt;&gt;b; position = a.find(b);//在a中查找b cout&lt;&lt;position&lt;&lt;endl; if(a.find(b)==string::npos)//没有找到，返回string::npos cout&lt;&lt;"不存在！"&lt;&lt;endl; return 0;&#125; 还有一个字母转换的函数，把所有的大写字母都转换为小写字母： 1transform(str.begin(),str.end(),str.begin(),::tolower); 把所有字母转换成大写字母： 1transform(s.begin(), s.end(), s.begin(), ::toupper); vectorC++ STL中的verctor好比是C语言中的数组，但是vector又具有数组没有的一些高级功能。与数组相比，vector就是一个可以不用再初始化就必须制定大小的边长数组，当然了，它还有许多高级功能。 要想用vector首先得包含头文件vector。 1#include&lt;vector&gt; 初始化如果vector的元素类型是int，默认初始化为0；如果vector元素类型为string，则默认初始化为空字符串。 1234567vector&lt;int&gt; v1(10, 12); //10个元素，每个元素值都是12vector&lt;int&gt; v2(10); //10个元素，每个元素值都是0vector&lt;int&gt; v3; //0个元素vector&lt;string&gt; v4(10, "hi"); //10个元素，每个元素值都是“hi”vector&lt;string&gt; v5&#123;10, "hi"&#125;; //10个元素，每个元素值都是“hi”vector&lt;string&gt; v6&#123;10&#125;; //10个元素，每个元素值都是“”vector&lt;vector&lt;int&gt; &gt;; //注意空格。这里相当于二维数组int a[n][n]; 添加元素使用push_back加入元素，并且这个元素是被加在数组尾部的。 1234for(int i = 0;i &lt; 20; i++)&#123; v.push_back(i);&#125; 注意：只能对已存在的元素进行赋值或者修改操作，如果是要加入新元素，务必使用push_back。push_back的作用有两个：告诉编译器为新元素开辟空间、将新元素存入新空间里。 比如下面的代码是错误的，但是编译器不会报错，就像是数组越界： 12vector&lt;int&gt; vec;vec[0] = 1; //错误！ 基本操作123456789v.empty(); //v为空返回truev.size(); //v中元素个数v[n]; //返回v中位置为n的元素v1 = v2; //把v1中的元素替换为v2中元素的副本。v.resize(n); //重新调整vector容量大小为nv.push_back(t); //将t插入到v的末尾v.pop_back(t); //删除vector尾部的对象v.erase(); //删除一个或多个元素v.clear(); //删除所有的元素 遍历使用迭代器来访问元素： 12345678910111213vector&lt;string&gt; v6 = &#123; "hi","my","name","is","lee" &#125;;for (vector&lt;string&gt;::iterator iter = v6.begin(); iter != v6.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; endl;&#125;/*输出结果：himynameislee*/ set其实set的大部分操作是与vector类似的，不过set不支持随机访问，必须要使用迭代器去访问。由于set放入一个元素就会调整这个元素的位置，把它放到合适的位置，所以set中只有一个insert插入操作。 set输出的集合中的元素是按字母大小顺序排列的，而且每个值都不重复。如果cin重复值，并不会真正存入。 输出时，必须用迭代器遍历输出每一个元素。 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;int main()&#123; set&lt;string&gt; strset; set&lt;string&gt;::iterator iter; strset.insert("apple"); strset.insert("orange"); strset.insert("grapes"); strset.insert("grapes"); for(iter=strset.begin();iter!=strset.end();iter++) &#123; cout&lt;&lt;*iter&lt;&lt;endl; &#125;&#125; listlist就是链表，list是一个双向链表，双向链表的优点是插入和删除元素都比较快捷，缺点是不能随机访问元素。 1234567891011#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;int main()&#123; list&lt;int&gt; a=&#123;1,2,3,4,3,6,8,2,1&#125;; for(list&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) cout&lt;&lt;*it&lt;&lt;" "; cout&lt;&lt;endl; return 0;&#125; list的排序方式和algorithm的略有不同： 123a.sort();for(list&lt;int&gt;::iterator it=a.begin();it!=a.end();it++) cout&lt;&lt;*it&lt;&lt;endl;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 搭建Spring MVC环境]]></title>
    <url>%2F2018%2F07%2F17%2FIntelliJ-IDEA-%E6%90%AD%E5%BB%BASpring-MVC%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[记录在IntelliJ IDEA中创建Spring MVC的web项目的全过程，与Maven项目的方法不同，这个需要手动导入jar包。 这种普通的方法比Maven的使用要稍微简单一些，但是熟练之后，还是Maven比较方便。 新建项目File –&gt; New –&gt; Project，最上面是填java JDK安装路径的，如果以前使用Idea编辑器，就会自动帮你选上。选择Spring MVC，下面有两个选项可以选，“use library”就是需要选择本地的依赖包，而“download”就是在生成项目的时候就下载Spring MVC的包，如果是初次创建Spring MVC的项目，就选择“download”。 填写项目名称和项目存储的位置： 点击Finsh，项目就创建完成了。 创建好后的项目目录如下图，lib中已经自动导入了java的包和Spring MVC的包： 修改代码文件修改index.jsp文件index.jsp文件就是等会运行时，显示在浏览器中的界面，初始代码如下： 上面一部分是注释，包含项目的基本信息，中间是空的，可以把&lt; title &gt; 中间改为你想要的文字，例如“SpringMVC”，&lt; body &gt;中间的内容就是正文内容，也可以随意添加，例如改为“Hello World!”,最后的代码如下图： 新增一个控制器HelloMVCController.java首先在src目录下新建一个包，我这里把它命名为 com.spring.mvc ： 然后在这个包下，新增一个类，命名为HelloMVCController ： 文件结构如下： 编辑HelloMVCController.java，代码如下： 123456789101112131415package com.spring.mvc;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class HelloMVCController &#123; @RequestMapping(value="/hello",method = RequestMethod.GET) public String printWelcome(ModelMap model) &#123; model.addAttribute("msg", "Spring 3 MVC Hello World"); return "hello"; &#125;&#125; 修改 dispatcher-servlet.xml 文件dispatcher-servlet.xml文件在web/WEB-INF文件夹下，打开替换为一下代码： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt; &lt;!--对应src下的报名，需要自己新建--&gt; &lt;context:component-scan base-package="com.spring.mvc" /&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix"&gt; &lt;!-- 这个配置是配置JSP页面的位置，按照你自己的配置来配 --&gt; &lt;value&gt;/WEB-INF&lt;/value&gt; &lt;/property&gt; &lt;property name="suffix"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 部署项目在上方菜单栏Run-&gt;Edit Configurations ： 点击左上角的”+”号，选择Tomcat Server，(如果没有请选择最下方的33 items more，找到Tomcat Server)，再选择Local，点击 Application server 右边的 Configure，导入Tomcat 目录： 切换到Deployment标签，再点击右边的”+”号，添加一个Artifact. 选择第二个：war exploded，点击OK，这样，该项目就已经部署到了Tomcat中. 点击OK，这时整个Tomcat就配置好了。点击右上角的运行符号： 这时，发现Artifact报错了： 先暂停运行： 修正错误打开 Project Structure： 选择 Artifacts–&gt;Output Layout ，看到右边有两个包，点击右键，选择第一个Put into/WEB-INF/lib，两个包都要这样操作。 完成后，应该是这样的页面： 点击OK，再次运行，就可以成功部署了，浏览器会自动打开并跳转到 localhost:8080，内容就是index.jsp中所写的。 大功告成！]]></content>
      <categories>
        <category>spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
        <tag>java</tag>
        <tag>maven</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA创建Spring MVC的Maven项目]]></title>
    <url>%2F2018%2F07%2F17%2FMVC%E7%9A%84Maven%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[记录在IntelliJ IDEA中创建Spring MVC的Maven项目。 创建Maven Web项目菜单File-&gt;New Project可进入如图界面，首先选择左边栏Maven，再配置JDK的路径(如果之前添加了JDK的话会自动填充，如未添加点击旁边的New将JDK目录导入即可)。勾选”Create from archetype”，然后选中maven-archetype-webapp，点Next，进入如下界面： 点击next，需要输入GroupID，ArtifactID，Version是自带的版本，暂时不用改。 点击next，填写Maven的配置，配置文件和本地仓库都可以不填。 点击next，填写项目名称和项目保存位置，点击Finsh。 maven会在后台生成web项目，这需要等待一定的时间，视网络环境而定。 选择右边红框的Enable-Auto- Import，这样就可以在每次修改pom.xml后，自动的下载并导入jar包。 下图展示了初始的文件结构： 我们可以看到，目录结构并不是严格的maven格式,因为少了java源码文件夹 。 首先在main文件夹下创建一个文件夹，名称为java ： 将java文件夹标识为Source Root，之后文件夹会变成蓝色，就表明设置成功了 ： 再在main文件夹下创建一个文件夹，名称为recources ，将recources 文件夹标识为recources Root，文件图标也会更换： Maven自动导入jar包现在已经创建好了一个Maven项目，但是还需要给Maven添加依赖。 Maven所做的工作就是自动把你需要的jar包下载到本地，然后关联到项目中来。maven的所有jar包都是保存在几个中央仓库里面的，其中一个最常用的是Maven Repository，即，你需要什么jar包，它就会从仓库中拿给你。那么如何告诉maven需要什么jar包呢？我们看看工程目录，能找到一个pom.xml文件（这个文件在刚创建好项目时就已经展现在了大家面前），maven就是靠它来定义需求的，初始时是这样子的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.cici&lt;/groupId&gt; &lt;artifactId&gt;maven_mvc_test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;maven_mvc_test Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;maven_mvc_test&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.20.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 可以看到，这里面已经自动生成了我们之前定义的本项目的groupId等信息，这些信息是该项目的标识，我们不要去改动它们。重点看 &lt; dependencies &gt;标签，翻译过来是”依赖”的意思，也就是说把对每个包的需求都称为一个依赖&lt; depedency &gt;，定义在&lt; dependencies &gt;中。在每个&lt; depedency &gt;中，你需要提供的是所需jar包的groupId、artifactId、version(g,a,v)这三个必要信息(坐标)。比如上面我们看到引入可一个junit包，格式如下： Junit是单元测试包，提供了三个基本信息，第4个scope对其他包来说是非必需的。所有jar包的引入都要满足这个格式。 现在我们需要把Spring MVC的包加入依赖项，怎么查看这些jar包的3个信息呢？这就需要查阅仓库，打开Maven Repository，搜索spring-webmvc，进入如下界面： 点击打开后，可以看到很多版本，选择一个比较新的版本： 很方便，仓库里面已经写好了Maven的依赖代码，直接复制就可以了。 现在，把这段代码复制到pox.xml中的&lt; dependencies &gt;中： 这时，Maven就会自动把对应的jar包移植到本地项目里： 可以发现，虽然我们只写了一个依赖，但是会把与它密切相关的jar包同时导入进来。 自此演示一个简单的maven项目所需的jar包其实已经够了~ SpringMVC框架设置现在进行项目的配置。 web.xml 配置默认代码如下： 1234567&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;/web-app&gt; 现在需要创建一个创建Spring MVC的中央控制器 ，还有一个servlet名为mvc-dispatcher(名称可修改)，用于拦截请求（url-pattern为*.do），并交由Spring MVC的后台控制器来处理。这一项配置是必须的。为了能够处理中文的post请求，再配置一个encodingFilter，以避免post请求中文出现乱码情况，最终web.xml的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;display-name&gt;winner-test Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc-dispatcher.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; mvc-dispatcher.xml配置在resources文件夹下创建mvc-dispatcher.xml ,代码如下： 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置包扫描器 --&gt; &lt;context:component-scan base-package="com.winner.controller"/&gt; &lt;!-- 配置注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; MainController配置在java文件夹下创建一个class，名为MainController，代码如下： 123456789101112import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class MainController &#123; @RequestMapping(value = "/test.do",method = RequestMethod.GET) public String index() &#123; return "index"; &#125;&#125; –@Controller注解：采用注解的方式，可以明确地定义该类为处理请求的Controller类；–@RequestMapping()注解：用于定义一个请求映射，value为请求的url；–return “index”：处理完该请求后返回的逻辑视图。 配置Tomcat来运行项目在上方菜单栏Run-&gt;Edit Configurations ： 点击左上角的”+”号，选择Tomcat Server，(如果没有请选择最下方的33 items more，找到Tomcat Server)，再选择Local，点击 Application server 右边的 Configure，导入Tomcat 目录： 切换到Deployment标签，再点击右边的”+”号，添加一个Artifact. 选择第二个：war exploded，点击OK，这样，该项目就已经部署到了Tomcat中. 点击OK，这时整个Tomcat就配置好了。点击右上角的运行符号： 这时，浏览器会自动打开，输出文字： 这样就算成功完成了最基本的设置。 这段话是写在哪里的呢？在index.jsp里面！ 12345678&lt;html&gt;&lt;body&gt;&lt;h2&gt; Hello World! Hello Spring MVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>spring MVC</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
        <tag>java</tag>
        <tag>maven</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF历届真题]]></title>
    <url>%2F2018%2F07%2F16%2FCCF%E5%8E%86%E5%B1%8A%E7%9C%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[CCF历届真题汇总笔记，持续更新中…… [TOC] 更新于2018.9.20： 9月参加了CCF，得分210分，终于过了200（达到我们学院的毕业要求了 ​ ）不过学习算法的脚步还不能停，所以或许以后还会更新，练习后面的图论题和动态规划的题。加油鸭！ 201312-1出现次数最多的数问题描述 给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。 输入格式 输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。 输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。 输出格式 输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。 样例输入 ​ 6 10 1 10 20 30 20 样例输出 ​ 10 很简单，直接用一个数组a[] 存放所有的数，用数组b[] 存放每个元素出现的次数，b数组的下标就是a[i]的值，然后找出b数组中最大数的下标就可以了。需要注意的是数据范围是1 ≤ n ≤ 1000 ，1 ≤ si ≤ 10000，所以 a数组的范围可以是1000，而 b数组的范围必须是10000！ 代码 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i; int a[1005],b[10005]=&#123;0&#125;; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; b[a[i]]++; &#125; int max=b[0]; int flag=0; for(i=0;i&lt;=10000;i++) &#123; if(b[i]&gt;max) &#123; max=b[i]; flag=i; &#125; &#125; cout&lt;&lt;flag&lt;&lt;endl; return 0;&#125; 201312-2 ISBN号码问题描述 每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔 符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。 识别码的计算方法如下： 首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，…，9，再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码。 编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出是正确的ISBN号码。 输入格式 输入只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。 输出格式 输出一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。 样例输入 ​ 0-670-82162-4 样例输出 ​ Right 样例输入 ​ 0-670-82162-0 样例输出 ​ 0-670-82162-4 定位到每一个数字，进行运算模11进行比较判断。不用纠结循环取数，判断是否是“-”的问题，直接一个数一个数的取，因为数据格式是固定的。运算完后的总和模11之后，要转换为字符型变量，与给定的数字进行比较。 代码 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; string s; cin&gt;&gt;s; int i,j,sum=0; int a[10]; a[0]=s[0]-'0'; a[1]=s[2]-'0'; a[2]=s[3]-'0'; a[3]=s[4]-'0'; a[4]=s[6]-'0'; a[5]=s[7]-'0'; a[6]=s[8]-'0'; a[7]=s[9]-'0'; a[8]=s[10]-'0'; a[9]=s[12]-'0'; for(i=0,j=1;i&lt;9;i++,j++) &#123; sum+=a[i]*j; &#125; sum=sum%11; char c=sum==10?'X':sum+'0'; if(s[12]==c) cout&lt;&lt;"Right"&lt;&lt;endl; else &#123; s[12]=c; cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125; 201312-3 最大的矩形问题描述 在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。 请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。 输入格式 第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。 第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。 输出格式 输出一行，包含一个整数，即给定直方图内的最大矩形的面积。 样例输入 ​ 6 3 1 6 5 2 3 样例输出 ​ 10 一开始感觉是动态规划问题，看了答案之后发现其实就是暴力法，遍历每一条条形，如果它后面出现高度小于它的条形，就找到当前这个条形所能得到的最大矩形面积。然后每次遍历时都检验这个面积是不是最大的面积。 代码 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,j,a[1005],ans=0; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=0;i&lt;n;i++) &#123; int h=a[i]; for(j=i;j&lt;n;j++) &#123; if(a[j]&lt;h) h=a[j]; int s=(j-i+1)*h; if(s&gt;ans) ans=s; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 201403-1 相反数问题描述 ​ 有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数(a 和 -a 为一对相反数)。 输入格式 ​ 第一行包含一个正整数 N。(1 ≤ N ≤ 500)。 ​ 第二行为 N 个用单个空格隔开的非零整数,每个数的绝对值不超过1000,保证这些整数各不相同。 输出格式 ​ 只输出一个整数,即这 N 个数中包含多少对相反数。 样例输入 5 1 2 3 -1 -2 样例输出 2 题目中很重要的一句话是，有 N 个非零且各不相同的整数 ，所以不用考虑有多组相同的相反数，也没有0干扰判断。直接双重循环，如果2个数相加等于0，就计数，最后计数除以2就是相反数的对数。 代码 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,j,sum=0,a[505]; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; if(a[i]+a[j]==0) sum++; &#125; &#125; cout&lt;&lt;sum/2&lt;&lt;endl; return 0;&#125; 201403-2 窗口问题描述 在某图形操作系统中,有 N 个窗口,每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别,在多于一个窗口重叠的区域里,只会显示位于顶层的窗口里的内容。 当你点击屏幕上一个点的时候,你就选择了处于被点击位置的最顶层窗口,并且这个窗口就会被移到所有窗口的最顶层,而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口,则系统会忽略你这次点击。 现在我们希望你写一个程序模拟点击窗口的过程。 输入格式 输入的第一行有两个正整数,即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10) 接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2,表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 &lt; x2,y1 2。 接下来 M 行每行包含两个非负整数 x, y,表示一次鼠标点击的坐标。 题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过 2559 和 1439。 输出格式 输出包括 M 行,每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口,则输出这个窗口的编号(窗口按照输入中的顺序从 1 编号到 N);如果没有,则输出”IGNORED”(不含双引号)。 样例输入 3 40 0 4 41 1 5 52 2 6 61 10 04 40 5 样例输出 211IGNORED 样例说明 第一次点击的位置同时属于第 1 和第 2 个窗口,但是由于第 2 个窗口在上面,它被选择并且被置于顶层。 第二次点击的位置只属于第 1 个窗口,因此该次点击选择了此窗口并将其置于顶层。现在的三个窗口的层次关系与初始状态恰好相反了。 第三次点击的位置同时属于三个窗口的范围,但是由于现在第 1 个窗口处于顶层,它被选择。 最后点击的 (0, 5) 不属于任何窗口。 CCF的第2道题很喜欢出这类型的题目，首先第一个难点就是怎么存每一个窗口的坐标和次序，答案就是用结构体进行存储。第二个难点是查找点击的坐标属于哪个窗口并重新排序。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;struct Windows&#123; int x1; int x2; int y1; int y2; int order;&#125;a[15];int main()&#123; int n,m,i,j,k,x,y; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++) &#123; a[i].order=i; cin&gt;&gt;a[i].x1&gt;&gt;a[i].y1&gt;&gt;a[i].x2&gt;&gt;a[i].y2; &#125; Windows b; for(i=1;i&lt;=m;i++) &#123; cin&gt;&gt;x&gt;&gt;y; for(j=n;j&gt;0;j--) &#123; if(x&gt;=a[j].x1 &amp;&amp; x&lt;=a[j].x2 &amp;&amp; y&gt;=a[j].y1 &amp;&amp; y&lt;=a[j].y2) &#123; b=a[j]; cout&lt;&lt;a[j].order&lt;&lt;endl; for(k=j;k&lt;n;k++) &#123; a[k]=a[k+1]; &#125; a[n]=b; break; &#125; &#125; if(j==0) cout&lt;&lt;"IGNORED"&lt;&lt;endl; &#125; return 0;&#125; 201409-1 相邻数对问题描述 给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。 输入格式 输入的第一行包含一个整数n，表示给定整数的个数。 第二行包含所给定的n个整数。 输出格式 输出一个整数，表示值正好相差1的数对的个数。 样例输入 610 2 6 3 7 8 样例输出 3 样例说明 值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。 评测用例规模与约定 1&lt;=n&lt;=1000，给定的整数为不超过10000的非负整数。 排个序，判断一下上一个数和下一个数是否相差为1即可。 代码 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,sum=0; int a[1005]; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); for(i=0;i&lt;n;i++) &#123; if(a[i]+1==a[i+1]) sum++; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 201409-2 画图问题描述 在一个定义了直角坐标系的纸上，画一个(x1,y1)到(x2,y2)的矩形指将横坐标范围从x1到x2，纵坐标范围从y1到y2之间的区域涂上颜色。 下图给出了一个画了两个矩形的例子。第一个矩形是(1,1) 到(4, 4)，用绿色和紫色表示。第二个矩形是(2, 3)到(6, 5)，用蓝色和紫色表示。图中，一共有15个单位的面积被涂上颜色，其中紫色部分被涂了两次，但在计算面积时只计算一次。在实际的涂色过程中，所有的矩形都涂成统一的颜色，图中显示不同颜色仅为说明方便。 给出所有要画的矩形，请问总共有多少个单位的面积被涂上颜色。 输入格式 输入的第一行包含一个整数n，表示要画的矩形的个数。 接下来n行，每行4个非负整数，分别表示要画的矩形的左下角的横坐标与纵坐标，以及右上角的横坐标与纵坐标。 输出格式 输出一个整数，表示有多少个单位的面积被涂上颜色。 样例输入 21 1 4 42 3 6 5 样例输出 15 评测用例规模与约定 1&lt;=n&lt;=100，0&lt;=横坐标、纵坐标&lt;=100。 这个题目比较简单，不需要用结构体，直接建一个二维数组保存标记，一组一组的读入坐标，再把对应二维数组标记为1就可以了。最后统计标记了多少个格子即可。 代码 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int a[105][105]=&#123;0&#125;;int main()&#123; int n,i,j,k,sum=0; cin&gt;&gt;n; while(n--) &#123; int x1,y1,x2,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; for(i=x1;i&lt;x2;i++) &#123; for(j=y1;j&lt;y2;j++) &#123; a[i][j]=1; &#125; &#125; &#125; for(i=0;i&lt;105;i++) &#123; for(j=0;j&lt;105;j++) &#123; if(a[i][j]==1) sum++; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 用结构体一样的： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int flag[105][105]=&#123;0&#125;;struct&#123; int x1; int y1; int x2; int y2;&#125;a[100];int main()&#123; int n,i,j,k,sum=0; cin&gt;&gt;n; for(k=0;k&lt;n;k++) &#123; cin&gt;&gt;a[k].x1&gt;&gt;a[k].y1&gt;&gt;a[k].x2&gt;&gt;a[k].y2; for(i=a[k].x1;i&lt;a[k].x2;i++) &#123; for(j=a[k].y1;j&lt;a[k].y2;j++) &#123; flag[i][j]=1; &#125; &#125; &#125; for(i=0;i&lt;105;i++) &#123; for(j=0;j&lt;105;j++) &#123; if(flag[i][j]==1) sum++; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 201409-3 字符串匹配问题描述 给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。 输入格式 输入的第一行包含一个字符串S，由大小写英文字母组成。 第二行包含一个数字，表示大小写敏感的选项，当数字为0时表示大小写不敏感，当数字为1时表示大小写敏感。 第三行包含一个整数n，表示给出的文字的行数。 接下来n行，每行包含一个字符串，字符串由大小写英文字母组成，不含空格和其他字符。 输出格式 输出多行，每行包含一个字符串，按出现的顺序依次给出那些包含了字符串S的行。 样例输入 Hello15HelloWorldHiHiHelloHiHiGrepIsAGreatToolHELLOHELLOisNOTHello 样例输出 HelloWorldHiHiHelloHiHiHELLOisNOTHello 样例说明 在上面的样例中，第四个字符串虽然也是Hello，但是大小写不正确。如果将输入的第二行改为0，则第四个字符串应该输出。 评测用例规模与约定 1&lt;=n&lt;=100，每个字符串的长度不超过100。 字符串操作的问题，对于大小写敏感的查找，就使用C++中的string类，find函数，可以查找子字符串；对于大小写不敏感的查找，需要先把所有的字符串转换为小写的，再用find函数进行查找！ string大法好！函数大法好！ 代码 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; string str; cin&gt;&gt;str; int flag,n,i; cin&gt;&gt;flag&gt;&gt;n; if(flag==1) &#123; while(n--) &#123; string s; cin&gt;&gt;s; if(s.find(str)!=string::npos) cout&lt;&lt;s&lt;&lt;endl; &#125; &#125; if(flag==0) &#123; transform(str.begin(), str.end(), str.begin(),::tolower); while(n--) &#123; string s; cin&gt;&gt;s; string p=s; transform(p.begin(), p.end(), p.begin(),::tolower); if(p.find(str)!=string::npos) cout&lt;&lt;s&lt;&lt;endl; &#125; &#125; return 0;&#125; 201412-1 门禁系统问题描述 涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。 输入格式 输入的第一行包含一个整数n，表示涛涛的记录条数。 第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。 输出格式 输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。 样例输入 51 2 1 1 3 样例输出 1 1 2 3 1 评测用例规模与约定 1≤n≤1,000，读者的编号为不超过n的正整数。 用另外一个字符串记录每个数出现的次数，读入一个数，输出计数值一次。 代码 123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i; int a[1005],b[1005]=&#123;0&#125;; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; b[a[i]]++; cout&lt;&lt;b[a[i]]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125; 201412-2 Z字形扫描问题描述 在图像编码的算法中，需要将一个给定的方形矩阵进行Z字形扫描(Zigzag Scan)。给定一个n×n的矩阵，Z字形扫描的过程如下图所示： 对于下面的4×4的矩阵， 1 5 3 9 3 7 5 6 9 4 6 4 7 3 1 3 对其进行Z字形扫描后得到长度为16的序列： 1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3 请实现一个Z字形扫描的程序，给定一个n×n的矩阵，输出对这个矩阵进行Z字形扫描的结果。 输入格式 输入的第一行包含一个整数n，表示矩阵的大小。 输入的第二行到第n+1行每行包含n个正整数，由空格分隔，表示给定的矩阵。 输出格式 输出一行，包含n×n个整数，由空格分隔，表示输入的矩阵经过Z字形扫描后的结果。 样例输入 41 5 3 93 7 5 69 4 6 47 3 1 3 样例输出 1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3 评测用例规模与约定 1≤n≤500，矩阵元素为不超过1000的正整数。 模拟的逻辑不是很复杂，关键是循环条件一开始没想清楚怎么写，后来借鉴了网上的代码。还有一个很坑的地方就是转弯时，要先判断角落，再判断边界。一开始我也没有注意else if 的条件顺序，一直只有60分，后来才发现这个问题。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int a[500][500]; int n,i,j; cin&gt;&gt;n; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) cin&gt;&gt;a[i][j]; int up=1; int down; i=0;j=0; while((i!=n-1) || (j!=n-1)) &#123; while(up) &#123; if(i!=0 &amp;&amp; j!=n-1) &#123;cout&lt;&lt;a[i][j]&lt;&lt;" ";i--;j++;&#125; else if(j==n-1) &#123;cout&lt;&lt;a[i][j]&lt;&lt;" ";i++;down=1;up=0;&#125; else if(i==0) &#123;cout&lt;&lt;a[i][j]&lt;&lt;" ";j++;down=1;up=0;&#125; &#125; while(down) &#123; if(i!=n-1 &amp;&amp; j!=0) &#123;cout&lt;&lt;a[i][j]&lt;&lt;" ";i++;j--;&#125; else if(i==n-1) &#123;cout&lt;&lt;a[i][j]&lt;&lt;" ";j++;up=1;down=0;&#125; else if(j==0) &#123;cout&lt;&lt;a[i][j]&lt;&lt;" ";i++;up=1;down=0;&#125; &#125; &#125; cout&lt;&lt;a[i][j]; return 0;&#125; 201503-1 图像旋转问题描述 旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。 计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。 输入格式 输入的第一行包含两个整数n, m，分别表示图像矩阵的行数和列数。 接下来n行每行包含m个整数，表示输入的图像。 输出格式 输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。 样例输入 2 31 5 33 2 4 样例输出 3 45 21 3 评测用例规模与约定 1 ≤ n, m ≤ 1,000，矩阵中的数都是不超过1000的非负整数。 矩阵的转置，没有什么难度… 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int a[1005][1005];int main()&#123; int n,m,i,j; cin&gt;&gt;m&gt;&gt;n; for(i=0;i&lt;m;i++) &#123; for(j=0;j&lt;n;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(j=n-1;j&gt;=0;j--) &#123; for(i=0;i&lt;m;i++) &#123; cout&lt;&lt;a[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 201503-2 数字排序问题描述 给定n个整数，请统计出每个整数出现的次数，按出现次数从多到少的顺序输出。 输入格式 输入的第一行包含一个整数n，表示给定数字的个数。 第二行包含n个整数，相邻的整数之间用一个空格分隔，表示所给定的整数。 输出格式 输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的次数。按出现次数递减的顺序输出。如果两个整数出现的次数一样多，则先输出值较小的，然后输出值较大的。 样例输入 125 2 3 3 1 3 4 2 5 2 3 5 样例输出 3 42 35 31 14 1 评测用例规模与约定 1 ≤ n ≤ 1000，给出的数都是不超过1000的非负整数。 如果就是记录出现的次数并排序，就十分简单，但是这个要输出对应的元素值，一开始想到用结构体存储，但是好像一排序顺序也打乱了…结果暴力的双重循环，遇到a[i]==j 的就把 j 和a[j]都输出来。 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,num,i,j; int a[1005]=&#123;0&#125;; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;num; a[num]++; &#125; for(i=1004;i&gt;0;i--) &#123; for(j=0;j&lt;1005;j++) &#123; if(a[j]==i) cout&lt;&lt;j&lt;&lt;" "&lt;&lt;a[j]&lt;&lt;endl; &#125; &#125; return 0;&#125; 201503-3 节日问题描述 有一类节日的日期并不是固定的，而是以“a月的第b个星期c”的形式定下来的，比如说母亲节就定为每年的五月的第二个星期日。 现在，给你a，b，c和y1, y2(1850 ≤ y1, y2 ≤ 2050)，希望你输出从公元y1年到公元y2年间的每年的a月的第b个星期c的日期。 提示：关于闰年的规则：年份是400的整数倍时是闰年，否则年份是4的倍数并且不是100的倍数时是闰年，其他年份都不是闰年。例如1900年就不是闰年，而2000年是闰年。 为了方便你推算，已知1850年1月1日是星期二。 输入格式 输入包含恰好一行，有五个整数a, b, c, y1, y2。其中c=1, 2, ……, 6, 7分别表示星期一、二、……、六、日。 输出格式 对于y1和y2之间的每一个年份，包括y1和y2，按照年份从小到大的顺序输出一行。 如果该年的a月第b个星期c确实存在，则以”yyyy/mm/dd”的格式输出，即输出四位数的年份，两位数的月份，两位数的日期，中间用斜杠“/”分隔，位数不足时前补零。 如果该年的a月第b个星期c并不存在，则输出”none”（不包含双引号)。 样例输入 5 2 7 2014 2015 样例输出 2014/05/112015/05/10 评测用例规模与约定 所有评测用例都满足：1 ≤ a ≤ 12，1 ≤ b ≤ 5，1 ≤ c ≤ 7，1850 ≤ y1, y2 ≤ 2050。 CCF就喜欢出这种骚题目，看起来很简单，改来改去就是a不了。刚开始觉得很简单，先计算出a月1号是周几，再计算a月第一个星期c是几号，日期加上（b - 1）*7，就是最终的日期。需要注意几个问题：第一个问题是，如果按照题目中所说从1850年开始推算日子的话，1850年1月1号是周二，不好惯性思维……也可以不管题目，直接从1年1月1日开始计算，1年1月1日是周日！第二个问题是，是打印y1~y2年间的每一个日期，不是只打印y1年和y2年的……题目中的样例正好y1和y2是连着的，我就一直以为只输出这两个年份，害我改了一早上，读题目啊！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int month_day[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;//计算year年month月day日是星期几int weeks(int year,int month,int day)&#123; if(year%400==0 || (year%4==0 &amp;&amp; year%100!=0)) month_day[2]=29; else month_day[2]=28; int sum=0; for(int i=1;i&lt;year;i++) &#123; if(i%400==0 || (i%4==0 &amp;&amp; i%100!=0)) sum+=366; else sum+=365; &#125; for(int j=1;j&lt;month;j++) &#123; sum+=month_day[j]; &#125; sum+=day; int k=sum%7; if(k==0) return 7; if(k==1) return 1; if(k==2) return 2; if(k==3) return 3; if(k==4) return 4; if(k==5) return 5; if(k==6) return 6;&#125;int main()&#123; int a,b,c,y1,y2; int y[3005],first_date[3005],day[3005]; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;y1&gt;&gt;y2; for(int i=y1;i&lt;=y2;i++) &#123; y[i]=i; &#125; for(int i=y1;i&lt;=y2;i++) &#123; //计算y年a月1号是周几 first_date[i]=weeks(y[i],a,1); //计算周c距离a月1日有几天 if(c&lt;first_date[i]) &#123; day[i]=first_date[i]-c; day[i]=7-day[i]+1; &#125; if(c&gt;=first_date[i]) &#123; day[i]=c-first_date[i]+1; &#125; day[i]=day[i]+(b-1)*7; //骚的不行的输出 if(day[i]&gt;month_day[a]) cout&lt;&lt;"none"&lt;&lt;endl; else &#123; cout&lt;&lt;y[i]&lt;&lt;"/"; if(a&lt;10) cout&lt;&lt;"0"&lt;&lt;a&lt;&lt;"/"; else cout&lt;&lt;a&lt;&lt;"/"; if(day[i]&lt;10) cout&lt;&lt;"0"&lt;&lt;day[i]&lt;&lt;endl; else cout&lt;&lt;day[i]&lt;&lt;endl; &#125; &#125; return 0;&#125; 201509-1 数字分段问题描述 给定一个整数数列，数列中连续相同的最长整数序列算成一段，问数列中共有多少段？ 输入格式 输入的第一行包含一个整数n，表示数列中整数的个数。 第二行包含n个整数a1, a2, …, an，表示给定的数列，相邻的整数之间用一个空格分隔。 输出格式 输出一个整数，表示给定的数列有多个段。 样例输入 88 8 8 0 12 12 8 0 样例输出 5 样例说明 8 8 8是第一段，0是第二段，12 12是第三段，倒数第二个整数8是第四段，最后一个0是第五段。 评测用例规模与约定 1 ≤ n ≤ 1000，0 ≤ ai ≤ 1000。 检查目前输入进来的数和上一个数相不相同，不相同就计数加一。我感觉a[0]不赋值并没有关系啊，然而不赋值就90分，赋了值就满分了… 代码 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,sum=0; int a[1005]; a[0]=-1; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; if(a[i]!=a[i-1]) sum++; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 201509-2 日期计算问题描述 给定一个年份y和一个整数d，问这一年的第d天是几月几日？ 注意闰年的2月有29天。满足下面条件之一的是闰年： 1） 年份是4的整数倍，而且不是100的整数倍； 2） 年份是400的整数倍。 输入格式 输入的第一行包含一个整数y，表示年份，年份在1900到2015之间（包含1900和2015）。 输入的第二行包含一个整数d，d在1至365之间。 输出格式 输出两行，每行一个整数，分别表示答案的月份和日期。 样例输入 201580 样例输出 321 样例输入 200040 样例输出 29 不是很难，关键是细心。先把12个月份每个月多少天存在数组里，如果是闰年就把2月改为29天。再一个月一个月的减，直到d小于下个月的天数，就可以输出月份和d了。容易忽视的是：1月根本就不能进入循环，直接输出1月d号！ 代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int year,d,i; int month[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;; cin&gt;&gt;year&gt;&gt;d; if(year%400==0 || (year%4==0 &amp;&amp; year%100!=0)) month[2]=29; if(d&lt;=month[1]) cout&lt;&lt;"1"&lt;&lt;endl&lt;&lt;d&lt;&lt;endl; else &#123; for(i=1;i&lt;=12;i++) &#123; d-=month[i]; if(d&lt;=month[i+1]) break; &#125; cout&lt;&lt;i+1&lt;&lt;endl&lt;&lt;d&lt;&lt;endl; &#125; return 0;&#125; 201512-1 位数之和问题描述 给定一个十进制整数n，输出n的各位数字之和。 输入格式 输入一个整数n。 输出格式 输出一个整数，表示答案。 样例输入 20151220 样例输出 13 样例说明 20151220的各位数字之和为2+0+1+5+1+2+2+0=13。 评测用例规模与约定 所有评测用例满足：0 ≤ n ≤ 1000000000。 最好的方法就是把输入当做一个字符串输入，然后遍历每个字符减去48后累加求和。 代码 123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,sum=0; string a; cin&gt;&gt;a; for(i=0;i&lt;a.size();i++) &#123; int t=a[i]-48; sum+=t; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 201512-2 消除类游戏问题描述 消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。 现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。 请注意：一个棋子可能在某一行和某一列同时被消除。 输入格式 输入的第一行包含两个整数n, m，用空格分隔，分别表示棋盘的行数和列数。 接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。 输出格式 输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。 样例输入 4 52 2 3 1 23 4 5 1 42 3 2 1 32 2 2 4 4 样例输出 2 2 3 0 23 4 5 0 42 3 2 0 30 0 0 4 4 样例说明 棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。 样例输入 4 52 2 3 1 23 1 1 1 12 3 2 1 32 2 3 3 3 样例输出 2 2 3 0 23 0 0 0 02 3 2 0 32 2 0 0 0 样例说明 棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。 评测用例规模与约定 所有的评测用例满足：1 ≤ n, m ≤ 30。 不算很难，一个二维数组a存储数据，另外一个二维数组b改写0，这样就可以先一排一排的检查，再一列一列的检查。感觉有点啰嗦，但是a了就好。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,m,i,j; int a[35][35],b[35][35]; cin&gt;&gt;n&gt;&gt;m; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; cin&gt;&gt;a[i][j]; b[i][j]=a[i][j]; &#125; &#125; for(i=0;i&lt;n;i++) &#123; for(j=1;j&lt;m-1;j++) &#123; if(a[i][j]==a[i][j-1] &amp;&amp; a[i][j]==a[i][j+1]) &#123; b[i][j-1]=0; b[i][j]=0; b[i][j+1]=0; &#125; &#125; &#125; for(i=1;i&lt;n-1;i++) &#123; for(j=0;j&lt;m;j++) &#123; if(a[i][j]==a[i-1][j] &amp;&amp; a[i][j]==a[i+1][j]) &#123; b[i-1][j]=0; b[i][j]=0; b[i+1][j]=0; &#125; &#125; &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; cout&lt;&lt;b[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 201604-1 折点计数问题描述 给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天和第6天是折点。 给定n个整数a1, a2, …, an表示销售量，请计算出这些天总共有多少个折点。 为了减少歧义，我们给定的数据保证：在这n天中相邻两天的销售量总是不同的，即ai-1≠ai。注意，如果两天不相邻，销售量可能相同。 输入格式 输入的第一行包含一个整数n。 第二行包含n个整数，用空格分隔，分别表示a1, a2, …, an。 输出格式 输出一个整数，表示折点出现的数量。 样例输入 75 4 1 2 3 6 4 样例输出 2 评测用例规模与约定 所有评测用例满足：1 ≤ n ≤ 1000，每天的销售量是不超过10000的非负整数。 只要三个连续的数不是连续递增或者递减就计数增加。 代码 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,sum=0; int a[1005]; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=1;i&lt;n-1;i++) &#123; if((a[i]-a[i-1])*(a[i+1]-a[i])&lt;0) sum++; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 201604-2 俄罗斯方块问题描述 俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。 游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。 在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。 具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。 输入格式 输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。 输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。 第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例） 输出格式 输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。 样例输入 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 0 0 0 1 1 1 10 0 0 0 1 0 0 0 0 00 0 0 00 1 1 10 0 0 10 0 0 03 样例输出 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 1 1 1 1 1 1 10 0 0 0 1 1 0 0 0 0 模拟的思想，找到方块能够下降的位置，然后重新赋值后输出。提示好坑人啊，什么左边是不是0的问题，一开始被误导了…底板的边界从1开始计数，而不是0。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int board[20][20]; int block[5][5]; int i,j,k,a,b,pos; for(i=1;i&lt;=15;i++) for(j=1;j&lt;=10;j++) cin&gt;&gt;board[i][j]; for(j=1;j&lt;=10;j++) board[16][j]=1; for(i=0;i&lt;4;i++) for(j=0;j&lt;4;j++) cin&gt;&gt;block[i][j]; cin&gt;&gt;pos; bool over=false; //模拟，找到下降的位置 for(i=1;i&lt;=15;i++) &#123; for(a=0;a&lt;4;a++) &#123; for(b=0;b&lt;4;b++) &#123; if(block[a][b]==1 &amp;&amp; board[i+a][pos+b]==1) over = true; &#125; &#125; if(over==true) break; &#125; //改变值 for(a=0;a&lt;4;a++) for(b=0;b&lt;4;b++) board[i+a-1][pos+b]+=block[a][b]; for(i=1;i&lt;=15;i++) &#123; for(j=1;j&lt;=10;j++) &#123; cout&lt;&lt;board[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 201609-1 最大波动问题描述 小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。 输入格式 输入的第一行包含了一个整数n，表示小明拿到的收盘价格的连续天数。 第二行包含n个正整数，依次表示每天的收盘价格。 输出格式 输出一个整数，表示这只股票这n天中的最大波动值。 样例输入 62 5 5 7 3 5 样例输出 4 样例说明 第四天和第五天之间的波动最大，波动值为|3-7|=4。 评测用例规模与约定 对于所有评测用例，2 ≤ n ≤ 1000。股票每一天的价格为1到10000之间的整数。 送分题== 代码 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i; int a[10005],b[10005]; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=1;i&lt;n;i++) &#123; b[i-1]=abs(a[i]-a[i-1]); //if(b[i-1]&lt;0) b[i-1]=-b[i-1]; &#125; sort(b,b+n); cout&lt;&lt;b[n-1]&lt;&lt;endl; return 0;&#125; 201609-2 火车购票问题描述 请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。 假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。 购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。 假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。 输入格式 输入的第一行包含一个整数n，表示购票指令的数量。 第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。 输出格式 输出n行，每行对应一条指令的处理结果。 对于购票指令p，输出p张车票的编号，按从小到大排序。 样例输入 42 5 4 2 样例输出 1 26 7 8 9 1011 12 13 143 4 样例说明 1) 购2张票，得到座位1、2。 2) 购5张票，得到座位6至10。 3) 购4张票，得到座位11至14。 4) 购2张票，得到座位3、4。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。 我就直接暴力模拟，对1~5这五种情况全部列举一遍，得了90分，有一个问题就是如果前20次都是4个座位，第21次再买4个座位时，应该输出：5 10 15 20，中间是空格而不是换行，所以需要手动输出空格和换行。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int s[101]=&#123;0&#125;;void buy(int op)&#123; int i; if(op==1) &#123; for(i=1;i&lt;=100;i++) &#123; if(s[i]==0) &#123; cout&lt;&lt;i; s[i]=1; break; &#125; &#125; &#125; if(op==2) &#123; int flag=0; for(i=1;i&lt;=99;i++) &#123; if(s[i]==0 &amp;&amp; s[i+1]==0 &amp;&amp; i%5!=0) &#123; flag=1; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i+1&lt;&lt;endl; s[i]=1; s[i+1]=1; break; &#125; &#125; if(flag==0) &#123; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;endl; &#125; &#125; if(op==3) &#123; int flag=0; for(i=1;i&lt;=98;i++) &#123; if(s[i]==0 &amp;&amp; s[i+1]==0 &amp;&amp; s[i+2]==0 &amp;&amp; i%5&lt;=3 &amp;&amp; i%5!=0) &#123; flag=1; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i+1&lt;&lt;" "&lt;&lt;i+2&lt;&lt;endl; s[i]=1; s[i+1]=1; s[i+2]=1; break; &#125; &#125; if(flag==0) &#123; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;endl; &#125; &#125; if(op==4) &#123; int flag=0; for(i=1;i&lt;=97;i++) &#123; if(s[i]==0 &amp;&amp; s[i+1]==0 &amp;&amp; s[i+2]==0 &amp;&amp; s[i+3]==0 &amp;&amp; i%5&lt;=2 &amp;&amp; i%5!=0) &#123; flag=1; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i+1&lt;&lt;" "&lt;&lt;i+2&lt;&lt;" "&lt;&lt;i+3&lt;&lt;endl; s[i]=1; s[i+1]=1; s[i+2]=1; s[i+3]=1; break; &#125; &#125; if(flag==0) &#123; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;endl; &#125; &#125; if(op==5) &#123; int flag=0; for(i=1;i&lt;=96;i++) &#123; if(s[i]==0 &amp;&amp; s[i+1]==0 &amp;&amp; s[i+2]==0 &amp;&amp; s[i+3]==0 &amp;&amp; s[i+4]==0 &amp;&amp; i%5==1) &#123; flag=1; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i+1&lt;&lt;" "&lt;&lt;i+2&lt;&lt;" "&lt;&lt;i+3&lt;&lt;" "&lt;&lt;i+4&lt;&lt;endl; s[i]=1; s[i+1]=1; s[i+2]=1; s[i+3]=1; s[i+4]=1; break; &#125; &#125; if(flag==0) &#123; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;" "; buy(1);cout&lt;&lt;endl; &#125; &#125;&#125;int main()&#123; int n,k,op; cin&gt;&gt;n; for(k=0;k&lt;n;k++) &#123; cin&gt;&gt;op; buy(op); if(op==1) cout&lt;&lt;endl; &#125; return 0;&#125; 201612-1 中间数问题描述 在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。 给定一个整数序列，请找出这个整数序列的中间数的值。 输入格式 输入的第一行包含了一个整数n，表示整数序列中数的个数。 第二行包含n个正整数，依次表示a1, a2, …, an。 输出格式 如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。 样例输入 62 6 5 6 3 5 样例输出 5 样例说明 比5小的数有2个，比5大的数也有2个。 样例输入 43 4 6 7 样例输出 -1 样例说明 在序列中的4个数都不满足中间数的定义。 样例输入 53 4 6 6 7 样例输出 -1 样例说明 在序列中的5个数都不满足中间数的定义。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。 就是遍历每一个数，统计比它大和小的数各有多少个。 代码 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,j,flag=0; int a[1005]; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(i=0;i&lt;n;i++) &#123; int s1=0,s2=0; int t=a[i]; for(j=0;j&lt;n;j++) &#123; if(a[j]&gt;a[i]) s1++; if(a[j]&lt;a[i]) s2++; &#125; if(s1==s2) &#123; flag=1; cout&lt;&lt;a[i]&lt;&lt;endl; break; &#125; &#125; if(flag==0) cout&lt;&lt;"-1"&lt;&lt;endl; return 0;&#125; 201612-2 工资计算问题描述 小明的公司每个月给小明发工资，而小明拿到的工资为交完个人所得税之后的工资。假设他一个月的税前工资（扣除五险一金后、未扣税前的工资）为S元，则他应交的个人所得税按如下公式计算： 1） 个人所得税起征点为3500元，若S不超过3500，则不交税，3500元以上的部分才计算个人所得税，令A=S-3500元； 2） A中不超过1500元的部分，税率3%； 3） A中超过1500元未超过4500元的部分，税率10%； 4） A中超过4500元未超过9000元的部分，税率20%； 5） A中超过9000元未超过35000元的部分，税率25%； 6） A中超过35000元未超过55000元的部分，税率30%； 7） A中超过55000元未超过80000元的部分，税率35%； 8） A中超过80000元的部分，税率45%； 例如，如果小明的税前工资为10000元，则A=10000-3500=6500元，其中不超过1500元部分应缴税1500×3%=45元，超过1500元不超过4500元部分应缴税(4500-1500)×10%=300元，超过4500元部分应缴税(6500-4500)×20%=400元。总共缴税745元，税后所得为9255元。 已知小明这个月税后所得为T元，请问他的税前工资S是多少元。 输入格式 输入的第一行包含一个整数T，表示小明的税后所得。所有评测数据保证小明的税前工资为一个整百的数。 输出格式 输出一个整数S，表示小明的税前工资。 样例输入 9255 样例输出 10000 评测用例规模与约定 对于所有评测用例，1 ≤ T ≤ 100000。 不算很难，关键是细心，反解方程需要思路非常清晰，循环一个个检验比较保险点。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int t,s,a,x; cin&gt;&gt;t; if(t&lt;=3500) &#123; cout&lt;&lt;t&lt;&lt;endl; return 0; &#125; x=0; s=200000; a=s-3500; while(1) &#123; if(a&lt;=1500) x=a*0.03; else if(a&lt;=4500) x=45+(a-1500)*0.1; else if(a&lt;=9000) x=45+300+(a-4500)*0.2; else if(a&lt;=35000) x=45+300+900+(a-9000)*0.25; else if(a&lt;=55000) x=45+300+900+6500+(a-35000)*0.3; else if(a&lt;=80000) x=45+300+900+6500+6000+(a-55000)*0.35; else x=45+300+900+6500+6000+8750+(a-80000)*0.45; if(s==x+t) break; s-=100; a=s-3500; &#125; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125; 201703-1 分蛋糕问题描述 小明今天生日，他有n块蛋糕要分给朋友们吃，这n块蛋糕（编号为1到n）的重量分别为a1, a2, …, an。小明想分给每个朋友至少重量为k的蛋糕。小明的朋友们已经排好队准备领蛋糕，对于每个朋友，小明总是先将自己手中编号最小的蛋糕分给他，当这个朋友所分得蛋糕的重量不到k时，再继续将剩下的蛋糕中编号最小的给他，直到小明的蛋糕分完或者这个朋友分到的蛋糕的总重量大于等于k。 请问当小明的蛋糕分完时，总共有多少个朋友分到了蛋糕。 输入格式 输入的第一行包含了两个整数n, k，意义如上所述。 第二行包含n个正整数，依次表示a1, a2, …, an。 输出格式 输出一个整数，表示有多少个朋友分到了蛋糕。 样例输入 6 92 6 5 6 3 5 样例输出 3 样例说明 第一个朋友分到了前3块蛋糕，第二个朋友分到了第4、5块蛋糕，第三个朋友分到了最后一块蛋糕。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 10000，1 ≤ ai ≤ 1000。 一开始用数组循环，越写越晕，不知道哪里没有考虑到，只有70分，然后改用while循环，一个数一个数的加，大于等于k时就计数。最后再判断一下最后一次的累加值是否为0，不为0就代表最后剩下的蛋糕不够k，但是还可以再分给一个人。 代码 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,k,a,s=0,sum=0; cin&gt;&gt;n&gt;&gt;k; while(n--) &#123; cin&gt;&gt;a; s+=a; if(s&gt;=k) &#123; s=0; sum++; &#125; &#125; if(s!=0) sum++; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 201703-2 学生排队问题描述 体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。 例如，下面给出了一组移动的例子，例子中学生的人数为8人。 0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8； 1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8； 2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7； 3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。 小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？ 请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。 输入格式 输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。 第二行包含一个整数m，表示调整的次数。 接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。 输出格式 输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。 样例输入 833 28 -33 -2 样例输出 1 2 4 3 5 8 6 7 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，所有移动均合法。 不算很难，就是模拟。需要注意的是向前移动的时候，需要从后往前修改数组里的元素。 代码 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,m,i,k,x,y,pos; cin&gt;&gt;n&gt;&gt;m; int a[1005]; for(i=1;i&lt;=n;i++) a[i]=i; for(i=1;i&lt;=m;i++) &#123; cin&gt;&gt;x&gt;&gt;y; for(int k=1;k&lt;=n;k++) &#123; if(a[k]==x) pos=k; &#125; if(y&gt;0)//back &#123; for(int j=pos;j&lt;pos+y;j++) a[j]=a[j+1]; a[pos+y]=x; &#125; if(y&lt;0)//front &#123; for(int j=pos;j&gt;pos+y;j--) a[j]=a[j-1]; a[pos+y]=x; &#125; &#125; for(i=1;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125; 201709-1 打酱油问题描述 小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。 输入格式 输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。 输出格式 输出一个整数，表示小明最多可以得到多少瓶酱油。 样例输入 40 样例输出 5 样例说明 把40元分成30元和10元，分别买3瓶和1瓶，其中3瓶送1瓶，共得到5瓶。 样例输入 80 样例输出 11 样例说明 把80元分成30元和50元，分别买3瓶和5瓶，其中3瓶送1瓶，5瓶送2瓶，共得到11瓶。 优先买5瓶送2瓶的，50块钱；再买3瓶送1瓶的，30块钱；剩下的钱就只能一瓶一瓶的买。 代码 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,s; cin&gt;&gt;n; int k1=n/50; int s1=k1*7; n-=k1*50; int k2=n/30; int s2=k2*4; n-=k2*30; int s3=n/10; s=s1+s2+s3; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125; 201709-2 公共钥匙盒问题描述 有一个学校的老师共用N个教室，按照规定，所有的钥匙都必须放在公共钥匙盒里，老师不能带钥匙回家。每次老师上课前，都从公共钥匙盒里找到自己上课的教室的钥匙去开门，上完课后，再将钥匙放回到钥匙盒中。 钥匙盒一共有N个挂钩，从左到右排成一排，用来挂N个教室的钥匙。一串钥匙没有固定的悬挂位置，但钥匙上有标识，所以老师们不会弄混钥匙。 每次取钥匙的时候，老师们都会找到自己所需要的钥匙将其取走，而不会移动其他钥匙。每次还钥匙的时候，还钥匙的老师会找到最左边的空的挂钩，将钥匙挂在这个挂钩上。如果有多位老师还钥匙，则他们按钥匙编号从小到大的顺序还。如果同一时刻既有老师还钥匙又有老师取钥匙，则老师们会先将钥匙全还回去再取出。 今天开始的时候钥匙是按编号从小到大的顺序放在钥匙盒里的。有K位老师要上课，给出每位老师所需要的钥匙、开始上课的时间和上课的时长，假设下课时间就是还钥匙时间，请问最终钥匙盒里面钥匙的顺序是怎样的？ 输入格式 输入的第一行包含两个整数N, K。 接下来K行，每行三个整数w, s, c，分别表示一位老师要使用的钥匙编号、开始上课的时间和上课的时长。可能有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。 保证输入数据满足输入格式，你不用检查数据合法性。 输出格式 输出一行，包含N个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。 样例输入 5 24 3 32 2 7 样例输出 1 4 3 2 5 样例说明 第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使用钥匙，使用7单位时间，所以在时刻9还钥匙。 每个关键时刻后的钥匙状态如下（X表示空）： 时刻2后为1X345； 时刻3后为1X3X5； 时刻6后为143X5； 时刻9后为14325。 样例输入 5 71 1 143 3 121 15 122 7 203 18 124 21 195 30 9 样例输出 1 2 3 5 4 评测用例规模与约定 对于30%的评测用例，1 ≤ N, K ≤ 10, 1 ≤ w ≤ N, 1 ≤ s, c ≤ 30； 对于60%的评测用例，1 ≤ N, K ≤ 50，1 ≤ w ≤ N，1 ≤ s ≤ 300，1 ≤ c ≤ 50； 对于所有评测用例，1 ≤ N, K ≤ 1000，1 ≤ w ≤ N，1 ≤ s ≤ 10000，1 ≤ c ≤ 100。 这一次的CCF，我报名参加了，然而这一题完全没有做出来……用结构体的排序就系统报错，思路也不清晰。（这题最为第二题确实难了点……）这次做也废了很大功夫才拿到满分，用的结构体 + vector，关于结构体排序的问题又反复弄了半天，一开始单独定义了一个函数，但是只有30分，把排序函数写在struct的定义里面就是满分了，到现在也不知道为什么！ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stdio.h&gt;using namespace std;struct action&#123; int keyid; int time; int type; //0:put,1:get bool operator&lt;(const action &amp;other) const &#123; if(time&lt;other.time) return true; else if(time==other.time &amp;&amp; type&lt;other.type) return true; else if(time==other.time &amp;&amp; type==other.type &amp;&amp; keyid&lt;other.keyid) return true; return false; &#125;&#125;;int main()&#123; int N,K,w,s,c; cin&gt;&gt;N&gt;&gt;K; vector&lt;action&gt; actions; vector&lt;int&gt; states(N+1); for(int n=1;n&lt;=N;n++) states[n]=n; for(int k=0;k&lt;K;k++) &#123; action p1,p2; cin&gt;&gt;w&gt;&gt;s&gt;&gt;c; p1.keyid=w;p1.time=s;p1.type=1; actions.push_back(p1); p2.keyid=w;p2.time=s+c;p2.type=0; actions.push_back(p2); &#125; sort(actions.begin(),actions.end()); for(int i=0;i&lt;actions.size();i++) &#123; action temp=actions[i]; if(temp.type==0)//put &#123; for(int n=1;n&lt;=N;n++) &#123; if(states[n]==-1) &#123; states[n]=temp.keyid; break; &#125; &#125; &#125; else//get &#123; for(int n=1;n&lt;=N;n++) &#123; if(states[n]==temp.keyid) &#123; states[n]=-1; break; &#125; &#125; &#125; &#125; for(int n=1;n&lt;=N;n++) cout&lt;&lt;states[n]&lt;&lt;" "; return 0;&#125; 201712-1 最小差值问题描述 给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。 输入格式 输入第一行包含一个整数n。 第二行包含n个正整数，相邻整数之间使用一个空格分隔。 输出格式 输出一个整数，表示答案。 样例输入 51 5 4 8 20 样例输出 1 样例说明 相差最小的两个数是5和4，它们之间的差值是1。 样例输入 59 3 6 1 3 样例输出 0 样例说明 有两个相同的数3，它们之间的差值是0. 数据规模和约定 对于所有评测用例，2 ≤ n ≤ 1000，每个给定的整数都是不超过10000的正整数。 先排序，再遍历逐个比较差值。注意差值不能为负数，所以做减法时加绝对值比较保险（不加也可以，因为排过序了） 代码 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,i,ans=10000; int a[1005]; cin&gt;&gt;n; for(i=0;i&lt;n;i++) cin&gt;&gt;a[i]; sort(a,a+n); for(i=1;i&lt;n;i++) &#123; if(abs(a[i]-a[i-1])&lt;ans) ans=abs(a[i]-a[i-1]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 201712-2 游戏问题描述 有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。 游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。 例如，当n=5, k=2时： 1号小朋友报数1； 2号小朋友报数2淘汰； 3号小朋友报数3； 4号小朋友报数4淘汰； 5号小朋友报数5； 1号小朋友报数6淘汰； 3号小朋友报数7； 5号小朋友报数8淘汰； 3号小朋友获胜。 给定n和k，请问最后获胜的小朋友编号为多少？ 输入格式 输入一行，包括两个整数n和k，意义如题目所述。 输出格式 输出一行，包含一个整数，表示获胜的小朋友编号。 样例输入 5 2 样例输出 3 样例输入 7 3 样例输出 4 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。 仔细读题目！不是约瑟夫环问题！报数要一直一直递增下去…模拟的思路。另外要注意n=1时，无论k为何值都应该是输出1。 代码 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,k,count=0,index=0,step=1; cin&gt;&gt;n&gt;&gt;k; int a[1005]=&#123;0&#125;; while(n&gt;count) &#123; if(a[index]==0) &#123; if((step%k==0)||(step%10==k)) &#123; if(count==n-1) &#123; cout&lt;&lt;index+1&lt;&lt;endl; break; &#125; a[index]=1; count++; &#125; step++; &#125; index++; index%=n; &#125; return 0;&#125; 201803-1 跳一跳问题描述 近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。 简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。 如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8…）。 现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。 输入格式 输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。 输出格式 输出一个整数，为本局游戏的得分（在本题的规则下）。 样例输入 1 1 2 2 2 1 1 2 2 0 样例输出 22 数据规模和约定 对于所有评测用例，输入的数字不超过30个，保证0正好出现一次且为最后一个数字。 就是统计2连续出现的次数。 代码 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int x,num=0,sum=0; while(cin&gt;&gt;x &amp;&amp; x!=0) &#123; if(x==1) &#123; sum+=1; num=0; &#125; if(x==2) &#123; num++; sum+=2*num; &#125; &#125; cout&lt;&lt;sum; return 0;&#125; 201803-2 碰撞的小球问题描述 数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。 当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。 当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。 现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。 提示 因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。 同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。 输入格式 输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。 第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。 输出格式 输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。 样例输入 3 10 54 6 8 样例输出 7 9 9 样例说明 初始时，三个小球的位置分别为4, 6, 8。 一秒后，三个小球的位置分别为5, 7, 9。 两秒后，第三个小球碰到墙壁，速度反向，三个小球位置分别为6, 8, 10。 三秒后，第二个小球与第三个小球在位置9发生碰撞，速度反向（注意碰撞位置不一定为偶数），三个小球位置分别为7, 9, 9。 四秒后，第一个小球与第二个小球在位置8发生碰撞，速度反向，第三个小球碰到墙壁，速度反向，三个小球位置分别为8, 8, 10。 五秒后，三个小球的位置分别为7, 9, 9。 样例输入 10 22 3014 12 16 6 10 2 8 20 18 4 样例输出 6 6 8 2 4 0 4 12 10 2 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 &lt; ai &lt; L。L为偶数。 保证所有小球的初始位置互不相同且均为偶数。 一开始想的太简单，以为给出的初始状态全部是排好序的，然后两个数组，一个表述位置，一个表示方向，碰撞检测就是检测pos[ i ] 和 pos[ i+1 ]，结果发现太天真，这样交上去是0分。如果先把pos排序，输出的结果也是被拍了序的（因为下标改变了），纠结了半天不知道怎么排序之后记录下标……后来看了网上的代码，原来可以用双重循环进行碰撞检测……关键是要定义一个是否碰撞的数组，如果已经检测到了碰撞，就把对应的小球标记为检测过。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,L,t,i,j,k; int pos[1005],dir[1005]; cin&gt;&gt;n&gt;&gt;L&gt;&gt;t; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;pos[i]; dir[i]=1; &#125; for(int time=0;time&lt;t;time++) &#123; for(i=0;i&lt;n;i++) &#123; pos[i]+=dir[i]; if(pos[i]==L || pos[i]==0) dir[i]=-dir[i]; &#125; int ischeck[1005]=&#123;0&#125;; for(i=0;i&lt;n;i++) &#123; if(ischeck[i]==0) &#123; for(j=0;j&lt;n;j++) &#123; if(pos[i]==pos[j] &amp;&amp; i!=j) &#123; dir[i]=-dir[i]; dir[j]=-dir[j]; ischeck[i]=1; ischeck[j]=1; &#125; &#125; &#125; &#125; &#125; for(i=0;i&lt;n;i++) cout&lt;&lt;pos[i]&lt;&lt;" "; return 0;&#125;]]></content>
      <categories>
        <category>CCF</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解算法》学习笔记9]]></title>
    <url>%2F2018%2F06%2F11%2F%E3%80%8A%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%2F</url>
    <content type="text"><![CDATA[第九章的学习笔记 第九章 动态规划背包问题经典的背包问题： 假设你是一个小偷，背着一个可以装4磅东西的背包。你可以盗取的物品有以下3样： 音响 3000美元 4磅 笔记本电脑 2000美元 3磅 吉他 1500美元 1磅 为了让盗窃的商品价值最高，应该怎么选择商品？ 解题过程每一个动态规划问题都是从一个网格开始，背包问题的网格如下： 网格的各行为商品，各列为不同容量（1~4磅）的背包。所有这些列都需要，因为他们帮助你计算子背包的价值。网格最初是空的，你将填充其中的每一个单元格，网格填满后，就可以得出答案。 现在开始填表： 吉他行 这一行中，你能够拿的物品只有吉他。当背包容量为1时就可以拿吉他，因为吉他的重量就是1，这时最大价值为1500，接下来当背包容量为2，3，4时，依然只能拿吉他，所以第一行全部都是1500。 音响行 现在可以选择的物品有吉他和音响。当容量为1，2，3时，只能拿吉他，价值为1500；当容量为4时，可以拿音响，音响比吉他值钱，所以拿音响，价值为3000。 这时容量为4的背包最大价值更新为3000。 笔记本电脑行 现在可以选择的物品有吉他、音响、笔记本电脑。当容量为1，2时，只能拿吉他，价值1500；当容量为3时，可以拿笔记本电脑，更新价值为2000；当容量为4时，可以拿（容量为3时的最大值 + 余下的1磅物品）或者之前选择的音响。发现笔记本电脑+吉他更之前，更新价值为4500。 现在表填完了，最后一行的最后一列代表所有物品都可以选且容量为背包最大容量时能获得的最大价值，即为答案。 动态规划算法在刚刚填表的过程中，其实是有一套规则的：$$cell\ [\ i\ ][\ j\ ]=\begin{cases} 上一个单元格的值（即cell\ [\ i-1\ ][\ j-1\ ]的值）\\当前商品的价值 + 剩余空间的价值（cell\ [\ i-1\ ][\ j- 当前商品的重量\ ]）\end{cases}$$背包问题FAQ Q：再增加一个物品呢？ A：直接再加一行即可，表格中前面的值不变，只用填新加的这一行就可以了，依然遵循刚才的填表原则。 Q：行的排列顺序发生变化会如何？ A：无论行是什么顺序，都不影响最终结果。 Q：可以逐列而不是逐行填表吗？ A：背包问题可以，有些动态规划问题不行。 Q：增加一件更小的物品怎么办？ A：例如增加一个0.5磅的物品，子背包应该变为0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4。 Q：可以偷商品的一部分吗？ A：不行，动态规划不能解决只拿一部分的问题。需要用贪心算法每次选择价值最高的物品。 Q：最优解可能出现没装满的情况吗？ A：很有可能。 最长公共子串&amp;子序列最长公共子串最长公共子串问题描述：假如用户输入一个单词，但是拼错了，你的字典里根本没有这个单词，但是有几个类似的单词，怎么判断另一个单词和他输入的单词的有多少字母相同呢？ 例如他输入hish，而你想计算fish和它的相似度。 填表： H I S H F 0 0 0 0 I 0 1 0 0 S 0 0 2 0 H 1 0 0 3 表格中最大的数为3，所以两个单词的最长公共子串的长度为3。 怎么填表的呢？ 如果两个字母不相同，则为0 如果两个字母相同，则为左上角邻居的值+1 最长公共子序列 F O S H F 1 1 1 1 I 1 1 1 1 S 1 1 2 2 H 1 1 2 3 填表依据： 如果两个字母不同，就选择上方和左方邻居中较大的那个 如果两个字母相同，就是左方单元格的值+1 代码实现1234567891011121314151617181920212223242526272829import string,randomdef lcs_dp(input_x, input_y): # 建立一个dp二维数组 # input_y as column, input_x as row dp = [([0] * (len(input_y) + 1)) for i in range(len(input_x) + 1)] for i in range(1, len(input_x) + 1): for j in range(1, len(input_y) + 1): if i == 0 or j == 0: # 在边界上，自行+1 dp[i][j] = 1 elif input_x[i - 1] == input_y[j - 1]: # 不在边界上，相等就加一 dp[i][j] = dp[i - 1][j - 1] + 1 else: # 不相等 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[-1][-1]def random_str(randomlength): str = "" for i in range(randomlength): str += random.choice(list(string.ascii_letters)) return strif __name__ == "__main__": str1 = random_str(10000) str2 = random_str(10000) print("字符串1:", str1) print("字符串2:", str2) print("最长子序列的长度：", lcs_dp(str1, str2)) 小结动态规划可以解决的常见实际问题： 生物学家根据最长公共子序列来确定DNA链的相似性，进而判断两种动物或疾病有多相似。 代码查重/论文查重也是查找最长公共子序列的问题。 计算编辑距离的问题，拼写检查、判断盗版都是用动态规划解决的。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解算法》学习笔记8]]></title>
    <url>%2F2018%2F06%2F10%2F%E3%80%8A%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08%2F</url>
    <content type="text"><![CDATA[第八章的学习笔记 第八章 贪婪算法教室调度问题假设有一张课表，你希望将尽可能多的课程安排在某间教室上。但是又本可能所有课都在这一间教室上，因为有些课的上课时间有冲突。 美术 9：00AM 10:00AM 英语 9：30AM 10：30AM 数学 10：00AM 11：00AM 计算机 10：30AM 11：30AM 音乐 11：00AM 12：00AM 具体做法是： 1.选出结束最早的课，它就是要在这间教室上的第一堂课。 2.接下来，必须选择第一堂课结束后才开始的课。同样，你选择结束最早的课，这将是要在这间教室上的第二堂课。 重复这样做就能找到答案。 贪婪算法很简单：每一步都采取最优的做法。用专业术语说，每步都选择局部最优解，最终得到的就是全局最优解。 集合覆盖问题假设需要让全美50个州都收到广播节目，不同的广播公司向不同的州广播，怎么选择最少的广播公司呢？ 这就需要列举出所有可能的集合，在这个集合中选择覆盖全美50个州的最小集合。 这样的穷举需要耗费大量的时间，效率极低。为了解决这种问题，可以采用近似算法，使用贪婪算法可以得到非常接近的解，而时间可以大大缩短。 12345678910111213141516171819202122states_needed = &#123;"mt", "wa", "or", "id", "nv", "ut", "ca", "az"&#125;stations = &#123;"kone": &#123;"id", "nv", "ut"&#125;, "ktwo": &#123;"wa", "id", "mt"&#125;, "kthree": &#123;"or", "nv", "ca"&#125;, "kfour": &#123;"nv", "ut"&#125;, "kfive": &#123;"ca", "az"&#125;&#125;final_stations = set()while states_needed: best_station = None states_covered = set() for station, states in stations.items(): covered = states_needed &amp; states if len(covered) &gt; len(states_covered): best_station = station states_covered = covered states_needed -= states_covered final_stations.add(best_station)print(final_stations) 小结 旅行商问题和集合覆盖问题有一个共同之处：需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。 元素较少时算法的运算速度非常快，但是随着元素数量的增加，速度会变得非常慢。 涉及“所有组合”的问题通常是NP完全问题。 不能将问题分成小问题，必须考虑各种情况的可能情况。这可能是NP完全问题。 贪婪算法寻找局部最优解，企图用这种方式获得全局最优解，贪婪算法易于实现、运算速度快，是不错的近似算法。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解算法》学习笔记7]]></title>
    <url>%2F2018%2F06%2F04%2F%E3%80%8A%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07%2F</url>
    <content type="text"><![CDATA[第七章的学习笔记 第七章 Dijkstra算法算法概述Dijkstra算法解决的是：在加权图中，一个点（源点）到其余各个顶点的最短路径问题，也叫做“单源最短路径”。例如下图所示的一个加权图中，从1到6有很多条路径，每一段的长度都不同，用Dijkstra算法可以选择一条长度最短的路径。 注意该算法要求图中不存在负权边。 核心思路若对于顶点 s 存在能直接到达的边（s,m），则把d[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径。当算法结束时，d[v] 中存储的便是从 s 到 v的最短路径，或者如果路径不存在的话是无穷大。 边的拓展是Dijkstra 算法的基础操作：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到尾部来拓展一条从 s 到 v 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比目前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直运行到所有的 d[v] 都代表从 s 到 v 的最短路径的长度值。此算法的组织令 d[u] 达到其最终值时，每条边（u, v）都只被拓展一次。 算法维护两个顶点集合 S 和 Q。集合 S 保留所有已知最小 d[v] 值的顶点 v ，而集合 Q 则保留其他所有顶点。集合S初始状态为空，而后每一步都有一个顶点从 Q 移动到 S。这个被选择的顶点是 Q 中拥有最小的 d[u] 值的顶点。当一个顶点 u 从 Q 中转移到了 S 中，算法对 u 的每条外接边 (u, v) 进行拓展。 换钢琴的实例这是交换物品的一张图，乐谱是起点（已经有的东西），现在需要花最少的钱来还到钢琴。 第一步：从起点（乐谱）出发，找到最便宜的节点。 这里只有两个节点，一个是唱片（权值为5），一个是海报（权值为0），所以选择海报这个节点。 第二步：计算前往该节点（海报）的各个邻居的开销。 用一个表来记录： 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 海报 吉他 30 海报 架子鼓 35 — 钢琴 &infin; 第三步：再次执行第一步。下一个最便宜的节点为唱片。 第四部：再次执行第二步。计算前往该节点（唱片）的各个邻居的开销。 用一个表来记录： 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 唱片 吉他 20 唱片 架子鼓 25 — 钢琴 &infin; 第五步：更新开销。 发现通过唱片到吉他和通过唱片到架子鼓的开销更小。所以将架子鼓和吉他的父节点更新为唱片。 第六步：重复第一步。现在起点变成了唱片。下一个最便宜的节点是吉他。 第七步：重复第二步。计算前往该节点（吉他）的各个邻居的开销。 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 唱片 吉他 20 唱片 架子鼓 25 吉他 钢琴 40 第八步：重复第一步。起点是唱片，除了吉他，下一个最便宜的节点是架子鼓。 第九步：重复第二步。计算前往该节点（架子鼓）的各个邻居的开销。 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 唱片 吉他 20 唱片 架子鼓 25 架子鼓 钢琴 35 第十步：更新开销。 通过架子鼓到钢琴更便宜，所以钢琴的父节点更新为架子鼓。 至此，就找到了从乐谱到各个节点的最便宜的方案，例如要还到钢琴，就需要35元。怎么确定路径呢？根据父节点向前推导就可以知道这条路径了。 代码实现题目如下图为例： 定义散列表一共需要三个散列表，一个是定义图，节点之间权值的散列表，一个是costs，一个是parents，也就是前文例子中的表格后两列。 1234567891011121314151617181920212223# 先定义一个散列表，起点分别是start，a，b，fingraph = &#123;"start": &#123;&#125;, "a": &#123;&#125;, "b": &#123;&#125;, "fin": &#123;&#125;&#125;graph["start"]["a"] = 4graph["start"]["b"] = 2graph["a"]["fin"] = 1graph["b"]["a"] = 3graph["b"]["fin"] = 5infinity = float("inf")# 定义开销的散列表costs = &#123;&#125;costs["a"] = 6costs["b"] = 2costs["fin"] = infinity# 定义父节点的散列表parents = &#123;&#125;parents["a"] = "start"parents["b"] = "start"parents["fin"] = None 最小costs函数123456789def find_lowest_cost_node(costs): lowest_cost = float("inf") lowest_cost_node = None for node in costs: cost = costs[node] if cost &lt; lowest_cost and node not in processed: lowest_cost = cost lowest_cost_node = node return lowest_cost_node 主函数123456789101112node = find_lowest_cost_node(costs)while node is not None: cost = costs[node] neighbors = graph[node] for n in neighbors.keys(): new_cost = cost + neighbors[n] if costs[n] &gt; new_cost: costs[n] = new_cost parents[n] = node processed.append(node) node = find_lowest_cost_node(costs) print(node)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记6]]></title>
    <url>%2F2018%2F06%2F02%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%2F</url>
    <content type="text"><![CDATA[第六章的学习笔记 第六章 广度优先搜索BFS的核心思想：层层递进首先以一个未被访问过的顶点作为起始顶点，访问其所有相邻的顶点，然后对每个相邻的顶点再访问它们相邻的未被访问过的顶点，直到所有顶点都被访问过，遍历结束。 BFS搜索是一种用于图的查找，可以帮助回答两类问题： 从节点A出发，有前往节点B的路径吗？ 从节点A出发，前往节点B的哪条路径最短？ 芒果经销商的例子 假设你经营着一个芒果农场，需要寻找芒果经销商，为此，你在朋友列表中查找 这种查找很简单，创建一个朋友名单，并依次遍历每一个朋友看她是不是芒果经销商 假设没有，这时就要在朋友的朋友中查找 这时对于每一个朋友，再将他们的朋友加入到列表中 再次遍历列表，看朋友的朋友是不是芒果经销商 如果依然没有，就把第三层关系人物加入到列表，在重复遍历查找的操作。 广度优先搜索就是先查找一度关系，再查找二度关系、再查找三度关系，以此类推。在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，一层一层的向外查找。 注意，必须按照添加顺序查找时，才能实现这样的目的。如果不按照层次顺序查找，就无法找到最短路径。想要按照添加顺序进行检查，就需要使用一种数据结构，那就是队列（queue）。 队列队列是一种先进先出（First In First Out,FIFO）的数据结构，而栈是一种后进先出（Last In First Out,LIFO）的数据结构。 队列的工作原理与生活中的队列完全相同，不能随机访问队列中的元素，队列只支持两种操作：入队和出队。 实现算法 首先，创建一个队列。在python中，可以用deque来创建一个双端队列。 12345678910111213141516171819202122232425262728293031323334353637from collections import deque# 可以用散列表来生成图graph = &#123;&#125;graph['you'] = ['alice', 'bob', 'claire']graph['bob'] = ['anuj', 'peggy']graph['alice'] = ['peggy']graph['claire'] = ['thom', 'jonny']graph['anuj'] = []graph['peggy'] = []graph['thom'] = []graph['jonny'] = []def person_is_seller(name): # 自定义以m结尾的名字就是芒果经销商 return name[-1] == 'm'def search(name): search_queue = deque() search_queue += graph[name] searched = [] while search_queue: person = search_queue.popleft() # 取出第一个人 if person not in searched: if person_is_seller(person): print(person + " is a mango seller!") return True else: search_queue += graph[person] searched.append(person) return Falseif __name__ == '__main__': search('you') 小结 广度优先搜索指出是否有从A到B的路径。 如果有，广度优先搜索将找出最短路径。 有向图中的边为箭头，箭头方向指定了关系的方向。 无向图中的边不带箭头，其中的关系是双向的。 队列是先进先出（FIFO）的。 栈是后进先出（LIFO）的。 广度优先搜索需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。 对于检查过的人，务必不要再检查，否则会导致无限循环。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记5]]></title>
    <url>%2F2018%2F05%2F31%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%2F</url>
    <content type="text"><![CDATA[第五章的学习笔记 第五章 散列表散列表散列表（Hash table），也叫哈希表，是根据键（key）而直接访问在内存存储位置的数据结构，也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。 一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 X 到首字母 F(X) 的一个函数关系，在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则 F( )，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。 散列函数散列函数（英文：Hash function）又称哈希函数。 散列函数总是将同样的输入映射到相同的索引。 散列函数只带数组有多大，只返回有效的索引。 Python提供的散列表实现为字典，可以使用函数 dict 来创建散列表。 哈希查找1234567891011121314151617181920212223242526272829303132333435363738class HashTable: def __init__(self, size): self.elem = [None for i in range(size)] # 使用list数据结构作为哈希表元素保存方法 self.count = size # 最大表长 def hash(self, key): return key % self.count # 散列函数采用除留余数法 def insert_hash(self, key): """插入关键字到哈希表内""" address = self.hash(key) # 求散列地址 while self.elem[address]: # 当前位置已经有数据了，发生冲突。 address = (address+1) % self.count # 线性探测下一地址是否可用 self.elem[address] = key # 没有冲突则直接保存。 def search_hash(self, key): """查找关键字，返回布尔值""" star = address = self.hash(key) while self.elem[address] != key: address = (address + 1) % self.count if not self.elem[address] or address == star: # 说明没找到或者循环到了开始的位置 return False return True if __name__ == '__main__': list_a = [12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34] hash_table = HashTable(12) for i in list_a: hash_table.insert_hash(i) for i in hash_table.elem: if i: print((i, hash_table.elem.index(i)), end=" ") print("n") print(hash_table.search_hash(15)) print(hash_table.search_hash(33)) 小结 散链表常用于查找、防止重复。缓存。 散链表适用于映射关系、防止重复、缓存/记住数据。 冲突很糟糕，应该使用可以最大限度减小冲突的散列函数。 散列表的查找、插入、删除操作速度都非常快。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记4]]></title>
    <url>%2F2018%2F05%2F30%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[第四章的学习笔记 第四章 快速排序分治法——分而治之总述 分而治之（divide and conquer,D&amp;C）是一种著名的递归式问题解决方法。分治法提供了一种解决问题的思路，是另一种可供你使用的工具。分治法的核心思想就是用一种对解决某个问题通用而且尽可能简单的方法，不断缩小问题的规模，知道求解出问题为止。 步骤 找出基线条件，这种条件必须尽可能简单 不断将问题分解（缩小规模），直到符合基线条件。 分治法：划分方块问题题目要求 现在有一个矩形，边长为1680 * 640，需要将这个矩形均匀地分成方块，且分出的方块要尽可能大。 思路 找基线条件：当一条边长是另一条边长的整数倍时，就可以尽可能大的划分成方块。 分解问题： 首先找到这个矩形能容纳的最大方块：因为宽度是640，所以可以划分的最大方块的边长为640*640，一共可以划分出两个这样的方块。 剩下的矩形边长为640*400。 再对剩下的矩形进行相同的操作，找出这个矩形能容纳的最大方块：400*400。 剩下的矩形变成了400*240。 再对这个矩形进行同样的操作，找出最大能容纳的方块：240*240。 剩下的矩形变成了240*120。这时这个矩形可以划分成两个小方形（满足基线条件：一条边长是另一条边长的整数倍）结束。 最后，对于最初的那个矩形，适用的最大方块为80*80。 这里用到了一个原理：适用于这小块地的最大方块，也是适用于整块地的最大方块。这个原理来源于欧几里得算法。 分治法：求数组元素之和题目要求 给出一个数组，数组中有一串数组，现在需要求这数组中数字元素之和。 最简单的方法就是直接循环求和： 12345def sum(arr): total = 0 for x in arr: total += x return total 但是怎么用递归函数来实现呢？这就需要不断的把问题规模缩小。 例如给出一个数组：[2,4,6],求和： 第一步：找出基线条件：$$\begin{cases}空集不包含任何元素 ,&amp; \text{总和为0} \\ 只包含一个元素, &amp; \text {总和为该元素本身}\end{cases}$$第二步：缩小规模： 1234def dc_sum(arr): if arr == []: return 0 return arr[0] + dc_sum(arr[1:]) 分治法：快速排序快速排序的思想是：先选择一个元素值做为基准值，然后将数组中所有小于基准数的数放在这个数的左边，大于这个数的元素都放在右边。再在这两个子数组中做这种操作，各选择一个基准数，然后小的放一边，大的放一边……直到子数组为空或者只有一个元素（这两种情况下的子数组一定是有序的）。 12345678def quick_sort(arr): if len(arr) &lt; 2: return arr else: pivot = arr[0] #这里直接把第一个元素当做基准值 less = [i for i in arr[1:] if i &lt;= pivot] more = [i for i in arr[1:] if i &gt; pivot] return quick_sort(less) + [pivot] + quick_sort(more) 总结 分治法将问题逐步分解，划分成n个子问题。使用分治法处理列表时，基线条件很可能是空数组或者只包含一个元素。 实现快速排序时，基准值可以随机选择。 快速排序的平均运行时间为O(n logn)。 虽然快速排序和归并排序的时间效率都是O(n logn)，但是快速排序往往比归并排序要快很多。这是因为大O表示法中的常量事关重大。 快速查找比简单查找和二分查找的效率高很多。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验四]]></title>
    <url>%2F2018%2F05%2F27%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验四 作业调度方案我们现在要利用m台机器加工n个工件，每个工件都有m道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。 每个工件的每个工序称为一个操作，我们用记号j-k表示一个操作，其中j为1到n中的某个数字，为工件号；k为1到m中的某个数字，为工序号，例如2-4表示第2个工件第4道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。 例如，当n=3，m=2时，“1-1，1-2，2-1，3-1，3-2，2-2”就是一个给定的安排顺序，即先安排第1个工件的第1个工序，再安排第1个工件的第2个工序，然后再安排第2个工件的第1个工序，等等。 一方面，每个操作的安排都要满足以下的两个约束条件。 (1) 对同一个工件，每道工序必须在它前面的工序完成后才能开始； (2) 同一时刻每一台机器至多只能加工一个工件。 另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。 由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为“1 1 2 3 3 2”。 还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。 例如，取n=3,m=2，已知数据如下： 工件号 机器号/加工时间 工序 11 工序 22 11 , 1/31/3 , 2/22/2 22 , 1/21/2 , 2/52/5 33 , 2/22/2 , 1/41/4 则对于安排顺序“1 1 2 3 3 2”，下图中的两个实施方案都是正确的。但所需要的总时间分别是10与12。 当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件（1）（2）的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件（1）（2）的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。 显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。 输入 第1行为两个正整数m和n（其中m（&lt;20）表示机器数，n（&lt;20）表示工件数），用一个空格隔开：第2行：个用空格隔开的数，为给定的安排顺序。接下来的2n行，每行都是用空格隔开的m个正整数，每个数不超过20。其中前n行依次表示每个工件的每个工序所使用的机器号，第1个数为第1个工序的机器号，第2个数为第2个工序机器号，等等。后n行依次表示每个工件的每个工序的加工时间。 输出 只有一个正整数，为最少的加工时间。 样例输入 2 31 1 2 3 3 21 21 22 13 22 52 4 样例输出 10 题目解读代码 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int i,j,k,l,m,n,num[25][25],a[500],t[25][25],sum[25],f[25][1000],mx[25],ans,mt[25];int main() &#123; scanf("%d%d",&amp;m,&amp;n); for (i=1; i&lt;=m*n; i++) scanf("%d",&amp;a[i]); for (i=1; i&lt;=n; i++) for (j=1; j&lt;=m; j++) scanf("%d",&amp;num[i][j]); for (i=1; i&lt;=n; i++) for (j=1; j&lt;=m; j++) scanf("%d",&amp;t[i][j]); for (i=1; i&lt;=m*n; i++) &#123; sum[a[i]]++; for (j=mt[a[i]]; j&lt;=1000; j++) &#123; int pd=1; for (k=j; k&lt;=j+t[a[i]][sum[a[i]]]-1; k++) &#123; if (f[num[a[i]][sum[a[i]]]][k]==1) &#123; pd=0; break; &#125; &#125; if (pd==1) &#123; if (j+t[a[i]][sum[a[i]]]&gt;mx[num[a[i]][sum[a[i]]]]) mx[num[a[i]][sum[a[i]]]]=j+t[a[i]][sum[a[i]]]; if (j+t[a[i]][sum[a[i]]]&gt;mt[a[i]]) mt[a[i]]=j+t[a[i]][sum[a[i]]]; for (k=j; k&lt;=j+t[a[i]][sum[a[i]]]-1; k++) f[num[a[i]][sum[a[i]]]][k]=1; break; &#125; &#125; &#125; for (i=1; i&lt;=m; i++) ans=max(mx[i],ans); printf("%d\n",ans); &#125; Maximum Tape Utilization Ratio设有n 个程序{1,2,…, n }要存放在长度为L的磁带上。程序i存放在磁带上的长度是li ，1 &lt; = i &lt; = n。 程序存储问题要求确定这n 个程序在磁带上的一个存储方案，使得能够在磁带上存储尽可能多的程序。在保证存储最多程序的前提下还要求磁带的利用率达到最大。 对于给定的n个程序存放在磁带上的长度，编程计算磁带上最多可以存储的程序数和占用磁带的长度。 输入 第一行是2 个正整数，分别表示文件个数n &lt;=600和磁带的长度L&lt;=6000。接下来的1 行中，有n个正整数，表示程序存放在磁带上的长度。 输出 第1 行输出最多可以存储的程序数和占用磁带的长度；第2行输出存放在磁带上的每个程序的长度。 样例输入 9 502 3 13 8 80 20 21 22 23 样例输出 5 492 3 13 8 23 题目解读动态规划，优先考虑尽可能多的程序个数，如果程序个数相同再考虑程序占据的长度。 dp[i][j][0]：代表前i个程序，占据j长度，存储程序个数最大值 dp[i][j][1]：代表前i个程序，占据j长度，存储程序长度最大值 注意输入时倒序输，因为最后要回溯判断选了哪些并按顺序输出。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int dp[605][6005][2];//dp[i][j][k]//k=0，前i个程序，占据j长度，存储程序个数最大值//k=1，前i个程序，占据j长度，存储程序长度最大值int main()&#123; int n,L,i,j,k; int w[605]; cin&gt;&gt;n&gt;&gt;L; for(i=1;i&lt;=n;i++) cin&gt;&gt;w[n+1-i]; for(i=1;i&lt;=n;i++) &#123; for(j=0;j&lt;=L;j++) &#123; if(w[i]&lt;=j &amp;&amp; dp[i-1][j][0] &lt; dp[i-1][j-w[i]][0]+1) &#123; dp[i][j][0]=dp[i-1][j-w[i]][0]+1; dp[i][j][1]=dp[i-1][j-w[i]][1]+w[i]; &#125; else if(w[i]&lt;=j &amp;&amp; dp[i-1][j][0] == dp[i-1][j-w[i]][0]+1) &#123; dp[i][j][0]=dp[i-1][j][0]; dp[i][j][1]=max(dp[i-1][j][1],dp[i-1][j-w[i]][1]+w[i]); &#125; else &#123; dp[i][j][0]=dp[i-1][j][0]; dp[i][j][1]=dp[i-1][j][1]; &#125; &#125; &#125; cout&lt;&lt;dp[n][L][0]&lt;&lt;" "&lt;&lt;dp[n][L][1]&lt;&lt;endl; i=n,j=dp[n][L][1],k=0; while(i) &#123; if(dp[i][j][0] == dp[i-1][j-w[i]][0]+1 &amp;&amp; dp[i][j][1] == dp[i-1][j-w[i]][1]+w[i]) &#123; j-=w[i]; if(k++) cout&lt;&lt;" "; cout&lt;&lt;w[i]; &#125; i--; &#125; cout&lt;&lt;endl; return 0;&#125; Soldiers在一个划分成网格的操场上，n个士兵散乱地站在网格点上。网格点由整数坐标(x,y)表示。士兵们可以沿网格边上、下、左、右移动一步，但在同一时刻任一网格点上只能有一名士兵。按照军官的命令，士兵们要整齐地列成一个水平队列，即排列成(x,y),(x+1,y),…,(x+n-1,y)。如何选择x 和y的值才能使士兵们以最少的总移动步数排成一列。计算使所有士兵排成一行需要的最少移动步数。 输入 第1 行是士兵数n，1&lt; =n&lt; =10000。接下来n 行是士兵的位置，每行2个整数x和y，-10000&lt; =x，y&lt; =10000。 输出 第1 行中的数是士兵排成一行需要的最少移动步数。 样例输入 51 22 21 33 -23 3 样例输出 8 题目解读因为是排成一排，所以y方向必须选择一个中间值，对y左边排序取中位数。如果n是奇数，则就是中位数，如果n是偶数，就是中间两个数中的任意一个。 下面考虑x方向，需要注意的是，排好队后x坐标必须是连续的。所以说先对x排序，然后 x[i]-i 就是x每个x需要移动的最小距离，再对这个新的数组求中位数就是最佳位置。 代码 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,x[10005],y[10005],midx,midy,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; sort(y,y+n); midy=y[n/2]; sort(x,x+n); for(int i=0;i&lt;n;i++) x[i]-=i; sort(x,x+n); midx=x[n/2]; for(int i=0;i&lt;n;i++) ans+=abs(midx-x[i])+abs(midy-y[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Edit Distance设A 和B 是2 个字符串。要用最少的字符操作将字符串A 转换为字符串B。这里所说的字符操作包括 (1)删除一个字符； (2)插入一个字符； (3)将一个字符改为另一个字符。 将字符串A变换为字符串B 所用的最少字符操作数称为字符串A到B 的编辑距离，记为d(A,B)。试设计一个有效算法，对任给的2 个字符串A和B，计算出它们的编辑距离d(A,B)。 输入 第一行是字符串A，文件的第二行是字符串B。字符串长度不大于2000。 输出 输出距离d(A,B) 样例输入 fxpimuxwr 样例输出 5 题目解读此题常见的思路是动态规划，令dp[i][j] 表示原字符串S[0…i] 和目标串T[0…j] 的最短编辑距离，其边界： dp[i][0] = i, dp[0][j] = j ,我们可以得到状态转移方程：$$dp[i][j]=min \begin{cases} dp[i-1][j]+1,&amp;\text{S[i]不在T[0…j]中}\\ dp[i][j-1]+1，&amp;\text{S[i]在T[0…j-1]中}\\ dp[i-1][j-1] + 0or1，&amp;\text{S[i]在T[j]中}\end{cases}$$下面解释这3个式子： S[i] 不在 T[0…j]中，说明目标串里面没有源字符串的这个字符，即在某一次操作中这个字符被删除了。因为删除操作没有前后相关性，不妨将其在第一次操作中删除，进行了一次删除操作后，后续编辑操作是将长度为i-1的字符串编辑为长度为 j 的字符串，即dp[i-1][j]。 S[i] 在 T[0…j-1]中说明，S[i] 出现在 T[0…j-1]中的某个位置，不妨认为是k，因为最小编辑步数的定义，那么，在k+1到j-1的字符，必然是通过插入新字符完成的。因为共插入了(j-k)个字符，故编辑次数为(j-k)次。而字符串S[1…i]经过编辑，得到了T[1…k]，编辑次数为dp[i][k]。故： dp[i][j] = dp[i][k] + (j-k)。 由于最后的(j-k)次是插入操作，可以讲(j-k)逐次规约到dp[i][k]中。即：dp[i][k]+(j-k)=dp[i][k+1] + (j-k-1) 规约到插入操作为1次，得到 dp[i][k]+(j-k) =dp[i][k+1] + (j-k-1) =dp[i][k+2] + (j-k-2)=… =dp[i][k+(j-k-1)] + (j-k)-(j-k-1) =dp[i][j-1] + 1。 关于dp[i-1][j-1] + 0/1, s[i] 在T[j]的说明：s[i]经过编辑，最终落在T[j]的位置。 则要么s[i] == t[j]，s[i]直接落在T[j]。这种情况，编辑操作实际上是将长度为i-1的S’串，编辑成长度为j-1的T’串：即dp[i-1][j-1]； 要么s[i] ≠ t[j]，s[i] 落在T[j]后，要将s[i]修改成T[j]，即在上一种情况的基础上，增加一次修改操作：即dp[i-1][j-1] + 1。 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int dp[2005][2005];int main()&#123; char a[2005],b[2005]; cin&gt;&gt;a&gt;&gt;b; int len1,len2,i,j,cost; len1=strlen(a); len2=strlen(b); for(i=0;i&lt;=len1;i++) dp[i][0]=i; for(j=0;j&lt;=len2;j++) dp[0][j]=j; for(i=1;i&lt;=len1;i++) &#123; for(j=1;j&lt;=len2;j++) &#123; if(a[i-1]==b[j-1]) cost=0; else cost=1; dp[i][j]=min(dp[i-1][j-1]+cost,min(dp[i-1][j],dp[i][j-1])+1); &#125; &#125; cout&lt;&lt;dp[len1][len2]&lt;&lt;endl; return 0;&#125; Independent Task Scheduling用2 台处理机A 和B 处理n 个作业。设第i 个作业交给机器A 处理时需要时间i a ，若由机器B 来处理，则需要时间i b 。由于各作业的特点和机器的性能关系，很可能对于某些i，有ai &gt;=bi，而对于某些j,j≠i，有aj &lt; bj 。既不能将一个作业分开由2 台机器处理，也没有一台机器能同时处理2 个作业。设计一个动态规划算法，使得这2 台机器处理完这n个作业的时间最短(从任何一台机器开工到最后一台机器停工的总时间)。研究一个实例： (a1,a2,a3,a4,a5,a6)＝(2,5,7,10,5,2)；(b1,b2,b3,b4,b5,b6)＝(3,8,4,11,3,4)。 对于给定的2 台处理机A 和B处理n 个作业，找出一个最优调度方案，使2台机器处理完这n 个作业的时间最短。 输入 第1行是1个正整数n&lt;=200, 表示要处理n个作业。 接下来的2行中，每行有n 个正整数，分别表示处理机A 和B 处理第i 个作业需要的处理时间。 输出 最短处理时间 样例输入 62 5 7 10 5 23 8 4 11 3 4 样例输出 15 题目解读代码 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int a[205],b[205],t[2005]=&#123;0&#125;; int n,i,j,k,ta=0; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; ta+=a[i]; &#125; for(j=1;j&lt;=n;j++) cin&gt;&gt;b[j]; for(k=1;k&lt;=n;k++) &#123; for(i=ta;i&gt;=0;i--) &#123; if(i&gt;=a[k]) t[i]=min(t[i-a[k]],t[i]+b[k]); else t[i]=t[i]+b[k]; &#125; &#125; int ans=10000; for(i=0;i&lt;=ta;i++) &#123; ans=min(ans,max(i,t[i])); &#125; printf("%d\n",ans); return 0;&#125; Arbitrage套汇是指利用货币汇兑率的差异将一个单位的某种货币转换为大于一个单位的同种货币。例如，假定1 美元可以买0.7 英镑，1 英镑可以买9.5 法郎，且1 法郎可以买到0.16美元。通过货币兑换，一个商人可以从1 美元开始买入，得到0.7×9.5×0.16=1.064美元，从而获得6.4%的利润。 给定n 种货币c1 ,c2 ,… ,cn的有关兑换率，试设计一个有效算法，用以确定是否存在套汇的可能性。 输入 含多个测试数据项。每个测试数据项的第一行中只有1 个整数n (1&lt; =n&lt; =30)，表示货币总数。其后n行给出n种货币的名称。接下来的一行中 有1 个整数m，表示有m种不同的货币兑换率。其后m行给出m种不同的货币兑换率，每行有3 个数据项ci ， rij 和cj ，表示货币ci 和cj的兑换率为 rij。文件最后以数字0 结束。 输出 对每个测试数据项j，如果存在套汇的可能性则输出“Case j Yes”， 否则输出“Case j No”。 样例输入 3USDollarBritishPoundFrenchFranc3USDollar 0.5 BritishPoundBritishPound 10.0 FrenchFrancFrenchFranc 0.21 USDollar3USDollarBritishPoundFrenchFranc6USDollar 0.5 BritishPoundUSDollar 4.9 FrenchFrancBritishPound 10.0 FrenchFrancBritishPound 1.99 USDollarFrenchFranc 0.09 BritishPoundFrenchFranc 0.19 USDollar0 样例输出 Case 1 YesCase 2 No 题目解读看到题目之后首先想到的就是转换成图的问题，每个货币单位对应一个节点，计算一个节点经过其他节点最后回到自己时的路径（算路径时不时传统的权值相加，而应该是相乘）是否大于1的问题。关键问题就在于怎么把输入的数据转换成图… 思路就是先读入所有的name，然后循环找输入进来的每一条汇率中的两个国名分别是name中的第几个，对应的rank[j][k]就是汇率值。找的方法就是循环，用strcmp做为终止条件（即str1==str2），记录下标就可以把对应的rank[j][k]置为对应的汇率值。 接下来就是一个Floyd算法的变形，标准的Floyd应该是加法，因为最短路径是求每一段路程的总和；而这里应该是乘法，因为算汇率是乘法。如果找到汇率大于1的情况，就说明可以套汇，否则不能套汇。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,m,i,j,k,cnt=1; float x,rank[35][35]; char name[35][35],a[35],b[35]; while(cin&gt;&gt; n&amp;&amp;n) &#123; for(i=0;i&lt;n;i++) cin&gt;&gt;name[i]; memset(rank,0.0,sizeof(rank)); cin&gt;&gt;m; for(i=0;i&lt;m;i++) &#123; cin&gt;&gt;a&gt;&gt;x&gt;&gt;b; for(j=0;strcmp(a,name[j]);j++); for(k=0;strcmp(b,name[k]);k++); rank[j][k]=x; &#125; for(i=0;i&lt;n;i++) rank[i][i]=max(float(1.0),rank[i][i]); for(k=0;k&lt;n;k++) for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) rank[i][j]=max(rank[i][j],rank[i][k]*rank[k][j]); for(i=0;i&lt;n;i++) &#123; if(rank[i][i]&gt;1) break; &#125; if(i&lt;n) cout&lt;&lt;"Case "&lt;&lt;cnt++&lt;&lt;" Yes"&lt;&lt;endl; else cout&lt;&lt;"Case "&lt;&lt;cnt++&lt;&lt;" No"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记3]]></title>
    <url>%2F2018%2F05%2F26%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[第三章的学习笔记 第三章 递归递归的核心思想现在有一个盒子，盒子里还有盒子，要找到藏在某个盒子里的钥匙。 非递归思想（循环）： 递归思想： 简单来说：递归的思想就是函数自己调用自己。 基线条件和递归条件编写函数时，必须告诉它何时停止递归。正因如此，每个递归函数都有两个部分：基线条件和递归条件。递归条件指的是函数调用自己，而基线条件则值的是函数不再调用自己，从而避免形成无限循环。 递归求阶乘12345def factorial(x): if (x == 1): return 1 else: return x * factorial(x-1)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记2]]></title>
    <url>%2F2018%2F05%2F24%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[第二章的学习笔记 第二章 选择排序 本章主要学习两种最基本的数据结构——数组和链表。 同时还要学习一种排序算法——选择排序。 数组和链表数组对于数组来说，随机的读取元素时很高效，因为直接根据数组的下标就可以找到对应的元素。 但是数组的不便之处在于，需要提前申明数组的大小，如果需要存的数据量大于申明的数组大小，就无法存储多余的数据，如果用不完就会造成一定的内存浪费。 数组的另外一个不足之处就是，不便于进行插入、删除操作。如果要在数组的中间插入一个元素，要先将它后面的数据整体向后移动一个位置，才能插入新的元素，效率低下。 链表链表无需申明长度，可以随意进行元素的添加，在链表中，每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一次。这种数据结构的优势就是，便于进行插入、删除操作，只需将上一个元素存储的下一个元素地址指向待插入的元素地址，再把待插入的元素存储下一个元素地址，就完成了插入操作，比数组方便很多。 但是反过来，链表就不便于进行随机地读取元素了，因为并不知道待查找的元素的位置，所以需要一个一个的查，直到找到为止。 数组 链表 读取 O(1) O(n) 插入 O(n) O(1) 删除 O(n) O(1) O(n) = 线性时间 O(n) = 常量时间 总结数组和链表哪个用的更多呢？需要看具体情况。 有两种访问方式：随机访问和顺序访问。 顺序访问意味着从一个元素开始逐个地址读取元素，链表只能顺序访问。 随机访问意味着可以直接跳到第10个元素，数组可以随机访问。 因为在大部分情况下，我们需要随机访问，所以还是数组使用的更多。 选择排序既然是排序算法，就是给出一串无序的数组，然后编程使他们按照从小到大或者从大到小的顺序排列。 核心思想选择排序的思想很简单：首先找到所有数里最小的元素，把它存放在新的数组中，然后再在剩下的（n-1）个元素中找到最小的元素，并存放在新数组里面，以此类推，每次都在剩下的数中挑选出最小的存成新的数组，直到选完为止。 python代码1234567891011121314151617181920def findSmallest(arr): smallest = arr[0] #存储最小的值 smallest_index = 0 #存储最小值的索引 for i in range(1,len(arr)): if(arr[i] &lt; smallest): smallest = arr[i] smallest_index = i return smallest_indexdef selection_sort(arr): newArr = [] for i in range(len(arr)): smallest_index = findSmallest(arr) newArr.append(arr.pop(smallest_index)) #每次都找到最小的元素存入新数组，并在原来数组里删除掉 return newArrif __name__ == '__main__': print(selection_sort([5,3,6,2,10])) C/C++代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;void selection_sort(int *arr,int len)&#123; int i,j,min; for(i=0;i&lt;len-1;i++) &#123; min=i; for(j=i;j&lt;len;j++) &#123; if(arr[j]&lt;arr[min]) min=j; &#125; if(min!=i) &#123; int t=arr[min]; arr[min]=arr[i]; arr[i]=t; &#125; &#125;&#125;int main()&#123; int arr[5]=&#123;5,3,6,2,10&#125;; selection_sort(arr,5); for(int i=0;i&lt;5;i++) &#123; cout&lt;&lt;arr[i]&lt;&lt;" "; &#125; return 0;&#125; 时间复杂度每比较一次，就需要遍历一遍数组，所以每一次比较的时间复杂度都是O(n)，需要比较n次，所以选择排序的时间复杂度是O(n2)。 遗留问题： 随着排序的进行，每次需要比较的元素数在减小，最后一次需要检查的元素都只有一个，为什么是n个O(n)呢？ 因为平均每次检查的元素个数为n/2,因此运行时间为O(n * n/2)，但是大O表示法省略诸如1/2这样的常数，因此简写为O(n)。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记1]]></title>
    <url>%2F2018%2F05%2F22%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[《算法图解》像小说一样有趣的算法入门书，作者推崇图解式写作风格，生动易读。就我个人而言，算法一直是弱项，这次想花一个月的时间，坚持打卡学习，争取能在算法能力上取得一定的提升。 本书采用python语言编写，由于大部分ACM程序设计大赛都是用C/C++或java，所以我不仅用python编写，还会尽量用C/C++写代码。 第一章 算法简介二分查找算法定义二分查找，也叫折半查找，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 举例举个例子，给出一串有序数组：[10,20,30,40,50,60,70,80,90] 编号 1 2 3 4 5 6 7 8 9 数字 10 20 30 40 50 60 70 80 90 现在想要寻找80在哪个位置，蛮力法即是循环遍历数组中的每个元素，当遍历到的元素正好等于80时，就找到了，对于这个数组，需要查询8次。 而二分法的思想是，先看中间第5号元素是多少，结果是50，这样就把前面5个元素排除掉了，因为要找的90比50还大；现在只需要在5号到10号中间选，再挑选中间的7号元素查看，发现是70，还是比90小，那么前7个元素都被排除了；再在7到9之间选中间的8号元素查看，正好是80，就找到了，只查询了3次。 可以想象，随着元素的增多，二分法查找的效率会明显高于蛮力法，这就是二分法查找算法的优势。 代码实例python代码： 1234567891011121314151617181920212223242526def binary_search(list,item): #用low和high代表需要查找的区间范围 low = 0 high = len(list) - 1 while(low&lt;=high): #只要范围没有缩小到只剩一个元素 mid = (low + high) // 2 #中间的元素 #（"//"运算符代表取整除，返回商的整数部分，否则如果是小数，就无法在数组中查询了） guess = list[mid] #查看中间元素对应的值 if(guess == item): #找到了 return mid if(guess &gt; item): #猜大了 high = mid - 1 else: #猜小了 low = mid + 1 return None #没找到if __name__ == '__main__': my_list = [1,3,5,7,9] print(binary_search(my_list, 3)) print(binary_search(my_list, -1))"""1None""" C/C++代码： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int arr[5]=&#123;1,3,5,7,9&#125;;int binary_search(int n,int item) //传入数组的长度和需要查找的值&#123; int low = 0,high = n-1; while(low&lt;=high) &#123; int mid = (low + high) / 2; if(arr[mid]==item) &#123; return mid; break; &#125; if(arr[mid]&gt; item) high=mid-1; if(arr[mid]&lt; item) low=mid+1; &#125; return -1;&#125;int main()&#123; printf("%d\n",binary_search(5,3)); printf("%d\n",binary_search(5,-1)); return 0;&#125; 大O表示法 在计算机科学中，算法的时间复杂度是一个函数，它定性描述该算法的运行时间，这是一个代表算法输入值的字符串的长度的函数。时间复杂度通常用大O表示。 引入下面做一个实验，分别比较同种操作系统下、同种规模的数据量（1到105、106、107），二分法和蛮力查找最后一个元素时，所花费的时间。 python中计算运行时间的方法： 1234import timet0 = time.clock()binary_search(list,item)print("process time:", time.clock() - t0) python中蛮力法遍历查找的代码如下： 12345678910def rude_search(num_list,item): for index,element in enumerate(num_list): if(element == item): return index return Noneif __name__ == '__main__': my_list = [1,3,5,7,9] print(rude_search(my_list, 3)) print(rude_search(my_list, -1)) 下面是运行时间的比较,我们做出曲线图： 这时我们就会发现一个问题，仅知道算法需要多长时间才能运行完毕还不够，还需要知道运行时间如何随列表增长而增加，这正是大O的用武之地。 大O大O指出了算法有多快。例如，假设列表有n个元素，蛮力法查找需要检查每个元素，因此需要（最多）执行n次操作。使用大O表示法，这个运行时间为O(n)，没有单位，因为大O表示法让你能够比较操作次数，它指出了算法运行时间的增速。 常见的大O运行时间 名称 时间复杂度 算法举例 对数时间 O(log n) 二分查找 线性时间 O(n) 遍历数组 线性迭代对数时间 O(n * log n) 快速排序 二次时间 O(n2) 选择排序 阶乘时间 O(n!) 旅行商问题]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（上）]]></title>
    <url>%2F2018%2F05%2F19%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[动态规划（英语：Dynamic programming，简称DP） 常常适用于有重叠子问题 和最优子性质的问题。 动态规划（上）动态规划（英语：Dynamic programming，简称DP） 常常适用于有重叠子问题 和最优子性质的问题。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 斐波那契数列斐波那契数列可以以递归的方式来定义： F0 = 0 F1 = 1 Fn = Fn-1 + Fn-2 （n&gt;=2) 用文字来说，就是斐波那契数列由0和1开始，之后的数就是前面连个数之和：0,1,1,2,3,5,8,13…… 求解斐波那契数列时，可以直接使用递归的定义方法： 12345int fib(n)&#123; if(n==0 || n==1) return n; return fib(n-1)+fib(n-2);&#125; 这样的定义方式便于理解，但是有一个问题：对于相似的子问题进行了大量重复的计算，例如在求fib(5)时，经历了这样的步骤： fib(5) fib(4) + fib(3) ( fib(3) + fib(2) ) + ( fib(2) + fib(1) ) [ ( fib(2) + fib(1) ) + ( fib(1) + fib(0) ) ] + [ ( fib(1) + fib(0) ) + fib(1) ] [ ( ( fib(1) + fib(0) ) + fib(1) ) + ( fib(1) + fib(0) ) ] + [ ( fib(1) + fib(0) ) + fib(1) ] 由这个过程可以看出，这样递归的方法会重复计算多次fib(2)、fib(3)，因此效率很低，如果将前n个已经计算出来了的 fib(i) 存在一个数组中，这样在后面的计算中，就可以直接调用数组中存储的值，而避免了重复计算。这种思想就是动态规划的思想。 1234567int dp[1005];int fib(n)&#123; if(n==0) dp[n]=0; if(n==1) dp[n]=1; dp[n]=dp[n-1]+dp[n-2];&#125; 收集硬币问题有一串数字，现在需要取出一些数组，取数规则就是不能选两个相邻的数。现在需要计算在这种规则下，能取到的数字之和最大是多少。 例如以下这一串数字： 编号 0 1 2 3 4 5 num 5 1 2 10 6 2 现在定义一个数组dp[ ],dp[i]代表选择到第i个硬币时，能得到的最大金额数。 以dp[5]为例，此时有两种选择： 选5号（那就不能选4号）：dp[3]+num[5] 不选5号（就可以选4号）：dp[4] 这样就可以推导出状态方程：$$\begin{cases}dp[i] = max( dp[i-2] + num[i] , dp[i-1] )\dp[0] = num[0]\dp[1] = max( num[0], num[1] )\end{cases}$$这样就可以敲代码了，如果使用递归的方法，会产生很多重叠子问题，运算速度慢，效率为O(n^2^)。所以不使用递归方法，而是建立一个dp数组，然后循环填表，一次把dp[0],dp[1],dp[2]……的值计算出来，最后最优解即是dp[n-1]。 代码 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define max(a,b) ((a&gt;b)?a:b)int main()&#123; int num[10000],dp[10000]=&#123;0&#125;; int n,i; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;num[i]; &#125; dp[0]=num[0]; dp[1]=max(num[0],num[1]); for(i=2;i&lt;n;i++) &#123; dp[i]=max(dp[i-2]+num[i],dp[i-1]); &#125; printf("%d\r\n",dp[n-1]); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv-python人脸识别应用]]></title>
    <url>%2F2018%2F05%2F08%2Fopencv-python%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[利用OpenCV和python环境实现简单的人脸识别应用：识别人脸并框处人脸、检测并框处人的眼睛、检测笑脸、并框处笑脸。 环境准备 系统环境：win7 python版本：python3.6.3 已存在vs2015（OpenCV需要C++环境） OpenCV 关于OpenCV自带的分类器OpenCV 是一个跨平台的计算机视觉库，它实现了图像处理和计算机视觉方面的很多通用算法，是一个非常强大的开源库。 OpenCV项目源码中有很多训练好的Haar分类器。 这些xml文件是已经训练好的数据，可以直接调用，进而达到识别分类的功能。本文不训练数据，直接使用这些OpenCV库中自带的方法进行人脸识别。 找到图像中人脸的位置1234567891011121314151617#detectFaces()返回图像中所有人脸的矩形坐标（矩形左上、右下顶点）#使用haar特征的级联分类器haarcascade_frontalface_default.xml，在haarcascades目录下还有其他的训练好的xml文件可供选择。#注：haarcascades目录下训练好的分类器必须以灰度图作为输入。def detectFaces(image_name): img = cv2.imread(image_name) face_cascade = cv2.CascadeClassifier("D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_frontalface_default.xml") #分类器函数中的参数就是xml文件的具体位置 if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 faces = face_cascade.detectMultiScale(gray, 1.2, 5)#1.3和5是特征的最小、最大检测窗口，它改变检测结果也会改变 result = [] for (x,y,width,height) in faces: result.append((x,y,x+width,y+height)) return result 函数最终返回一个列表，包含识别出来的人脸的左上、右上、左下、右下4个定点的坐标。 框出人脸123456789101112#在原图像上画矩形，框出所有人脸。#调用Image模块的draw方法，Image.open获取图像句柄，ImageDraw.Draw获取该图像的draw实例，然后调用该draw实例的rectangle方法画矩形(矩形的坐标即#detectFaces返回的坐标)，outline是矩形线条颜色(B,G,R)。#注：原始图像如果是灰度图，则去掉outline，因为灰度图没有RGB可言。drawEyes、detectSmiles也一样。def drawFaces(image_name): faces = detectFaces(image_name) if faces: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in faces: draw_instance.rectangle((x1,y1,x2,y2), outline=(255, 0,0)) img.save('drawfaces_'+image_name) 效果如图，可以看到正面人脸都被识别出来了，有一处判断错误的地方。 检测眼睛12345678910111213141516#检测眼睛，返回坐标#由于眼睛在人脸上，我们往往是先检测出人脸，再细入地检测眼睛。故detectEyes可在detectFaces基础上来进行，代码中需要注意“相对坐标”。#当然也可以在整张图片上直接使用分类器,这种方法代码跟detectFaces一样，这里不多说。def detectEyes(image_name): eye_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_eye.xml') faces = detectFaces(image_name) img = cv2.imread(image_name) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) result = [] for (x1,y1,x2,y2) in faces: roi_gray = gray[y1:y2, x1:x2] eyes = eye_cascade.detectMultiScale(roi_gray,1.3,2) for (ex,ey,ew,eh) in eyes: result.append((x1+ex,y1+ey,x1+ex+ew,y1+ey+eh)) return result 使用眼睛的分类器进行分类，将四个顶点的坐标保存在列表里。 框出眼睛123456789#在原图像上框出眼睛.def drawEyes(image_name): eyes = detectEyes(image_name) if eyes: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in eyes: draw_instance.rectangle((x1,y1,x2,y2), outline=(0, 0,255)) img.save('draweyes_'+image_name) 效果如图，识别的还不算太精准： 检验笑脸1234567891011121314#检测笑脸def detectSmiles(image_name): img = cv2.imread(image_name) smiles_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_smile.xml') if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 smiles = smiles_cascade.detectMultiScale(gray,4,5) result = [] for (x,y,width,height) in smiles: result.append((x,y,x+width,y+height)) return result 框出笑脸123456789#在原图像上框出笑脸def drawSmiles(image_name): smiles = detectSmiles(image_name) if smiles: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in smiles: draw_instance.rectangle((x1,y1,x2,y2), outline=(100, 100,0)) img.save('drawsmiles_'+image_name) 效果如图： 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import osimport cv2from PIL import Image,ImageDraw#detectFaces()返回图像中所有人脸的矩形坐标（矩形左上、右下顶点）#使用haar特征的级联分类器haarcascade_frontalface_default.xml，在haarcascades目录下还有其他的训练好的xml文件可供选择。#注：haarcascades目录下训练好的分类器必须以灰度图作为输入。def detectFaces(image_name): img = cv2.imread(image_name) face_cascade = cv2.CascadeClassifier("D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_frontalface_default.xml") if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 faces = face_cascade.detectMultiScale(gray, 1.2, 5)#1.3和5是特征的最小、最大检测窗口，它改变检测结果也会改变 result = [] for (x,y,width,height) in faces: result.append((x,y,x+width,y+height)) return result#保存人脸图def saveFaces(image_name): faces = detectFaces(image_name) if faces: #将人脸保存在save_dir目录下。 #Image模块：Image.open获取图像句柄，crop剪切图像(剪切的区域就是detectFaces返回的坐标)，save保存。 save_dir = image_name.split('.')[0]+"_faces" os.mkdir(save_dir) count = 0 for (x1,y1,x2,y2) in faces: file_name = os.path.join(save_dir,str(count)+".jpg") Image.open(image_name).crop((x1,y1,x2,y2)).save(file_name) count+=1#在原图像上画矩形，框出所有人脸。#调用Image模块的draw方法，Image.open获取图像句柄，ImageDraw.Draw获取该图像的draw实例，然后调用该draw实例的rectangle方法画矩形(矩形的坐标即#detectFaces返回的坐标)，outline是矩形线条颜色(B,G,R)。#注：原始图像如果是灰度图，则去掉outline，因为灰度图没有RGB可言。drawEyes、detectSmiles也一样。def drawFaces(image_name): faces = detectFaces(image_name) if faces: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in faces: draw_instance.rectangle((x1,y1,x2,y2), outline=(255, 0,0)) img.save('drawfaces_'+image_name)#检测眼睛，返回坐标#由于眼睛在人脸上，我们往往是先检测出人脸，再细入地检测眼睛。故detectEyes可在detectFaces基础上来进行，代码中需要注意“相对坐标”。#当然也可以在整张图片上直接使用分类器,这种方法代码跟detectFaces一样，这里不多说。def detectEyes(image_name): eye_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_eye.xml') faces = detectFaces(image_name) img = cv2.imread(image_name) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) result = [] for (x1,y1,x2,y2) in faces: roi_gray = gray[y1:y2, x1:x2] eyes = eye_cascade.detectMultiScale(roi_gray,1.3,2) for (ex,ey,ew,eh) in eyes: result.append((x1+ex,y1+ey,x1+ex+ew,y1+ey+eh)) return result#在原图像上框出眼睛.def drawEyes(image_name): eyes = detectEyes(image_name) if eyes: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in eyes: draw_instance.rectangle((x1,y1,x2,y2), outline=(0, 0,255)) img.save('draweyes_'+image_name)#检测笑脸def detectSmiles(image_name): img = cv2.imread(image_name) smiles_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_smile.xml') if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 smiles = smiles_cascade.detectMultiScale(gray,4,5) result = [] for (x,y,width,height) in smiles: result.append((x,y,x+width,y+height)) return result#在原图像上框出笑脸def drawSmiles(image_name): smiles = detectSmiles(image_name) if smiles: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in smiles: draw_instance.rectangle((x1,y1,x2,y2), outline=(100, 100,0)) img.save('drawsmiles_'+image_name)if __name__ == '__main__': drawFaces('obama.jpg') drawEyes('obama.jpg') drawSmiles('obama.jpg') saveFaces('obama.jpg')"""上面的代码将眼睛、人脸、笑脸在不同的图像上框出，如果需要在同一张图像上框出，改一下代码就可以了。总之，利用opencv里训练好的haar特征的xml文件，在图片上检测出人脸的坐标，利用这个坐标，我们可以将人脸区域剪切保存，也可以在原图上将人脸框出。剪切保存人脸以及用矩形工具框出人脸，本程序使用的是PIL里的Image、ImageDraw模块。此外，opencv里面也有画矩形的模块，同样可以用来框出人脸。""" 总结OpenCV自带的分类器使用起来比较简单，对于标准的人脸图片识别的准确率比较高，但是也有误判的现象，特别是笑脸的判断不够精准，还有待完善。 后期可以使用OpenCV制作分类器，大致分为3步： 制作训练集的数据集 训练分类器 使用分类器进行分类]]></content>
      <categories>
        <category>onpencv</category>
      </categories>
      <tags>
        <tag>图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验三]]></title>
    <url>%2F2018%2F05%2F04%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验三 简单背包问题设有一个背包可以放入的物品重量为S，现有n件物品，重量分别是w1，w2，w3，…wn。 问能否从这n件物品中选择若干件放入背包中，使得放入的重量之和正好为S。 如果有满足条件的选择，则此背包有解，否则此背包问题无解。 输入 输入数据有多行，假设背包可以放入的物品重量为S，物品的件数n，以及每件物品的重量（输入数据均为正整数）。多组测试数据。 输出 对于每个测试实例，若满足条件则输出“YES”，若不满足则输出“NO“。 样例输入 20 51 3 5 7 9 样例输出 YES 题目解读思想就是先把所有的物品都放入背包，然后再一件一件的往外拿，当拿出之后： 当背包被取空了时，就表明有解； 当拿完所有物品后，背包质量还不等于weight，就无解； 当第n个物品没有取出，而n-1个被取出时，背包的质量等于weight，就有解。 假设第n－1个物品取出来了，依然往下取，这时背包的weight变成weight-data[n]。 代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int data[1005];int bag(int weight,int n)&#123; if(weight==0) return 1; if(n==0 &amp;&amp; weight!=0) return 0; if(bag(weight,n-1)==1) return 1; return bag(weight-data[n],n-1);&#125;int main()&#123; int weight,n; while(scanf("%d %d",&amp;weight,&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;data[i]); &#125; if(bag(weight,n)==1) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; Buyer哆啦A梦班级举办个party，当然吃的东西必不可少，哆啦A梦负责采购任务，他得到了一份清单，上面注明不同食品的受欢迎程度，哆啦A梦需要用一定的价钱尽可能达到的更大的受欢迎程度！例如，瓜子的受欢迎程度为20，瓜子的价钱是50元，那么如果哆啦A梦选择买瓜子，将花费50元，但受欢迎程度增加了20。为了避免食品单调性，每种食品只能买一份，不能重复购买。 现在哆啦A梦需要知道如何采购才能达到最大的受欢迎程度，你能帮助他吗？ 输入 输入数据为多组，每组输入的第一行有两个正整数M和N(M&lt;100&amp;&amp;N&lt;1000)，分别为哆啦A梦可以支配的钱数和清单上的可选择的物品种类。 接下来的N行每行有两个正整数,分别为每种物品的价钱和它的受欢迎程度（编号为1到N）。 输出 如果存在物品购买，那么输出的第一行为能够达到的最大的受欢迎程度。第二行为需要购买的物品的编号（如果有多种可能，输出字典序靠前的那种），空格分隔每个数字；如没有物品可以购买，输出只有一行，为数字0。 样例输入 10 4100 55 55 510 10 样例输出 102 3 题目解读这道题就是01背包问题，金额限定M代表背包的容量，每种物品的价格代表物品的重量w[ ]，每种物品的价值用v[ ]表示。 动态规划求解构造一个二维数组dp[N][M]，N行（N个物品),M列（M为容量能使用的最大金额)。二维数组dp[i][j]的含义是：当拿到第i个物品，不超过金额 j 时的最大价值。一行一行的循环填表： 如果当前的限额超过了该物品的价值，表示可以取该物品,需要选择最优解： 如果不取，当前价值为dp[i-1][j] 如果取，当前价值为dp[i-1][ j-w[i] ]+v[i]（指考虑了i-1件物品，背包容量为 j-w[i] 时的价值加上拿取的这件物品的价值） 如果当前的限额低于这件物品的价值，就不能拿取这个物品： 当前价值为dp[i-1][j] 12345678910for(i=1;i&lt;=N;i++)&#123; for(j=1;j&lt;=M;j++) &#123; if(j&gt;=w[i]) dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); else dp[i][j]=dp[i-1][j]; &#125;&#125; 回溯检验是否取了物品另外创建一个一维数组x[N]，下标代表物品对应的编号，0代表没有取，1代表取了。 由于dp[i][M]为最优解，如果dp[i][M]=dp[i-1][M]，那就说明有没有第i件物品都一样，那么x[i]=0，否则x[i]=1。 1234567891011121314void traceback(int M,int N) &#123; for(int i=N;i&gt;1;i--) &#123; if(dp[i][M]==dp[i-1][M]) x[i]=0; else &#123; x[i]=1; M-=w[i]; &#125; &#125; x[1]=(dp[1][M]&gt;0)?1:0; &#125; 输出问题（小心PE） 首先输出一行最大价值，换行； 然后输出取出来的物品，中间用一个空格隔开，注意最后一个数后面没有空格，而是换行； 多组输入，所以当最大价值为0时，输出0然后continue再次进入新的循环 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int dp[1005][1005]=&#123;0&#125;;int x[1005];int v[1005],w[1005];void traceback(int M,int N) &#123; for(int i=N;i&gt;1;i--) &#123; if(dp[i][M]==dp[i-1][M]) x[i]=0; else &#123; x[i]=1; M-=w[i]; &#125; &#125; x[1]=(dp[1][M]&gt;0)?1:0; &#125; int main()&#123; int M,N,i,j; while(scanf("%d %d",&amp;M,&amp;N)!=EOF) &#123; for(i=1;i&lt;=N;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(i=1;i&lt;=N;i++) &#123; for(j=1;j&lt;=M;j++) &#123; if(j&gt;=w[i]) dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); else dp[i][j]=dp[i-1][j]; &#125; &#125; traceback(M,N); int sum=0; for(i=1;i&lt;=N;i++) &#123; if(x[i]==1) sum+=v[i]; &#125; if(sum==0) &#123; cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; cout&lt;&lt;sum&lt;&lt;endl; int flag=0; for(i=1;i&lt;=N;i++) &#123; if(x[i]==1 &amp;&amp; flag==0) &#123; cout&lt;&lt;i; flag=1; &#125; else if(x[i]==1 &amp;&amp; flag==1) cout&lt;&lt;" "&lt;&lt;i; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 售货员的难题某乡有n个村庄（1&lt; n &lt; 20），有一个售货员，他要到各个村庄去售货，各村庄之间的路程s（0 &lt; s &lt; 1000）是已知的，且A村到B村与B村到A村的路大多不同。为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，假设商店所在的村庄为 1，他不知道选择什么样的路线才能使所走的路程最短。请你帮他选择一条最短的路。 输入 村庄数n和各村之间的路程（均是整数）。 输出 最短的路径 样例输入 3 {村庄数}0 2 1 {村庄1到各村的路程}1 0 2 {村庄2到各村的路程}2 1 0 {村庄3到各村的路程} 样例输出 3 题目解读代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define maxn 25int INF=12345678;int n,maps[maxn][maxn];int d[maxn][maxn];int vis[1005];void Floyd()&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(d[i][j]&gt;d[i][k]+d[k][j]) d[i][j]=d[i][k]+d[k][j];&#125;void dfs(int x,int dis,int cnt)//x:current position&#123; if(x==1 &amp;&amp; cnt==n) &#123; INF=min(INF,dis); return; &#125; vis[x]=1; for(int i=1;i&lt;=n;i++) if((dis+maps[x][i]+d[i][1]&lt;INF) &amp;&amp; ((vis[i]==0) || (cnt==n-1 &amp;&amp; i==1))) dfs(i,dis+maps[x][i],cnt+1); vis[x]=0;&#125;int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;maps[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=maps[i][j]; memset(vis,0,sizeof(vis)); Floyd(); dfs(1,0,0); printf("%d\n",INF); &#125; return 0;&#125; 跑跑卡丁车跑跑卡丁车是时下一款流行的网络休闲游戏，你可以在这虚拟的世界里体验驾驶的乐趣。这款游戏的特别之处是你可以通过漂移来获得一种 加速卡，用这种加速卡可以在有限的时间里提高你的速度。为了使问题简单化，我们假设一个赛道分为L段，并且给你通过每段赛道的普通耗时Ai和用加速卡的耗时Bi。加速卡的获得机制是：普通行驶的情况下，每通过1段赛道,可以获得20%的能量(N2O).能量集满后获得一个加速卡(同时能量清0).加速卡最多可以储存2个,也就是说当你有2个加速卡而能量再次集满,那么能量清零但得不到加速卡。一个加速卡只能维持一段赛道，游戏开始时没有加速卡。问题是，跑完n圈最少用时为多少？ 输入 每组输入数据有3行，第一行有2个整数L( 0 &lt; L &lt; 100),N(0 &lt; N &lt; 100)分别表示一圈赛道分为L段和有N圈赛道，接下来两行分别有L个整数Ai和Bi (Ai &gt; Bi). 输出 对于每组输入数据，输出一个整数表示最少的用时. 样例输入 18 19 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 98 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 样例输出 145 题目解读代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int dp[10005][15],a[105],b[105],n,m;int main() &#123; while(cin&gt;&gt;n&gt;&gt;m) &#123; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; for(int i=0; i&lt;n; i++) cin&gt;&gt;b[i]; for(int i=0; i&lt;n*m; i++) &#123; a[i]=a[i%n]; b[i]=b[i%n]; &#125; memset(dp,INF,sizeof(dp)); dp[1][1]=a[0]; for(int i=1; i&lt;n*m; i++) &#123; for(int j=0; j&lt;15; j++) &#123; int k=j+1; if(k==15) k=10; dp[i+1][k]=min(dp[i+1][k],dp[i][j]+a[i]); if(j&gt;=5) dp[i+1][j-5]=min(dp[i+1][j-5],dp[i][j]+b[i]); &#125; &#125; int ans=INF; for(int i=0; i&lt;15; i++) ans=min(ans,dp[n*m][i]); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Renting Boats长江游艇俱乐部在长江上设置了n 个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt; =i&lt; j &lt; =n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n 所需的最少租金。 输入 第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的n-1 行是r(i,j),1&lt; =i&lt; j &lt; =n。 输出 从游艇出租站1 到游艇出租站n所需的最少租金 样例输入 35 157 样例输出 12 题目解读此题可以用Floyd-Warshall算法算法解决，Floyd算法是解决两点间的最短路径的一种算法。Floyd算法的原理是动态规划。 算法思想:如果存在定点k，使得以k做为中介点时，顶点i和顶点j之间的当前距离缩短，则使用顶点k做为顶点i和顶点j之间的中介点，即当dis[i][k] + dis[k][j] &lt; dis[i][j] 时，令 dis[i][j]=dis[i][k] + dis[k][j] 。 算法流程： 枚举顶点k 以顶点k做为中介点，枚举所有顶点i和j 如果dis[i][k] + dis[k][j] &lt; dis[i][j]成立，则 dis[i][j]=dis[i][k] + dis[k][j] 代码 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int dis[205][205]=&#123;0&#125;;int n;int Floyd()&#123; for(int k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(dis[i][k]!=0 &amp;&amp; dis[k][j]!=0 &amp;&amp; dis[i][k]+dis[k][j]&lt;dis[i][j]) dis[i][j]=dis[i][k]+dis[k][j];&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i=0;i&lt;n;i++) &#123; for(int j=i+1;j&lt;n;j++) &#123; cin&gt;&gt;dis[i][j]; &#125; &#125; Floyd(); cout&lt;&lt;dis[0][n-1]&lt;&lt;endl; &#125; return 0;&#125; Jack Strawsn the game of Jack Straws, a number of plastic or wooden “straws” are dumped on the table and players try to remove them one-by-one without disturbing the other straws. Here, we are only concerned with if various pairs of straws are connected by a path of touching straws. You will be given a list of the endpoints for some straws (as if they were dumped on a large piece of graph paper) and then will be asked if various pairs of straws are connected. Note that touching is connecting, but also two straws can be connected indirectly via other connected straws. 输入 A problem consists of multiple lines of input. The first line will be an integer n (1 &lt; n &lt; 13) giving the number of straws on the table. Each of the next n lines contain 4 positive integers, x1 , y1 , x2 and y2 , giving the coordinates, (x1 ; y1 ); (x2 ; y2 ) of the endpoints of a single straw. All coordinates will be less than 100. (Note that the straws will be of varying lengths.) The first straw entered will be known as straw #1, the second as straw #2, and so on. The remaining lines of input (except for the final line) will each contain two positive integers, a and b, both between 1 and n, inclusive. You are to determine if straw a can be connected to straw b. When a = 0 = b, the input is terminated. There will be no illegal input and there are no zero-length straws. 输出 You should generate a line of output for each line containing a pair a and b, except the final line where a = 0 = b. The line should say simply “CONNECTED”, if straw a is connected to straw b, or “NOT CONNECTED”, if straw a is not connected to straw b. For our purposes, a straw is considered connected to itself. 样例输入 71 6 3 34 6 4 94 5 6 71 4 3 53 5 5 55 2 6 35 4 7 21 41 63 36 72 31 30 0 样例输出 CONNECTEDNOT CONNECTEDCONNECTEDCONNECTEDNOT CONNECTEDCONNECTED 题目解读代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int set[20]; struct Point &#123; int x1,x2,y1,y2; Point(int x1 = 0, int x2 = 0, int y1 = 0, int y2 = 0) : x1(x1),x2(x2),y1(y1),y2(y2) &#123;&#125;; void read() &#123; scanf("%d %d %d %d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); &#125; &#125;p[20]; void unit(int n) &#123; for(int i = 1; i &lt;= n; i++) set[i] = i; &#125; int find(int x) &#123; return x == set[x] ? x : set[x] = find(set[x]); &#125; int cross(int x1, int y1, int x2, int y2) &#123; return x1 * y2 - x2 * y1; &#125; int intersection(Point A, Point B) //判断直线相交 &#123; int c[4]; if(max(A.x1,A.x2) &lt; min(B.x1,B.x2) || max(A.y1,A.y2) &lt; min(B.y1,B.y2) || max(B.x1,B.x2) &lt; min(A.x1,A.x2) || max(B.y1,B.y2) &lt; min(A.y1,A.y2) ) return 0; //考虑共线不相交的情况,为快速排斥定理 /*判断两条直线是否相交,即只需判断线是否在另一条线的两端*/ c[0] = cross(A.x2 - A.x1, A.y2 - A.y1, B.x1 - A.x1, B.y1 - A.y1); c[1] = cross(A.x2 - A.x1, A.y2 - A.y1, B.x2 - A.x1, B.y2 - A.y1); c[2] = cross(B.x2 - B.x1, B.y2 - B.y1, A.x1 - B.x1, A.y1 - B.y1); c[3] = cross(B.x2 - B.x1, B.y2 - B.y1, A.x2 - B.x1, A.y2 - B.y1); if(c[0] * c[1] &lt;= 0 &amp;&amp; c[2] * c[3] &lt;= 0) return 1; //运用到了向量的叉乘和点乘的知识; return 0; &#125; int main() &#123; //freopen("in.txt","r",stdin); int n; while(~scanf("%d",&amp;n) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; i++) p[i].read(); unit(n); for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) &#123; if(intersection(p[i],p[j])) &#123; int a = find(i); int b = find(j); if(a != b) set[a] = b; &#125; &#125; &#125; int a,b; while(~scanf("%d %d",&amp;a,&amp;b), a | b) &#123; a = find(a); b = find(b); if(a == b) puts("CONNECTED"); else puts("NOT CONNECTED"); &#125; &#125; return 0; &#125; Coin-collecting by robotSeveral coins are placed in cells of an n×m board. A robot, located in the upper left cell of the board, needs to collect as many of the coins as possible and bring them to the bottom right cell. On each step, the robot can move either one cell to the right or one cell down from its current location. 输入 The fist line is n,m, which 1&lt; = n,m &lt;= 1000.Then, have n row and m col, which has a coin in cell, the cell number is 1, otherwise is 0. 输出 The max number Coin-collecting by robot. 样例输入 5 60 0 0 0 1 00 1 0 1 0 00 0 0 1 0 10 0 1 0 0 11 0 0 0 1 0 样例输出 5 题目解读题目大意 在nxm的方格中有一些硬币，用1代表有硬币，0代表没有硬币。现在让一个机器人来尽可能多的捡硬币，它从左上角出发，每次只能走一步，要么向下走，要么向右走，到右下角时结束。 编号 0 1 2 3 4 5 0 0 0 0 0 1 0 1 0 1 0 1 0 0 2 0 0 0 1 0 1 3 0 0 1 0 0 1 4 1 0 0 0 1 0 建立dp二维数组，把原始数据存入二维数组中，这时从右下角往左上角依次按行列遍历，重新计算dp[i][j]的值。计算方法就是两种选择二选一，要么向下走，要么向右走： 选择下方的数：dp[i][j] += dp[i+1][j] 选择右面的数：dp[i][j] += dp[i][j+1] 状态方程就是： dp[i][j] += max( dp[i+1][j] , dp[i][j+1] ) 最后dp[0][0]就是最大值。 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define max(a,b) ((a&gt;b)?a:b)int dp[1000][1000]=&#123;0&#125;;int main()&#123; int n,m,i,j; cin&gt;&gt;n&gt;&gt;m; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; cin&gt;&gt;dp[i][j]; &#125; &#125; for(i=n-1;i&gt;=0;i--) &#123; for(j=m-1;j&gt;=0;j--) &#123; dp[i][j] += max(dp[i+1][j],dp[i][j+1]); &#125; &#125; printf("%d\r\n",dp[0][0]); return 0;&#125; Coin-row problemThere is a row of n coins whose values are some positive integers c₁, c₂,…,cn, not necessarily distinct. The goal is to pick up the maximum amount of money subject to the constraint that no two coins adjacent in the initial row can be picked up. 输入 Two lines, the first line is n (0&lt; n &lt;=10000), and the second line is value of coin(0&lt; value &lt;= 2^32). 输出 the maximum amount of money. 样例输入 65 1 2 10 6 2 样例输出 17 题目解读题目大意 有一串数字，现在需要取出一些数组，取数规则就是不能选两个相邻的数。现在需要计算在这种规则下，能取到的数字之和最大是多少。 编号 0 1 2 3 4 5 num 5 1 2 10 6 2 dp(i)代表选择到第i个硬币时，能得到的金额数。 以dp(5)为例，此时有两种选择： 选5号（那就不能选4号）：dp(3)+num(5) 不选5号（就可以选4号）：dp(4) 这样就可以推导出状态方程： dp(i) = max( dp(i-2)+num[i] , dp(i-1) ) dp(0) = num[0] dp(1) = max( num[0] , num[1] ) 这样就可以敲代码了，如果使用递归的方法，会产生很多重叠子问题，运算速度慢，效率为O(n^2)。所以不使用递归方法，而是建立一个dp数组，然后循环填表，一次把dp[0],dp[1],dp[2]……的值计算出来，最后最优解即是dp[n-1]。 代码 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define max(a,b) ((a&gt;b)?a:b)int main()&#123; int num[10000],dp[10000]=&#123;0&#125;; int n,i; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;num[i]; &#125; dp[0]=num[0]; dp[1]=max(num[0],num[1]); for(i=2;i&lt;n;i++) &#123; dp[i]=max(dp[i-2]+num[i],dp[i-1]); &#125; printf("%d\r\n",dp[n-1]); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之sklearn]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8Bsklearn%2F</url>
    <content type="text"><![CDATA[Scikit learn 也简称 sklearn, 是机器学习领域当中最知名的 python 模块之一。 Scikit learn模块Scikit learn 也简称 sklearn, 是机器学习领域当中最知名的 python 模块之一。 Sklearn 包含了很多种机器学习的方式: Classification 分类（监督学习） Regression 线性回归（监督学习） Clustering 非监督分类 Dimensionality reduction 数据降维 Model Selection 模型选择 Preprocessing 数据预处理 在股票、房价预测中可以使用线性回归。 其中蓝色圆圈内是判断条件，绿色方框内是可以选择的算法 sklearn 的使用正则化输入正则化含义解释 ： 如果输入特征属于不同范围内，可能有些特征值从0到1，有些特征值从1到1000，那么归一化（normalize）特征值就非常重要了。 具体参考吴恩达课程http://mooc.study.163.com/learn/2001281003?tid=2001391036#/learn/content?type=detail&amp;id=2001701046 12345678910# 将收盘数据正则化，全部化为-1到1之间的数import numpy as npimport pandas as pdfrom sklearn import preprocessing #标准化数据模块def normalize(): data = pd.read_csv("new_day_close.csv") data = data.iloc[:,1:] normalized = preprocessing.scale(data) print(normalized) SVR——Support Vector Regression交叉验证K-CV方法将原始数据分成K组(一般是均分),将每个子集数据分别做一次验证集,其余的K-1组子集数据作为训练集,这样会得到K个模型,用这K个模型最终的验证集的分类准确率的平均数作为此K-CV下分类器的性能指标.K一般大于等于2,实际操作时一般从3开始取,只有在原始数据集合数据量小的时候才会尝试取2.K-CV可以有效的避免过学习以及欠学习状态的发生,最后得到的结果也比较具有说服性。]]></content>
      <categories>
        <category>机器学习</category>
        <category>sklearn</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验二]]></title>
    <url>%2F2018%2F04%2F23%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验二 实验二凸包面积麦兜是个淘气的孩子。一天，他在玩钢笔的时候把墨水洒在了白色的墙上。再过一会，麦兜妈就要回来了，麦兜为了不让妈妈知道这件事情，就想用一个白色的凸多边形把墙上的墨点盖住。你能告诉麦兜最小需要面积多大的凸多边形才能把这些墨点盖住吗？ 现在，给出了这些墨点的坐标，请帮助麦兜计算出覆盖这些墨点的最小凸多边形的面积。 输入 多组测试数据。第一行是一个整数T，表明一共有T组测试数据。每组测试数据的第一行是一个正整数N(0&lt; N &lt; = 105)，表明了墨点的数量。接下来的N行每行包含了两个整数Xi和Yi（0&lt;=Xi,Yi&lt;=2000），表示每个墨点的坐标。每行的坐标间可能包含多个空格。 输出 每行输出一组测试数据的结果，只需输出最小凸多边形的面积。面积是个实数，小数点后面保留一位即可，不需要多余的空格。 样例输入 2 4 0 0 1 0 0 1 1 1 2 0 0 0 1 样例输出 1.0 0.0 题目解读代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int t,n;struct node&#123; int x,y; &#125;data[110],point[110],basic;int direction(node pi,node pj,node pk)&#123; return (pj.x-pi.x)*(pk.y-pi.y)-(pj.y-pi.y)*(pk.x-pi.x);&#125;int dis(node a,node b)&#123; return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);&#125;int cmp(node pj,node pk)&#123; int k=direction(basic,pj,pk); if(k==0) return(dis(basic,pj)&gt;dis(basic,pk)); else return k&gt;0?1:0;&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; int flag=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;data[i].x&gt;&gt;data[i].y; if(data[i].y&lt;data[flag].y||(data[i].y==data[flag].y&amp;&amp;data[i].x&lt;data[flag].x)) flag=i; &#125; if(n&lt;3) &#123; cout&lt;&lt;"0.0\n"; continue; &#125; node zz=data[0]; data[0]=data[flag]; data[flag]=zz; basic=data[0]; sort(data+1,data+n,cmp); int top=0; point[top++]=data[0]; point[top++]=data[1]; point[top++]=data[2]; for(int i=3;i&lt;n;i++) &#123; while(direction(point[top-2],point[top-1],data[i])&lt;0) top--; point[top++]=data[i]; &#125; double sum=0; for(int i=1;i&lt;top-1;i++) sum+=abs(direction(point[0],point[i],point[i+1])); printf("%.1lf\n",sum/2); &#125; return 0;&#125; 变位词如果两个单词的组成字母完全相同，只是字母的排列顺序不一样，则它们就是变位词，两个单词相同也被认为是变位词。如tea 与eat , nic 与cin, ddc与dcd, abc与abc 等。你的任务就是判断它们是否是变位词。 输入 第一行一个N,表示下面有N行测试数据。每行测试数据包括两个单词，如tea eat ,它们之间用空格割开 输出 对于每个测试数据，如果它们是变位词，输出Yes,否则输出No. 样例输入 3 tea eat ddc cdd dee dde 样例输出 Yes Yes No 题目解读策略 对于两个给定字符串，先预排序，排序之后比较是否完全一样，如果完全一样就是变位词，否则不是变位词。 代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int n; char a[105],b[105]; scanf("%d",&amp;n); while(n--) &#123; cin&gt;&gt;a&gt;&gt;b; int len1=strlen(a); int len2=strlen(b); sort(a,a+len1); sort(b,b+len2); if(strcmp(a,b)==0) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; Quick SortQuicksort is a well-known sorting algorithm developed by C. A. R. Hoare that, on average, makes Θ(n log n) comparisons to sort n items. However, in the worst case, it makes Θ(n2) comparisons. Typically, quicksort is significantly faster in practice than other Θ(n log n) algorithms, because its inner loop can be efficiently implemented on most architectures, and in most real-world data it is possible to make design choices which minimize the possibility of requiring quadratic time. Quicksort sorts by employing a divide and conquer strategy to divide a list into two sub-lists. The steps are: 1. Pick an element, called a pivot, from the list. 2. Reorder the list so that all elements which are less than the pivot come before the pivot and so that all elements greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation. 3. Recursively sort the sub-list of lesser elements and the sub-list of greater elements. The base case of the recursion are lists of size zero or one, which are always sorted. The algorithm always terminates because it puts at least one element in its final place on each iteration (the loop invariant). Quicksort in action on a list of random numbers. The horizontal lines are pivot values. Write a program to sort ascending int number by QuickSort ,n less than 50000. 输入 two lows, the first low is numbers , less and equal than 50000. the second low is a set integer numbers 输出 a set integer numbers of sort ascending 样例输入 10 4 2 1 5 7 6 9 8 0 3 样例输出 0 1 2 3 4 5 6 7 8 9 题目解读快排算法 代码 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n,i; int a[50005]; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; sort(a,a+n); for(i=0;i&lt;n;i++) &#123; printf("%d ",a[i]); &#125; printf("\n"); return 0;&#125; PostOffice在一个按照东西和南北方向划分成规整街区的城市里，n个居民点散乱地分布在不同的街区中。用x 坐标表示东西向，用y坐标表示南北向。各居民点的位置可以由坐标(x,y)表示。 街区中任意2 点(x1,y1)和(x2,y2)之间的距离可以用数值|x1-x2|+|y1-y2|度量。 居民们希望在城市中选择建立邮局的最佳位置，使n个居民点到邮局的距离总和最小。 任务：给定n 个居民点的位置,编程计算n 个居民点到邮局的距离总和的最小值。 输入 第1 行是居民点数n，1 &lt; = n &lt; =10000。接下来n 行是居民点的位置，每行2 个整数x 和y，-10000 &lt; =x，y &lt; =10000。 输出 n 个居民点到邮局的距离总和的最小值。 样例输入 5 1 2 2 2 1 3 3 -2 3 3 样例输出 10 题目解读策略 蛮力法。循环比较每两个点之间的距离。 代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n,i,midx,midy; scanf("%d",&amp;n); int x[10005],y[10005]; for(i=0;i&lt;n;i++) &#123; scanf("%d %d",&amp;x[i],&amp;y[i]); &#125; int sum=0; sort(x,x+n); sort(y,y+n); if(n%2==0) &#123; midx=(x[n/2]+x[n/2-1])/2; midy=(y[n/2]+y[n/2-1])/2; &#125; if(n%2!=0) &#123; midx=x[n/2]; midy=y[n/2]; &#125; for(i=0;i&lt;n;i++) &#123; int dis=abs(x[i]-midx)+abs(y[i]-midy); sum+=dis; &#125; printf("%d\n",sum); return 0;&#125; 俄式乘法俄式乘法，又被称为俄国农夫法，它是对两个正整数相乘的非主流算法。假设m和n是两个正整数，我们要计算它们的积。它的主要原理如下： if n is 偶数 n m=n/2 2m else n m=(n-1)/2 2m + m 该算法只包括折半，加倍，相加等几个简单操作，因此实现速度非常快。 输入 两个正整数 n,m。 输出 n和m的乘积。 输出整个求和表达式，运算符与数字之间用一个空格隔开。 样例输入 50 65 样例输出 130 + 1040 + 2080 = 3250 题目解读代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,m,i,k=0; int a[100]=&#123;0&#125;; scanf("%d %d",&amp;n,&amp;m); while(n&gt;1) &#123; if(n%2==0) &#123; n=n/2; m=m*2; &#125; else &#123; n=(n-1)/2; m=2*m; a[k]=m/2; k++; &#125; &#125; int sum=0; for(i=0;i&lt;k;i++) &#123; printf("%d",a[i]); printf(" + "); sum+=a[i]; &#125; printf("%d",m); printf(" = "); printf("%d\n",sum+m); return 0;&#125; 最近对问题设p1=(x1, y1), p2=(x2, y2), …, pn=(xn, yn)是平面上n个点构成的集合S，设计算法找出集合S中距离最近的点对。 输入 多组测试数据，第一行为测试数据组数n（0&lt;n≤100），每组测试数据由两个部分构成，第一部分为一个点的个数m（0&lt;m≤1000），紧接着是m行，每行为一个点的坐标x和y，用空格隔开，（0&lt;x，y≤100000） 输出 每组测试数据输出一行，为该组数据最近点的距离，保留4为小数。 样例输入 2 2 0 0 0 1 3 0 0 1 1 1 0 样例输出 1.0000 1.0000 题目解读策略 蛮力法。循环比较。 代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); while(n--) &#123; int m,i,j,k; scanf("%d",&amp;m); int x[1005],y[1005]; for(k=0;k&lt;m;k++) &#123; scanf("%d %d",&amp;x[k],&amp;y[k]); &#125; double min=10000; for(i=0;i&lt;m;i++) &#123; for(j=i+1;j&lt;m;j++) &#123; double a=(x[j]-x[i])*(x[j]-x[i]); double b=(y[j]-y[i])*(y[j]-y[i]); double dis=sqrt(a+b); if(dis&lt;min) min=dis; &#125; &#125; printf("%.4lf\n",min); &#125; return 0;&#125; 约瑟夫问题的实现n个人围成一个圈，每个人分别标注为1、2、…、n，要求从1号从1开始报数，报到k的人出圈，接着下一个人又从1开始报数，如此循环，直到只剩最后一个人时，该人即为胜利者。例如当n=10,k=4时，依次出列的人分别为4、8、2、7、3、10，9、1、6、5，则5号位置的人为胜利者。给定n个人，请你编程计算出最后胜利者标号数。（要求用单循环链表完成。） 输入 第一行为人数n; 第二行为报数k。 输出 输出最后胜利者的标号数。 样例输入 10 4 样例输出 5 题目解读代码 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int josephus(int n, int m)&#123; int i; int sum=0; for(i=1;i&lt;=n;i++) &#123; sum=(sum+m)%i; &#125; return sum+1;&#125;int main()&#123; int n,k; scanf("%d %d",&amp;n,&amp;k); int ans=josephus(n,k); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验一]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验一 实验一Euclid’s GameStarts with two unequal positive numbers (M,N and M&gt;N) on the board. Two players move in turn. On each move, a player has to write on the board a positive number equal to the difference of two numbers already on the board; this number must be new, i.e., different from all the numbers already on the board. The player who cannot move loses the game. Should you choose to move first or second in this game? According to the above rules, there are two players play tihs game. Assumptions A write a number on the board at first, then B write it. Your task is write a program to judge the winner is A or B. 输入 Two unequal positive numbers M and N , M&gt;N (M&lt;1000000) 输出 A or B 样例输入 3 1 样例输出 A 题目解读翻译 黑板上已经有两个正数M和N（M&gt;N），两个人轮流在黑板上写数组，要求写上的数字必须是黑板上已有数字只差，而且不能重复写已经在黑板上的数字，最后一个不能写数字的人就输了。请问赢家应该先写还是后写？ 策略 如果开始时，两个数字不是倍数关系，那么从M到1所有的数都可以出现，也就是黑板上总共可以出现M个数，减掉原先写在黑板上的两个数，就可以写 M-2 个数； 如果开始时，两个数字是整数倍关系，那么只能出现[M-1N , M-2N, M-3N…]这些数，也就是黑板上总共可以出现M/N个数，减掉原来写在黑板上的两个数，就可以写 M/N-2 个数。 代码 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int a,b,sum; scanf("%d %d",&amp;a,&amp;b); if(a%b==0) sum=a/b-2; else sum=a-2; if(sum%2==0) printf("B\n"); else printf("A\n"); return 0;&#125; 翻煎饼麦兜最喜欢的食物是煎饼，每次在街上看到煎饼摊的时候都会在那里停留几分钟。最吸引麦兜还是煎饼师傅那一手熟练的翻煎饼的技术，一堆煎饼在那里，师傅只需要用铲子翻几下，就让煎饼整齐的叠在了一起。 这天，为了庆祝麦兜被保送上研究生，他从煎饼师傅那里买回来一些煎饼请客。但是麦兜买回的煎饼大小不一，麦兜太想吃煎饼了，他想吃这些煎饼中最大的那个。麦兜还知道同学们也很喜欢煎饼，为了表示他的诚意，他想让同学们先吃，麦兜最后吃，因此，麦兜想把煎饼按照从小到大的顺序叠放在一起，大的在最下面。这样麦兜就可以在最后拿到最大的那一块煎饼了。 现在请你帮助麦兜用煎饼师傅翻煎饼的方法把麦兜买的煎饼从小到大的叠在一起。煎饼师傅的方法是用铲子插入两块煎饼之间，然后将铲子上的煎饼翻一转，这样铲子上第一个煎饼就被翻到了顶上，而原来顶上的煎饼则被翻到了刚才插入铲子的地方。麦兜希望这样翻煎饼的次数最少。 输入 输入包括两行，第一行是一个整数n(1&lt;=n&lt;=1000)，表示煎饼的个数，接下来的一行有n个不相同的整数，整数间用空格隔开，每个整数表示煎饼的大小（直径），左边表示顶部，右边表示底部。 输出 输出为一行，翻煎饼的最少次数 样例输入 5 5 4 2 3 1 样例输出 4 题目解读策略 每次先找最大的，然后把最大的翻到上面，再整体翻一次，最大的就到最下面了。 一个函数找数组中最大数对应的角标； 一个函数实现翻煎饼（把num[a]到num[b]逆序排列）； 一个递归函数反复找最大值和实现翻煎饼的过程。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int num[1005];int times=0;int turn(int a,int b)&#123; int i,j; for(i=a,j=b;i&lt;j;i++,j--) &#123; int t=num[i]; num[i]=num[j]; num[j]=t; &#125; times++;&#125;int FindMax(int a,int b)&#123; int i,max=a; for(i=a;i&lt;=b;i++) &#123; if(num[i]&gt;num[max]) max=i; &#125; return max;&#125;void change(int n)&#123; if(n==0) return; int maxn=FindMax(0,n); if(maxn!=0 &amp;&amp; maxn!=n) &#123; turn(0,maxn); turn(0,n); &#125; if(maxn==0) turn(0,n); change(n-1);&#125;int main()&#123; int n,i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) &#123; scanf("%d",&amp;num[i]); &#125; change(n-1); printf("%d\n",times); return 0;&#125; Locker doorsThere are n lockers in a hallway numbered sequentially from 1 to n. Initially, all the locker doors are closed. You make n passes by the lockers, each time starting with locker #1. On the ith pass, i = 1, 2, …, n, you toggle the door of every ith locker: if the door is closed, you open it, if it is open, you close it. For example, after the first pass every door is open; on the second pass you only toggle the even-numbered lockers (#2, #4, …) so that after the second pass the even doors are closed and the odd ones are opened; the third time through you close the door of locker #3 (opened from the first pass), open the door of locker #6 (closed from the second pass), and so on. After the last pass, which locker doors are open and which are closed? How many of them are open? Your task is write a program to output How many doors are open after the last pass? Assumptions all doors are closed at first. 输入 a positive numbers n, total doors. n&lt;=100000 输出 a positive numbers ，the total of doors opened after the last pass. 样例输入 10 样例输出 3 题目解读翻译 假设走廊上有n把锁，标号为0~n，全部都是锁上的，现在你经过走廊n次，第一次把1的倍数（1,2,3…）的锁打开，第二次把2的倍数（2,4,6…）的锁打开，如果已经打开了就关上，第三次对3的倍数的锁进行类似的操作。请问最后有几把锁是开着的？ 策略 直白的来看，就是从1到n，求每个数的公因数的个数（比如数字6，有1,2,3,6四个公因数，经过4次操作后就是关闭的状态），但是如果循环求n次公因数的个数，就会超时…… 换个角度想一想，什么样的数会有奇数个公因子呢？只有遇到1x1, 2x2, 3x3，… 才会出现奇数个公因子，所以只需要求$\sqrt{n}$的整数部分就可以啦！ 代码 123456789101112#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); int sum=sqrt(n); printf("%d\n",sum); return 0;&#125; The Josephus ProblemThe problem is named after Flavius Josephus, a Jewish historian who participated in and chronicled the Jewish revolt of 66-70C.E. against the Romans. Josephus, as a general, managed to hold the fortress of Jotapata for 47days, but after the fall of the city he took refuge with 40 diehards in a nearby cave. There the rebels voted to perish rather than surrender. Josephus proposed that each man in turn should dispatch his neighbor, the order to be determined by casting lots. Josephus contrived to draw the last lot, and as one of the two surviving men in the cave, he prevailed upon his intended victim to surrender to the Romans. Your task:computint the position of the survivor when there are initially n people. 输入 a Positive Integer n is initially people. n&lt; = 50000 输出 the position of the survivor 样例输入 6 样例输出 5 题目解读翻译 n个人围成一圈报数，报到2的人就会死掉，然后下一个人再接着从1开始报数，直到最后剩下一个人活着，请问最开始应该在几号位才能活到最后？ 策略 一种方法就是模拟，定义一个数组，从1到n全部置为1，对应编号的人死掉就置为0，用另一个数组表示当前报数的数字，等于2时，就从头再来。 还有一种公式法，循环取模。 代码 模拟法 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int n,i; scanf("%d",&amp;n); int s=0,t=0,count=0; int a[50005]=&#123;0&#125;; while(1) &#123; t++; if(t&gt;n) t=1; if(a[t]==0) s++; if(s==2) &#123; s=0; count++; a[t]=1; &#125; if(count==n-1) break; &#125; for(i=1;i&lt;=n;i++) &#123; if(a[i]==0) printf("%d\n",i); &#125; return 0;&#125; 公式法 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int josephus(int n, int m)&#123; int i; int sum=0; for(i=1;i&lt;=n;i++) &#123; sum=(sum+m)%i; &#125; return sum+1;&#125;int main()&#123; int n; scanf("%d",&amp;n); int ans=josephus(n,2); printf("%d\n",ans); return 0;&#125; Binary searchA binary search algorithm (or binary chop) is a technique for finding a particular value in a sorted list. It makes progressively better guesses, and closes in on the sought value, by comparing an element halfway with what has been determined to be an element too low in the list and one too high in the list. A binary search finds the median element in a list, compares its value to the one you are searching for, and determines if it’s greater than, less than, or equal to the one you want. A guess that turns out to be too high becomes the new top of the list, and one too low the new bottom of the list. The binary search’s next guess is halfway between the new list’s top and bottom. Pursuing this strategy iteratively, it narrows the search by a factor 2 each time, and finds your value. A binary search is an example of a divide and conquer algorithm (more specifically a decrease and conquer algorithm) and a dichotomic search (more at Search algorithm). The most common application of binary search is to find a specific value in a sorted list. To cast this in the frame of the guessing game (see Example below), realize that we are now guessing the index, or numbered place, of the value in the list. This is useful because, given the index, other data structures will contain associated information. Suppose a data structure containing the classic collection of name, address, telephone number and so forth has been accumulated, and an array is prepared containing the names, numbered from one to N. A query might be: what is the telephone number for a given name X. To answer this the array would be searched and the index (if any) corresponding to that name determined, whereupon it would be used to report the associated telephone number and so forth. Appropriate provision must be made for the name not being in the list (typically by returning an index value of zero), indeed the question of interest might be only whether X is in the list or not. If the list of names is in sorted order, a binary search will find a given name with far fewer probes than the simple procedure of probing each name in the list, one after the other in a linear search, and the procedure is much simpler than organising a hash table though that would be faster still, typically averaging just over one probe. This applies for a uniform distribution of search items but if it is known that some few items are much more likely to be sought for than the majority then a linear search with the list ordered so that the most popular items are first may do better. The binary search begins by comparing the sought value X to the value in the middle of the list; because the values are sorted, it is clear whether the sought value would belong before or after that middle value, and the search then continues through the correct half in the same way. Only the sign of the difference is inspected: there is no attempt at an interpolation search based on the size of the differences. Your task is to write a program that, given a set numbers of ascending and a key, finding a particular postion in a sorted list. 输入 The input contains one total numbers（N&lt;=5000000） and a find key,followed by a line containing the integer numbers ascending sets. 输出 if find the key in the sorted list, output containing postion in a sorted list, else ouput -1. 样例输入 10 7 0 1 2 3 4 5 6 7 8 9 样例输出 8 题目解读翻译 二分搜索（折半查找）：是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 特别注意 数组要开到5000005，写在函数外面，用iostream，c++提交。 代码 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int num[5000005];int binary(int n,int key)&#123; int first=0,last=n,mid; while(first&lt;=last) &#123; mid=(first+last)/2; if(num[mid]&gt;key) last=mid-1; if(num[mid]&lt;key) first=mid+1; if(num[mid]==key) return mid+1; &#125; return -1;&#125;int main()&#123; int n,i,key; scanf("%d %d",&amp;n,&amp;key); for(i=0;i&lt;n;i++) &#123; scanf("%d",&amp;num[i]); &#125; int ans=binary(n-1,key); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TF在MNIST中的应用]]></title>
    <url>%2F2018%2F04%2F18%2FTF%E5%9C%A8MNIST%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[TensorFlow在MNIST中的应用MNIST数据集简介常用的函数API r1.5tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(logits=prediction, labels=y))tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)tf.layers.conv2d(x_image, 32, 5, 1, ‘same’, activation=tf.nn.relu)tf.layers.max_pooling2d(conv1, 2, 2)tf.layers.dense(flat,10)tf.layers.dropout(output)]]></content>
  </entry>
</search>
