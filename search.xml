<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《图解算法》学习笔记9]]></title>
    <url>%2F2018%2F06%2F11%2F%E3%80%8A%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%2F</url>
    <content type="text"><![CDATA[第九章的学习笔记 第九章 动态规划背包问题经典的背包问题： 假设你是一个小偷，背着一个可以装4磅东西的背包。你可以盗取的物品有以下3样： 音响 3000美元 4磅 笔记本电脑 2000美元 3磅 吉他 1500美元 1磅 为了让盗窃的商品价值最高，应该怎么选择商品？ 解题过程每一个动态规划问题都是从一个网格开始，背包问题的网格如下： 网格的各行为商品，各列为不同容量（1~4磅）的背包。所有这些列都需要，因为他们帮助你计算子背包的价值。网格最初是空的，你将填充其中的每一个单元格，网格填满后，就可以得出答案。 现在开始填表： 吉他行 这一行中，你能够拿的物品只有吉他。当背包容量为1时就可以拿吉他，因为吉他的重量就是1，这时最大价值为1500，接下来当背包容量为2，3，4时，依然只能拿吉他，所以第一行全部都是1500。 音响行 现在可以选择的物品有吉他和音响。当容量为1，2，3时，只能拿吉他，价值为1500；当容量为4时，可以拿音响，音响比吉他值钱，所以拿音响，价值为3000。 这时容量为4的背包最大价值更新为3000。 笔记本电脑行 现在可以选择的物品有吉他、音响、笔记本电脑。当容量为1，2时，只能拿吉他，价值1500；当容量为3时，可以拿笔记本电脑，更新价值为2000；当容量为4时，可以拿（容量为3时的最大值 + 余下的1磅物品）或者之前选择的音响。发现笔记本电脑+吉他更之前，更新价值为4500。 现在表填完了，最后一行的最后一列代表所有物品都可以选且容量为背包最大容量时能获得的最大价值，即为答案。 动态规划算法在刚刚填表的过程中，其实是有一套规则的：$$cell\ [\ i\ ][\ j\ ]=\begin{cases} 上一个单元格的值（即cell\ [\ i-1\ ][\ j-1\ ]的值）\\当前商品的价值 + 剩余空间的价值（cell\ [\ i-1\ ][\ j- 当前商品的重量\ ]）\end{cases}$$背包问题FAQ Q：再增加一个物品呢？ A：直接再加一行即可，表格中前面的值不变，只用填新加的这一行就可以了，依然遵循刚才的填表原则。 Q：行的排列顺序发生变化会如何？ A：无论行是什么顺序，都不影响最终结果。 Q：可以逐列而不是逐行填表吗？ A：背包问题可以，有些动态规划问题不行。 Q：增加一件更小的物品怎么办？ A：例如增加一个0.5磅的物品，子背包应该变为0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4。 Q：可以偷商品的一部分吗？ A：不行，动态规划不能解决只拿一部分的问题。需要用贪心算法每次选择价值最高的物品。 Q：最优解可能出现没装满的情况吗？ A：很有可能。 最长公共子串&amp;子序列最长公共子串最长公共子串问题描述：假如用户输入一个单词，但是拼错了，你的字典里根本没有这个单词，但是有几个类似的单词，怎么判断另一个单词和他输入的单词的有多少字母相同呢？ 例如他输入hish，而你想计算fish和它的相似度。 填表： H I S H F 0 0 0 0 I 0 1 0 0 S 0 0 2 0 H 1 0 0 3 表格中最大的数为3，所以两个单词的最长公共子串的长度为3。 怎么填表的呢？ 如果两个字母不相同，则为0 如果两个字母相同，则为左上角邻居的值+1 最长公共子序列 F O S H F 1 1 1 1 I 1 1 1 1 S 1 1 2 2 H 1 1 2 3 填表依据： 如果两个字母不同，就选择上方和左方邻居中较大的那个 如果两个字母相同，就是左方单元格的值+1 代码实现1234567891011121314151617181920212223242526272829import string,randomdef lcs_dp(input_x, input_y): # 建立一个dp二维数组 # input_y as column, input_x as row dp = [([0] * (len(input_y) + 1)) for i in range(len(input_x) + 1)] for i in range(1, len(input_x) + 1): for j in range(1, len(input_y) + 1): if i == 0 or j == 0: # 在边界上，自行+1 dp[i][j] = 1 elif input_x[i - 1] == input_y[j - 1]: # 不在边界上，相等就加一 dp[i][j] = dp[i - 1][j - 1] + 1 else: # 不相等 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[-1][-1]def random_str(randomlength): str = "" for i in range(randomlength): str += random.choice(list(string.ascii_letters)) return strif __name__ == "__main__": str1 = random_str(10000) str2 = random_str(10000) print("字符串1:", str1) print("字符串2:", str2) print("最长子序列的长度：", lcs_dp(str1, str2)) 小结动态规划可以解决的常见实际问题： 生物学家根据最长公共子序列来确定DNA链的相似性，进而判断两种动物或疾病有多相似。 代码查重/论文查重也是查找最长公共子序列的问题。 计算编辑距离的问题，拼写检查、判断盗版都是用动态规划解决的。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解算法》学习笔记8]]></title>
    <url>%2F2018%2F06%2F10%2F%E3%80%8A%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08%2F</url>
    <content type="text"><![CDATA[第八章的学习笔记 第八章 贪婪算法教室调度问题假设有一张课表，你希望将尽可能多的课程安排在某间教室上。但是又本可能所有课都在这一间教室上，因为有些课的上课时间有冲突。 美术 9：00AM 10:00AM 英语 9：30AM 10：30AM 数学 10：00AM 11：00AM 计算机 10：30AM 11：30AM 音乐 11：00AM 12：00AM 具体做法是： 1.选出结束最早的课，它就是要在这间教室上的第一堂课。 2.接下来，必须选择第一堂课结束后才开始的课。同样，你选择结束最早的课，这将是要在这间教室上的第二堂课。 重复这样做就能找到答案。 贪婪算法很简单：每一步都采取最优的做法。用专业术语说，每步都选择局部最优解，最终得到的就是全局最优解。 集合覆盖问题假设需要让全美50个州都收到广播节目，不同的广播公司向不同的州广播，怎么选择最少的广播公司呢？ 这就需要列举出所有可能的集合，在这个集合中选择覆盖全美50个州的最小集合。 这样的穷举需要耗费大量的时间，效率极低。为了解决这种问题，可以采用近似算法，使用贪婪算法可以得到非常接近的解，而时间可以大大缩短。 12345678910111213141516171819202122states_needed = &#123;"mt", "wa", "or", "id", "nv", "ut", "ca", "az"&#125;stations = &#123;"kone": &#123;"id", "nv", "ut"&#125;, "ktwo": &#123;"wa", "id", "mt"&#125;, "kthree": &#123;"or", "nv", "ca"&#125;, "kfour": &#123;"nv", "ut"&#125;, "kfive": &#123;"ca", "az"&#125;&#125;final_stations = set()while states_needed: best_station = None states_covered = set() for station, states in stations.items(): covered = states_needed &amp; states if len(covered) &gt; len(states_covered): best_station = station states_covered = covered states_needed -= states_covered final_stations.add(best_station)print(final_stations) 小结 旅行商问题和集合覆盖问题有一个共同之处：需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。 元素较少时算法的运算速度非常快，但是随着元素数量的增加，速度会变得非常慢。 涉及“所有组合”的问题通常是NP完全问题。 不能将问题分成小问题，必须考虑各种情况的可能情况。这可能是NP完全问题。 贪婪算法寻找局部最优解，企图用这种方式获得全局最优解，贪婪算法易于实现、运算速度快，是不错的近似算法。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解算法》学习笔记7]]></title>
    <url>%2F2018%2F06%2F04%2F%E3%80%8A%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07%2F</url>
    <content type="text"><![CDATA[第七章的学习笔记 第七章 Dijkstra算法算法概述Dijkstra算法解决的是：在加权图中，一个点（源点）到其余各个顶点的最短路径问题，也叫做“单源最短路径”。例如下图所示的一个加权图中，从1到6有很多条路径，每一段的长度都不同，用Dijkstra算法可以选择一条长度最短的路径。 注意该算法要求图中不存在负权边。 核心思路若对于顶点 s 存在能直接到达的边（s,m），则把d[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径。当算法结束时，d[v] 中存储的便是从 s 到 v的最短路径，或者如果路径不存在的话是无穷大。 边的拓展是Dijkstra 算法的基础操作：如果存在一条从 u 到 v 的边，那么从 s 到 v 的最短路径可以通过将边（u, v）添加到尾部来拓展一条从 s 到 v 的路径。这条路径的长度是 d[u] + w(u, v)。如果这个值比目前已知的 d[v] 的值要小，我们可以用新值来替代当前 d[v] 中的值。拓展边的操作一直运行到所有的 d[v] 都代表从 s 到 v 的最短路径的长度值。此算法的组织令 d[u] 达到其最终值时，每条边（u, v）都只被拓展一次。 算法维护两个顶点集合 S 和 Q。集合 S 保留所有已知最小 d[v] 值的顶点 v ，而集合 Q 则保留其他所有顶点。集合S初始状态为空，而后每一步都有一个顶点从 Q 移动到 S。这个被选择的顶点是 Q 中拥有最小的 d[u] 值的顶点。当一个顶点 u 从 Q 中转移到了 S 中，算法对 u 的每条外接边 (u, v) 进行拓展。 换钢琴的实例这是交换物品的一张图，乐谱是起点（已经有的东西），现在需要花最少的钱来还到钢琴。 第一步：从起点（乐谱）出发，找到最便宜的节点。 这里只有两个节点，一个是唱片（权值为5），一个是海报（权值为0），所以选择海报这个节点。 第二步：计算前往该节点（海报）的各个邻居的开销。 用一个表来记录： 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 海报 吉他 30 海报 架子鼓 35 — 钢琴 &infin; 第三步：再次执行第一步。下一个最便宜的节点为唱片。 第四部：再次执行第二步。计算前往该节点（唱片）的各个邻居的开销。 用一个表来记录： 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 唱片 吉他 20 唱片 架子鼓 25 — 钢琴 &infin; 第五步：更新开销。 发现通过唱片到吉他和通过唱片到架子鼓的开销更小。所以将架子鼓和吉他的父节点更新为唱片。 第六步：重复第一步。现在起点变成了唱片。下一个最便宜的节点是吉他。 第七步：重复第二步。计算前往该节点（吉他）的各个邻居的开销。 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 唱片 吉他 20 唱片 架子鼓 25 吉他 钢琴 40 第八步：重复第一步。起点是唱片，除了吉他，下一个最便宜的节点是架子鼓。 第九步：重复第二步。计算前往该节点（架子鼓）的各个邻居的开销。 父节点 节点 开销 乐谱 唱片 5 乐谱 海报 0 唱片 吉他 20 唱片 架子鼓 25 架子鼓 钢琴 35 第十步：更新开销。 通过架子鼓到钢琴更便宜，所以钢琴的父节点更新为架子鼓。 至此，就找到了从乐谱到各个节点的最便宜的方案，例如要还到钢琴，就需要35元。怎么确定路径呢？根据父节点向前推导就可以知道这条路径了。 代码实现题目如下图为例： 定义散列表一共需要三个散列表，一个是定义图，节点之间权值的散列表，一个是costs，一个是parents，也就是前文例子中的表格后两列。 1234567891011121314151617181920212223# 先定义一个散列表，起点分别是start，a，b，fingraph = &#123;"start": &#123;&#125;, "a": &#123;&#125;, "b": &#123;&#125;, "fin": &#123;&#125;&#125;graph["start"]["a"] = 4graph["start"]["b"] = 2graph["a"]["fin"] = 1graph["b"]["a"] = 3graph["b"]["fin"] = 5infinity = float("inf")# 定义开销的散列表costs = &#123;&#125;costs["a"] = 6costs["b"] = 2costs["fin"] = infinity# 定义父节点的散列表parents = &#123;&#125;parents["a"] = "start"parents["b"] = "start"parents["fin"] = None 最小costs函数123456789def find_lowest_cost_node(costs): lowest_cost = float("inf") lowest_cost_node = None for node in costs: cost = costs[node] if cost &lt; lowest_cost and node not in processed: lowest_cost = cost lowest_cost_node = node return lowest_cost_node 主函数123456789101112node = find_lowest_cost_node(costs)while node is not None: cost = costs[node] neighbors = graph[node] for n in neighbors.keys(): new_cost = cost + neighbors[n] if costs[n] &gt; new_cost: costs[n] = new_cost parents[n] = node processed.append(node) node = find_lowest_cost_node(costs) print(node)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记6]]></title>
    <url>%2F2018%2F06%2F02%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%2F</url>
    <content type="text"><![CDATA[第六章的学习笔记 第六章 广度优先搜索BFS的核心思想：层层递进首先以一个未被访问过的顶点作为起始顶点，访问其所有相邻的顶点，然后对每个相邻的顶点再访问它们相邻的未被访问过的顶点，直到所有顶点都被访问过，遍历结束。 BFS搜索是一种用于图的查找，可以帮助回答两类问题： 从节点A出发，有前往节点B的路径吗？ 从节点A出发，前往节点B的哪条路径最短？ 芒果经销商的例子 假设你经营着一个芒果农场，需要寻找芒果经销商，为此，你在朋友列表中查找 这种查找很简单，创建一个朋友名单，并依次遍历每一个朋友看她是不是芒果经销商 假设没有，这时就要在朋友的朋友中查找 这时对于每一个朋友，再将他们的朋友加入到列表中 再次遍历列表，看朋友的朋友是不是芒果经销商 如果依然没有，就把第三层关系人物加入到列表，在重复遍历查找的操作。 广度优先搜索就是先查找一度关系，再查找二度关系、再查找三度关系，以此类推。在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，一层一层的向外查找。 注意，必须按照添加顺序查找时，才能实现这样的目的。如果不按照层次顺序查找，就无法找到最短路径。想要按照添加顺序进行检查，就需要使用一种数据结构，那就是队列（queue）。 队列队列是一种先进先出（First In First Out,FIFO）的数据结构，而栈是一种后进先出（Last In First Out,LIFO）的数据结构。 队列的工作原理与生活中的队列完全相同，不能随机访问队列中的元素，队列只支持两种操作：入队和出队。 实现算法 首先，创建一个队列。在python中，可以用deque来创建一个双端队列。 12345678910111213141516171819202122232425262728293031323334353637from collections import deque# 可以用散列表来生成图graph = &#123;&#125;graph['you'] = ['alice', 'bob', 'claire']graph['bob'] = ['anuj', 'peggy']graph['alice'] = ['peggy']graph['claire'] = ['thom', 'jonny']graph['anuj'] = []graph['peggy'] = []graph['thom'] = []graph['jonny'] = []def person_is_seller(name): # 自定义以m结尾的名字就是芒果经销商 return name[-1] == 'm'def search(name): search_queue = deque() search_queue += graph[name] searched = [] while search_queue: person = search_queue.popleft() # 取出第一个人 if person not in searched: if person_is_seller(person): print(person + " is a mango seller!") return True else: search_queue += graph[person] searched.append(person) return Falseif __name__ == '__main__': search('you') 小结 广度优先搜索指出是否有从A到B的路径。 如果有，广度优先搜索将找出最短路径。 有向图中的边为箭头，箭头方向指定了关系的方向。 无向图中的边不带箭头，其中的关系是双向的。 队列是先进先出（FIFO）的。 栈是后进先出（LIFO）的。 广度优先搜索需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。 对于检查过的人，务必不要再检查，否则会导致无限循环。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记5]]></title>
    <url>%2F2018%2F05%2F31%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%2F</url>
    <content type="text"><![CDATA[第五章的学习笔记 第五章 散列表散列表散列表（Hash table），也叫哈希表，是根据键（key）而直接访问在内存存储位置的数据结构，也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。 一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 X 到首字母 F(X) 的一个函数关系，在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则 F( )，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。 散列函数散列函数（英文：Hash function）又称哈希函数。 散列函数总是将同样的输入映射到相同的索引。 散列函数只带数组有多大，只返回有效的索引。 Python提供的散列表实现为字典，可以使用函数 dict 来创建散列表。 哈希查找1234567891011121314151617181920212223242526272829303132333435363738class HashTable: def __init__(self, size): self.elem = [None for i in range(size)] # 使用list数据结构作为哈希表元素保存方法 self.count = size # 最大表长 def hash(self, key): return key % self.count # 散列函数采用除留余数法 def insert_hash(self, key): """插入关键字到哈希表内""" address = self.hash(key) # 求散列地址 while self.elem[address]: # 当前位置已经有数据了，发生冲突。 address = (address+1) % self.count # 线性探测下一地址是否可用 self.elem[address] = key # 没有冲突则直接保存。 def search_hash(self, key): """查找关键字，返回布尔值""" star = address = self.hash(key) while self.elem[address] != key: address = (address + 1) % self.count if not self.elem[address] or address == star: # 说明没找到或者循环到了开始的位置 return False return True if __name__ == '__main__': list_a = [12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34] hash_table = HashTable(12) for i in list_a: hash_table.insert_hash(i) for i in hash_table.elem: if i: print((i, hash_table.elem.index(i)), end=" ") print("n") print(hash_table.search_hash(15)) print(hash_table.search_hash(33)) 小结 散链表常用于查找、防止重复。缓存。 散链表适用于映射关系、防止重复、缓存/记住数据。 冲突很糟糕，应该使用可以最大限度减小冲突的散列函数。 散列表的查找、插入、删除操作速度都非常快。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记4]]></title>
    <url>%2F2018%2F05%2F30%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[第四章的学习笔记 第四章 快速排序分治法——分而治之总述 分而治之（divide and conquer,D&amp;C）是一种著名的递归式问题解决方法。分治法提供了一种解决问题的思路，是另一种可供你使用的工具。分治法的核心思想就是用一种对解决某个问题通用而且尽可能简单的方法，不断缩小问题的规模，知道求解出问题为止。 步骤 找出基线条件，这种条件必须尽可能简单 不断将问题分解（缩小规模），直到符合基线条件。 分治法：划分方块问题题目要求 现在有一个矩形，边长为1680 * 640，需要将这个矩形均匀地分成方块，且分出的方块要尽可能大。 思路 找基线条件：当一条边长是另一条边长的整数倍时，就可以尽可能大的划分成方块。 分解问题： 首先找到这个矩形能容纳的最大方块：因为宽度是640，所以可以划分的最大方块的边长为640*640，一共可以划分出两个这样的方块。 剩下的矩形边长为640*400。 再对剩下的矩形进行相同的操作，找出这个矩形能容纳的最大方块：400*400。 剩下的矩形变成了400*240。 再对这个矩形进行同样的操作，找出最大能容纳的方块：240*240。 剩下的矩形变成了240*120。这时这个矩形可以划分成两个小方形（满足基线条件：一条边长是另一条边长的整数倍）结束。 最后，对于最初的那个矩形，适用的最大方块为80*80。 这里用到了一个原理：适用于这小块地的最大方块，也是适用于整块地的最大方块。这个原理来源于欧几里得算法。 分治法：求数组元素之和题目要求 给出一个数组，数组中有一串数组，现在需要求这数组中数字元素之和。 最简单的方法就是直接循环求和： 12345def sum(arr): total = 0 for x in arr: total += x return total 但是怎么用递归函数来实现呢？这就需要不断的把问题规模缩小。 例如给出一个数组：[2,4,6],求和： 第一步：找出基线条件：$$\begin{cases}空集不包含任何元素 ,&amp; \text{总和为0} \\ 只包含一个元素, &amp; \text {总和为该元素本身}\end{cases}$$第二步：缩小规模： 1234def dc_sum(arr): if arr == []: return 0 return arr[0] + dc_sum(arr[1:]) 分治法：快速排序快速排序的思想是：先选择一个元素值做为基准值，然后将数组中所有小于基准数的数放在这个数的左边，大于这个数的元素都放在右边。再在这两个子数组中做这种操作，各选择一个基准数，然后小的放一边，大的放一边……直到子数组为空或者只有一个元素（这两种情况下的子数组一定是有序的）。 12345678def quick_sort(arr): if len(arr) &lt; 2: return arr else: pivot = arr[0] #这里直接把第一个元素当做基准值 less = [i for i in arr[1:] if i &lt;= pivot] more = [i for i in arr[1:] if i &gt; pivot] return quick_sort(less) + [pivot] + quick_sort(more) 总结 分治法将问题逐步分解，划分成n个子问题。使用分治法处理列表时，基线条件很可能是空数组或者只包含一个元素。 实现快速排序时，基准值可以随机选择。 快速排序的平均运行时间为O(n logn)。 虽然快速排序和归并排序的时间效率都是O(n logn)，但是快速排序往往比归并排序要快很多。这是因为大O表示法中的常量事关重大。 快速查找比简单查找和二分查找的效率高很多。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验四]]></title>
    <url>%2F2018%2F05%2F27%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验四 作业调度方案我们现在要利用m台机器加工n个工件，每个工件都有m道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。 每个工件的每个工序称为一个操作，我们用记号j-k表示一个操作，其中j为1到n中的某个数字，为工件号；k为1到m中的某个数字，为工序号，例如2-4表示第2个工件第4道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。 例如，当n=3，m=2时，“1-1，1-2，2-1，3-1，3-2，2-2”就是一个给定的安排顺序，即先安排第1个工件的第1个工序，再安排第1个工件的第2个工序，然后再安排第2个工件的第1个工序，等等。 一方面，每个操作的安排都要满足以下的两个约束条件。 (1) 对同一个工件，每道工序必须在它前面的工序完成后才能开始； (2) 同一时刻每一台机器至多只能加工一个工件。 另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。 由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为“1 1 2 3 3 2”。 还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。 例如，取n=3,m=2，已知数据如下： 工件号 机器号/加工时间 工序 11 工序 22 11 , 1/31/3 , 2/22/2 22 , 1/21/2 , 2/52/5 33 , 2/22/2 , 1/41/4 则对于安排顺序“1 1 2 3 3 2”，下图中的两个实施方案都是正确的。但所需要的总时间分别是10与12。 当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件（1）（2）的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件（1）（2）的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。 显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。 输入 第1行为两个正整数m和n（其中m（&lt;20）表示机器数，n（&lt;20）表示工件数），用一个空格隔开：第2行：个用空格隔开的数，为给定的安排顺序。接下来的2n行，每行都是用空格隔开的m个正整数，每个数不超过20。其中前n行依次表示每个工件的每个工序所使用的机器号，第1个数为第1个工序的机器号，第2个数为第2个工序机器号，等等。后n行依次表示每个工件的每个工序的加工时间。 输出 只有一个正整数，为最少的加工时间。 样例输入 2 31 1 2 3 3 21 21 22 13 22 52 4 样例输出 10 题目解读代码 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int i,j,k,l,m,n,num[25][25],a[500],t[25][25],sum[25],f[25][1000],mx[25],ans,mt[25];int main() &#123; scanf("%d%d",&amp;m,&amp;n); for (i=1; i&lt;=m*n; i++) scanf("%d",&amp;a[i]); for (i=1; i&lt;=n; i++) for (j=1; j&lt;=m; j++) scanf("%d",&amp;num[i][j]); for (i=1; i&lt;=n; i++) for (j=1; j&lt;=m; j++) scanf("%d",&amp;t[i][j]); for (i=1; i&lt;=m*n; i++) &#123; sum[a[i]]++; for (j=mt[a[i]]; j&lt;=1000; j++) &#123; int pd=1; for (k=j; k&lt;=j+t[a[i]][sum[a[i]]]-1; k++) &#123; if (f[num[a[i]][sum[a[i]]]][k]==1) &#123; pd=0; break; &#125; &#125; if (pd==1) &#123; if (j+t[a[i]][sum[a[i]]]&gt;mx[num[a[i]][sum[a[i]]]]) mx[num[a[i]][sum[a[i]]]]=j+t[a[i]][sum[a[i]]]; if (j+t[a[i]][sum[a[i]]]&gt;mt[a[i]]) mt[a[i]]=j+t[a[i]][sum[a[i]]]; for (k=j; k&lt;=j+t[a[i]][sum[a[i]]]-1; k++) f[num[a[i]][sum[a[i]]]][k]=1; break; &#125; &#125; &#125; for (i=1; i&lt;=m; i++) ans=max(mx[i],ans); printf("%d\n",ans); &#125; Maximum Tape Utilization Ratio设有n 个程序{1,2,…, n }要存放在长度为L的磁带上。程序i存放在磁带上的长度是li ，1 &lt; = i &lt; = n。 程序存储问题要求确定这n 个程序在磁带上的一个存储方案，使得能够在磁带上存储尽可能多的程序。在保证存储最多程序的前提下还要求磁带的利用率达到最大。 对于给定的n个程序存放在磁带上的长度，编程计算磁带上最多可以存储的程序数和占用磁带的长度。 输入 第一行是2 个正整数，分别表示文件个数n &lt;=600和磁带的长度L&lt;=6000。接下来的1 行中，有n个正整数，表示程序存放在磁带上的长度。 输出 第1 行输出最多可以存储的程序数和占用磁带的长度；第2行输出存放在磁带上的每个程序的长度。 样例输入 9 502 3 13 8 80 20 21 22 23 样例输出 5 492 3 13 8 23 题目解读代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int n, L, w[605], dp[605][6005][2], i, j, k;//dp[i][j][k] k=0,前i个程序，占据j长度，存贮程序个数最大值// k=1,前i个程序，占据j长度，存贮程序耗费最大磁带长度int main() &#123; cin &gt;&gt; n &gt;&gt; L; for (i = 1; i &lt;= n; ++i) cin &gt;&gt; w[n + 1 - i];//逆序存贮方便输出最优解 for (i = 1; i &lt;= n; ++i) &#123; for (j = 0; j &lt;= L; ++j) &#123; if (w[i] &lt;= j &amp;&amp; dp[i - 1][j][0] &lt; dp[i - 1][j - w[i]][0] + 1) &#123; dp[i][j][0] = dp[i - 1][j - w[i]][0] + 1; dp[i][j][1] = dp[i - 1][j - w[i]][1] + w[i]; &#125; else if (w[i] &lt;= j &amp;&amp; dp[i - 1][j][0] == dp[i - 1][j - w[i]][0] + 1) &#123; dp[i][j][0] = dp[i - 1][j][0]; dp[i][j][1] = max(dp[i - 1][j][1], dp[i - 1][j - w[i]][1] + w[i]); &#125; else &#123; dp[i][j][0] = dp[i - 1][j][0]; dp[i][j][1] = dp[i - 1][j][1]; &#125; &#125; &#125; cout &lt;&lt; dp[n][L][0] &lt;&lt; ' ' &lt;&lt; dp[n][L][1] &lt;&lt; endl; i = n, j = dp[n][L][1], k = 0; while (i) &#123; if (dp[i][j][0] == dp[i - 1][j - w[i]][0] + 1 &amp;&amp; dp[i][j][1] == dp[i - 1][j - w[i]][1] + w[i]) &#123; j -= w[i]; if (k++) cout &lt;&lt; ' '; cout &lt;&lt; w[i]; &#125; i--; &#125; cout &lt;&lt; endl; return 0;&#125; Soldiers在一个划分成网格的操场上，n个士兵散乱地站在网格点上。网格点由整数坐标(x,y)表示。士兵们可以沿网格边上、下、左、右移动一步，但在同一时刻任一网格点上只能有一名士兵。按照军官的命令，士兵们要整齐地列成一个水平队列，即排列成(x,y),(x+1,y),…,(x+n-1,y)。如何选择x 和y的值才能使士兵们以最少的总移动步数排成一列。计算使所有士兵排成一行需要的最少移动步数。 输入 第1 行是士兵数n，1&lt; =n&lt; =10000。接下来n 行是士兵的位置，每行2个整数x和y，-10000&lt; =x，y&lt; =10000。 输出 第1 行中的数是士兵排成一行需要的最少移动步数。 样例输入 51 22 21 33 -23 3 样例输出 8 题目解读因为是排成一排，所以y方向必须选择一个中间值，对y左边排序取中位数。如果n是奇数，则就是中位数，如果n是偶数，就是中间两个数中的任意一个。 下面考虑x方向，需要注意的是，排好队后x坐标必须是连续的。所以说先对x排序，然后 x[i]-i 就是x每个x需要移动的最小距离，再对这个新的数组求中位数就是最佳位置。 代码 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,x[10005],y[10005],midx,midy,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; sort(y,y+n); midy=y[n/2]; sort(x,x+n); for(int i=0;i&lt;n;i++) x[i]-=i; sort(x,x+n); midx=x[n/2]; for(int i=0;i&lt;n;i++) ans+=abs(midx-x[i])+abs(midy-y[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Edit Distance设A 和B 是2 个字符串。要用最少的字符操作将字符串A 转换为字符串B。这里所说的字符操作包括 (1)删除一个字符； (2)插入一个字符； (3)将一个字符改为另一个字符。 将字符串A变换为字符串B 所用的最少字符操作数称为字符串A到B 的编辑距离，记为d(A,B)。试设计一个有效算法，对任给的2 个字符串A和B，计算出它们的编辑距离d(A,B)。 输入 第一行是字符串A，文件的第二行是字符串B。字符串长度不大于2000。 输出 输出距离d(A,B) 样例输入 fxpimuxwr 样例输出 5 题目解读此题常见的思路是动态规划，令dp[i][j] 表示原字符串S[0…i] 和目标串T[0…j] 的最短编辑距离，其边界： dp[i][0] = i, dp[0][j] = j ,我们可以得到状态转移方程：$$dp[i][j]=min \begin{cases} dp[i-1][j]+1,&amp;\text{S[i]不在T[0…j]中}\\ dp[i][j-1]+1，&amp;\text{S[i]在T[0…j-1]中}\\ dp[i-1][j-1] + 0or1，&amp;\text{S[i]在T[j]中}\end{cases}$$下面解释这3个式子： S[i] 不在 T[0…j]中，说明目标串里面没有源字符串的这个字符，即在某一次操作中这个字符被删除了。因为删除操作没有前后相关性，不妨将其在第一次操作中删除，进行了一次删除操作后，后续编辑操作是将长度为i-1的字符串编辑为长度为 j 的字符串，即dp[i-1][j]。 S[i] 在 T[0…j-1]中说明，S[i] 出现在 T[0…j-1]中的某个位置，不妨认为是k，因为最小编辑步数的定义，那么，在k+1到j-1的字符，必然是通过插入新字符完成的。因为共插入了(j-k)个字符，故编辑次数为(j-k)次。而字符串S[1…i]经过编辑，得到了T[1…k]，编辑次数为dp[i][k]。故： dp[i][j] = dp[i][k] + (j-k)。 由于最后的(j-k)次是插入操作，可以讲(j-k)逐次规约到dp[i][k]中。即：dp[i][k]+(j-k)=dp[i][k+1] + (j-k-1) 规约到插入操作为1次，得到 dp[i][k]+(j-k) =dp[i][k+1] + (j-k-1) =dp[i][k+2] + (j-k-2)=… =dp[i][k+(j-k-1)] + (j-k)-(j-k-1) =dp[i][j-1] + 1。 关于dp[i-1][j-1] + 0/1, s[i] 在T[j]的说明：s[i]经过编辑，最终落在T[j]的位置。 则要么s[i] == t[j]，s[i]直接落在T[j]。这种情况，编辑操作实际上是将长度为i-1的S’串，编辑成长度为j-1的T’串：即dp[i-1][j-1]； 要么s[i] ≠ t[j]，s[i] 落在T[j]后，要将s[i]修改成T[j]，即在上一种情况的基础上，增加一次修改操作：即dp[i-1][j-1] + 1。 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int dp[2005][2005];int main()&#123; char a[2005],b[2005]; cin&gt;&gt;a&gt;&gt;b; int len1,len2,i,j,cost; len1=strlen(a); len2=strlen(b); for(i=0;i&lt;=len1;i++) dp[i][0]=i; for(j=0;j&lt;=len2;j++) dp[0][j]=j; for(i=1;i&lt;=len1;i++) &#123; for(j=1;j&lt;=len2;j++) &#123; if(a[i-1]==b[j-1]) cost=0; else cost=1; dp[i][j]=min(dp[i-1][j-1]+cost,min(dp[i-1][j],dp[i][j-1])+1); &#125; &#125; cout&lt;&lt;dp[len1][len2]&lt;&lt;endl; return 0;&#125; Independent Task Scheduling用2 台处理机A 和B 处理n 个作业。设第i 个作业交给机器A 处理时需要时间i a ，若由机器B 来处理，则需要时间i b 。由于各作业的特点和机器的性能关系，很可能对于某些i，有ai &gt;=bi，而对于某些j,j≠i，有aj &lt; bj 。既不能将一个作业分开由2 台机器处理，也没有一台机器能同时处理2 个作业。设计一个动态规划算法，使得这2 台机器处理完这n个作业的时间最短(从任何一台机器开工到最后一台机器停工的总时间)。研究一个实例： (a1,a2,a3,a4,a5,a6)＝(2,5,7,10,5,2)；(b1,b2,b3,b4,b5,b6)＝(3,8,4,11,3,4)。 对于给定的2 台处理机A 和B处理n 个作业，找出一个最优调度方案，使2台机器处理完这n 个作业的时间最短。 输入 第1行是1个正整数n&lt;=200, 表示要处理n个作业。 接下来的2行中，每行有n 个正整数，分别表示处理机A 和B 处理第i 个作业需要的处理时间。 输出 最短处理时间 样例输入 62 5 7 10 5 23 8 4 11 3 4 样例输出 15 题目解读代码 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int a[205],b[205],t[2005]=&#123;0&#125;; int n,i,j,k,ta=0; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; ta+=a[i]; &#125; for(j=1;j&lt;=n;j++) cin&gt;&gt;b[j]; for(k=1;k&lt;=n;k++) &#123; for(i=ta;i&gt;=0;i--) &#123; if(i&gt;=a[k]) t[i]=min(t[i-a[k]],t[i]+b[k]); else t[i]=t[i]+b[k]; &#125; &#125; int ans=10000; for(i=0;i&lt;=ta;i++) &#123; ans=min(ans,max(i,t[i])); &#125; printf("%d\n",ans); return 0;&#125; Arbitrage套汇是指利用货币汇兑率的差异将一个单位的某种货币转换为大于一个单位的同种货币。例如，假定1 美元可以买0.7 英镑，1 英镑可以买9.5 法郎，且1 法郎可以买到0.16美元。通过货币兑换，一个商人可以从1 美元开始买入，得到0.7×9.5×0.16=1.064美元，从而获得6.4%的利润。 给定n 种货币c1 ,c2 ,… ,cn的有关兑换率，试设计一个有效算法，用以确定是否存在套汇的可能性。 输入 含多个测试数据项。每个测试数据项的第一行中只有1 个整数n (1&lt; =n&lt; =30)，表示货币总数。其后n行给出n种货币的名称。接下来的一行中 有1 个整数m，表示有m种不同的货币兑换率。其后m行给出m种不同的货币兑换率，每行有3 个数据项ci ， rij 和cj ，表示货币ci 和cj的兑换率为 rij。文件最后以数字0 结束。 输出 对每个测试数据项j，如果存在套汇的可能性则输出“Case j Yes”， 否则输出“Case j No”。 样例输入 3USDollarBritishPoundFrenchFranc3USDollar 0.5 BritishPoundBritishPound 10.0 FrenchFrancFrenchFranc 0.21 USDollar3USDollarBritishPoundFrenchFranc6USDollar 0.5 BritishPoundUSDollar 4.9 FrenchFrancBritishPound 10.0 FrenchFrancBritishPound 1.99 USDollarFrenchFranc 0.09 BritishPoundFrenchFranc 0.19 USDollar0 样例输出 Case 1 YesCase 2 No 题目解读代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define max(a,b) a&gt;b?a:bint main() &#123; int n, m, i, j, k, cnt = 1; float x, rank[31][31]; while (cin &gt;&gt; n&amp;&amp;n) &#123; char name[31][25], cinA[25], cinB[25]; for (i = 0; i &lt; n; i++) cin &gt;&gt; name[i]; memset(rank, 0.0, sizeof(rank)); cin &gt;&gt; m; for (i = 0; i &lt; m; i++) &#123; cin &gt;&gt; cinA &gt;&gt; x &gt;&gt; cinB; for (j = 0; strcmp(cinA, name[j]); j++); for (k = 0; strcmp(cinB, name[k]); k++); rank[j][k] = x; &#125; for (i = 0; i &lt; n; i++) rank[i][i] = max(1.0, rank[i][i]);//自身汇率为1 for (k = 0; k &lt; n; k++) for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) rank[i][j] = max(rank[i][j], rank[i][k] * rank[k][j]); for (i = 0; i &lt; n; i++) if (rank[i][i]&gt;1.0) break; if (i &lt; n)//找到一个就成立 cout &lt;&lt; "Case " &lt;&lt; cnt++ &lt;&lt; " Yes" &lt;&lt; endl; else cout &lt;&lt; "Case " &lt;&lt; cnt++ &lt;&lt; " No" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记3]]></title>
    <url>%2F2018%2F05%2F26%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[第三章的学习笔记 第三章 递归递归的核心思想现在有一个盒子，盒子里还有盒子，要找到藏在某个盒子里的钥匙。 非递归思想（循环）： 递归思想： 简单来说：递归的思想就是函数自己调用自己。 基线条件和递归条件编写函数时，必须告诉它何时停止递归。正因如此，每个递归函数都有两个部分：基线条件和递归条件。递归条件指的是函数调用自己，而基线条件则值的是函数不再调用自己，从而避免形成无限循环。 递归求阶乘12345def factorial(x): if (x == 1): return 1 else: return x * factorial(x-1)]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记2]]></title>
    <url>%2F2018%2F05%2F24%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[第二章的学习笔记 第二章 选择排序 本章主要学习两种最基本的数据结构——数组和链表。 同时还要学习一种排序算法——选择排序。 数组和链表数组对于数组来说，随机的读取元素时很高效，因为直接根据数组的下标就可以找到对应的元素。 但是数组的不便之处在于，需要提前申明数组的大小，如果需要存的数据量大于申明的数组大小，就无法存储多余的数据，如果用不完就会造成一定的内存浪费。 数组的另外一个不足之处就是，不便于进行插入、删除操作。如果要在数组的中间插入一个元素，要先将它后面的数据整体向后移动一个位置，才能插入新的元素，效率低下。 链表链表无需申明长度，可以随意进行元素的添加，在链表中，每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一次。这种数据结构的优势就是，便于进行插入、删除操作，只需将上一个元素存储的下一个元素地址指向待插入的元素地址，再把待插入的元素存储下一个元素地址，就完成了插入操作，比数组方便很多。 但是反过来，链表就不便于进行随机地读取元素了，因为并不知道待查找的元素的位置，所以需要一个一个的查，直到找到为止。 数组 链表 读取 O(1) O(n) 插入 O(n) O(1) 删除 O(n) O(1) O(n) = 线性时间 O(n) = 常量时间 总结数组和链表哪个用的更多呢？需要看具体情况。 有两种访问方式：随机访问和顺序访问。 顺序访问意味着从一个元素开始逐个地址读取元素，链表只能顺序访问。 随机访问意味着可以直接跳到第10个元素，数组可以随机访问。 因为在大部分情况下，我们需要随机访问，所以还是数组使用的更多。 选择排序既然是排序算法，就是给出一串无序的数组，然后编程使他们按照从小到大或者从大到小的顺序排列。 核心思想选择排序的思想很简单：首先找到所有数里最小的元素，把它存放在新的数组中，然后再在剩下的（n-1）个元素中找到最小的元素，并存放在新数组里面，以此类推，每次都在剩下的数中挑选出最小的存成新的数组，直到选完为止。 python代码1234567891011121314151617181920def findSmallest(arr): smallest = arr[0] #存储最小的值 smallest_index = 0 #存储最小值的索引 for i in range(1,len(arr)): if(arr[i] &lt; smallest): smallest = arr[i] smallest_index = i return smallest_indexdef selection_sort(arr): newArr = [] for i in range(len(arr)): smallest_index = findSmallest(arr) newArr.append(arr.pop(smallest_index)) #每次都找到最小的元素存入新数组，并在原来数组里删除掉 return newArrif __name__ == '__main__': print(selection_sort([5,3,6,2,10])) C/C++代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;void selection_sort(int *arr,int len)&#123; int i,j,min; for(i=0;i&lt;len-1;i++) &#123; min=i; for(j=i;j&lt;len;j++) &#123; if(arr[j]&lt;arr[min]) min=j; &#125; if(min!=i) &#123; int t=arr[min]; arr[min]=arr[i]; arr[i]=t; &#125; &#125;&#125;int main()&#123; int arr[5]=&#123;5,3,6,2,10&#125;; selection_sort(arr,5); for(int i=0;i&lt;5;i++) &#123; cout&lt;&lt;arr[i]&lt;&lt;" "; &#125; return 0;&#125; 时间复杂度每比较一次，就需要遍历一遍数组，所以每一次比较的时间复杂度都是O(n)，需要比较n次，所以选择排序的时间复杂度是O(n2)。 遗留问题： 随着排序的进行，每次需要比较的元素数在减小，最后一次需要检查的元素都只有一个，为什么是n个O(n)呢？ 因为平均每次检查的元素个数为n/2,因此运行时间为O(n * n/2)，但是大O表示法省略诸如1/2这样的常数，因此简写为O(n)。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《算法图解》学习笔记1]]></title>
    <url>%2F2018%2F05%2F22%2F%E3%80%8A%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[《算法图解》像小说一样有趣的算法入门书，作者推崇图解式写作风格，生动易读。就我个人而言，算法一直是弱项，这次想花一个月的时间，坚持打卡学习，争取能在算法能力上取得一定的提升。 本书采用python语言编写，由于大部分ACM程序设计大赛都是用C/C++或java，所以我不仅用python编写，还会尽量用C/C++写代码。 第一章 算法简介二分查找算法定义二分查找，也叫折半查找，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 举例举个例子，给出一串有序数组：[10,20,30,40,50,60,70,80,90] 编号 1 2 3 4 5 6 7 8 9 数字 10 20 30 40 50 60 70 80 90 现在想要寻找80在哪个位置，蛮力法即是循环遍历数组中的每个元素，当遍历到的元素正好等于80时，就找到了，对于这个数组，需要查询8次。 而二分法的思想是，先看中间第5号元素是多少，结果是50，这样就把前面5个元素排除掉了，因为要找的90比50还大；现在只需要在5号到10号中间选，再挑选中间的7号元素查看，发现是70，还是比90小，那么前7个元素都被排除了；再在7到9之间选中间的8号元素查看，正好是80，就找到了，只查询了3次。 可以想象，随着元素的增多，二分法查找的效率会明显高于蛮力法，这就是二分法查找算法的优势。 代码实例python代码： 1234567891011121314151617181920212223242526def binary_search(list,item): #用low和high代表需要查找的区间范围 low = 0 high = len(list) - 1 while(low&lt;=high): #只要范围没有缩小到只剩一个元素 mid = (low + high) // 2 #中间的元素 #（"//"运算符代表取整除，返回商的整数部分，否则如果是小数，就无法在数组中查询了） guess = list[mid] #查看中间元素对应的值 if(guess == item): #找到了 return mid if(guess &gt; item): #猜大了 high = mid - 1 else: #猜小了 low = mid + 1 return None #没找到if __name__ == '__main__': my_list = [1,3,5,7,9] print(binary_search(my_list, 3)) print(binary_search(my_list, -1))"""1None""" C/C++代码： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int arr[5]=&#123;1,3,5,7,9&#125;;int binary_search(int n,int item) //传入数组的长度和需要查找的值&#123; int low = 0,high = n-1; while(low&lt;=high) &#123; int mid = (low + high) / 2; if(arr[mid]==item) &#123; return mid; break; &#125; if(arr[mid]&gt; item) high=mid-1; if(arr[mid]&lt; item) low=mid+1; &#125; return -1;&#125;int main()&#123; printf("%d\n",binary_search(5,3)); printf("%d\n",binary_search(5,-1)); return 0;&#125; 大O表示法 在计算机科学中，算法的时间复杂度是一个函数，它定性描述该算法的运行时间，这是一个代表算法输入值的字符串的长度的函数。时间复杂度通常用大O表示。 引入下面做一个实验，分别比较同种操作系统下、同种规模的数据量（1到105、106、107），二分法和蛮力查找最后一个元素时，所花费的时间。 python中计算运行时间的方法： 1234import timet0 = time.clock()binary_search(list,item)print("process time:", time.clock() - t0) python中蛮力法遍历查找的代码如下： 12345678910def rude_search(num_list,item): for index,element in enumerate(num_list): if(element == item): return index return Noneif __name__ == '__main__': my_list = [1,3,5,7,9] print(rude_search(my_list, 3)) print(rude_search(my_list, -1)) 下面是运行时间的比较,我们做出曲线图： 这时我们就会发现一个问题，仅知道算法需要多长时间才能运行完毕还不够，还需要知道运行时间如何随列表增长而增加，这正是大O的用武之地。 大O大O指出了算法有多快。例如，假设列表有n个元素，蛮力法查找需要检查每个元素，因此需要（最多）执行n次操作。使用大O表示法，这个运行时间为O(n)，没有单位，因为大O表示法让你能够比较操作次数，它指出了算法运行时间的增速。 常见的大O运行时间 名称 时间复杂度 算法举例 对数时间 O(log n) 二分查找 线性时间 O(n) 遍历数组 线性迭代对数时间 O(n * log n) 快速排序 二次时间 O(n2) 选择排序 阶乘时间 O(n!) 旅行商问题]]></content>
      <categories>
        <category>学习笔记</category>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划（上）]]></title>
    <url>%2F2018%2F05%2F19%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[动态规划（英语：Dynamic programming，简称DP） 常常适用于有重叠子问题 和最优子性质的问题。 动态规划（上）动态规划（英语：Dynamic programming，简称DP） 常常适用于有重叠子问题 和最优子性质的问题。 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 斐波那契数列斐波那契数列可以以递归的方式来定义： F0 = 0 F1 = 1 Fn = Fn-1 + Fn-2 （n&gt;=2) 用文字来说，就是斐波那契数列由0和1开始，之后的数就是前面连个数之和：0,1,1,2,3,5,8,13…… 求解斐波那契数列时，可以直接使用递归的定义方法： 12345int fib(n)&#123; if(n==0 || n==1) return n; return fib(n-1)+fib(n-2);&#125; 这样的定义方式便于理解，但是有一个问题：对于相似的子问题进行了大量重复的计算，例如在求fib(5)时，经历了这样的步骤： fib(5) fib(4) + fib(3) ( fib(3) + fib(2) ) + ( fib(2) + fib(1) ) [ ( fib(2) + fib(1) ) + ( fib(1) + fib(0) ) ] + [ ( fib(1) + fib(0) ) + fib(1) ] [ ( ( fib(1) + fib(0) ) + fib(1) ) + ( fib(1) + fib(0) ) ] + [ ( fib(1) + fib(0) ) + fib(1) ] 由这个过程可以看出，这样递归的方法会重复计算多次fib(2)、fib(3)，因此效率很低，如果将前n个已经计算出来了的 fib(i) 存在一个数组中，这样在后面的计算中，就可以直接调用数组中存储的值，而避免了重复计算。这种思想就是动态规划的思想。 1234567int dp[1005];int fib(n)&#123; if(n==0) dp[n]=0; if(n==1) dp[n]=1; dp[n]=dp[n-1]+dp[n-2];&#125; 收集硬币问题有一串数字，现在需要取出一些数组，取数规则就是不能选两个相邻的数。现在需要计算在这种规则下，能取到的数字之和最大是多少。 例如以下这一串数字： 编号 0 1 2 3 4 5 num 5 1 2 10 6 2 现在定义一个数组dp[ ],dp[i]代表选择到第i个硬币时，能得到的最大金额数。 以dp[5]为例，此时有两种选择： 选5号（那就不能选4号）：dp[3]+num[5] 不选5号（就可以选4号）：dp[4] 这样就可以推导出状态方程：$$\begin{cases}dp[i] = max( dp[i-2] + num[i] , dp[i-1] )\dp[0] = num[0]\dp[1] = max( num[0], num[1] )\end{cases}$$这样就可以敲代码了，如果使用递归的方法，会产生很多重叠子问题，运算速度慢，效率为O(n^2^)。所以不使用递归方法，而是建立一个dp数组，然后循环填表，一次把dp[0],dp[1],dp[2]……的值计算出来，最后最优解即是dp[n-1]。 代码 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define max(a,b) ((a&gt;b)?a:b)int main()&#123; int num[10000],dp[10000]=&#123;0&#125;; int n,i; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;num[i]; &#125; dp[0]=num[0]; dp[1]=max(num[0],num[1]); for(i=2;i&lt;n;i++) &#123; dp[i]=max(dp[i-2]+num[i],dp[i-1]); &#125; printf("%d\r\n",dp[n-1]); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv-python人脸识别应用]]></title>
    <url>%2F2018%2F05%2F08%2Fopencv-python%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[利用OpenCV和python环境实现简单的人脸识别应用：识别人脸并框处人脸、检测并框处人的眼睛、检测笑脸、并框处笑脸。 环境准备 系统环境：win7 python版本：python3.6.3 已存在vs2015（OpenCV需要C++环境） OpenCV 关于OpenCV自带的分类器OpenCV 是一个跨平台的计算机视觉库，它实现了图像处理和计算机视觉方面的很多通用算法，是一个非常强大的开源库。 OpenCV项目源码中有很多训练好的Haar分类器。 这些xml文件是已经训练好的数据，可以直接调用，进而达到识别分类的功能。本文不训练数据，直接使用这些OpenCV库中自带的方法进行人脸识别。 找到图像中人脸的位置1234567891011121314151617#detectFaces()返回图像中所有人脸的矩形坐标（矩形左上、右下顶点）#使用haar特征的级联分类器haarcascade_frontalface_default.xml，在haarcascades目录下还有其他的训练好的xml文件可供选择。#注：haarcascades目录下训练好的分类器必须以灰度图作为输入。def detectFaces(image_name): img = cv2.imread(image_name) face_cascade = cv2.CascadeClassifier("D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_frontalface_default.xml") #分类器函数中的参数就是xml文件的具体位置 if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 faces = face_cascade.detectMultiScale(gray, 1.2, 5)#1.3和5是特征的最小、最大检测窗口，它改变检测结果也会改变 result = [] for (x,y,width,height) in faces: result.append((x,y,x+width,y+height)) return result 函数最终返回一个列表，包含识别出来的人脸的左上、右上、左下、右下4个定点的坐标。 框出人脸123456789101112#在原图像上画矩形，框出所有人脸。#调用Image模块的draw方法，Image.open获取图像句柄，ImageDraw.Draw获取该图像的draw实例，然后调用该draw实例的rectangle方法画矩形(矩形的坐标即#detectFaces返回的坐标)，outline是矩形线条颜色(B,G,R)。#注：原始图像如果是灰度图，则去掉outline，因为灰度图没有RGB可言。drawEyes、detectSmiles也一样。def drawFaces(image_name): faces = detectFaces(image_name) if faces: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in faces: draw_instance.rectangle((x1,y1,x2,y2), outline=(255, 0,0)) img.save('drawfaces_'+image_name) 效果如图，可以看到正面人脸都被识别出来了，有一处判断错误的地方。 检测眼睛12345678910111213141516#检测眼睛，返回坐标#由于眼睛在人脸上，我们往往是先检测出人脸，再细入地检测眼睛。故detectEyes可在detectFaces基础上来进行，代码中需要注意“相对坐标”。#当然也可以在整张图片上直接使用分类器,这种方法代码跟detectFaces一样，这里不多说。def detectEyes(image_name): eye_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_eye.xml') faces = detectFaces(image_name) img = cv2.imread(image_name) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) result = [] for (x1,y1,x2,y2) in faces: roi_gray = gray[y1:y2, x1:x2] eyes = eye_cascade.detectMultiScale(roi_gray,1.3,2) for (ex,ey,ew,eh) in eyes: result.append((x1+ex,y1+ey,x1+ex+ew,y1+ey+eh)) return result 使用眼睛的分类器进行分类，将四个顶点的坐标保存在列表里。 框出眼睛123456789#在原图像上框出眼睛.def drawEyes(image_name): eyes = detectEyes(image_name) if eyes: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in eyes: draw_instance.rectangle((x1,y1,x2,y2), outline=(0, 0,255)) img.save('draweyes_'+image_name) 效果如图，识别的还不算太精准： 检验笑脸1234567891011121314#检测笑脸def detectSmiles(image_name): img = cv2.imread(image_name) smiles_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_smile.xml') if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 smiles = smiles_cascade.detectMultiScale(gray,4,5) result = [] for (x,y,width,height) in smiles: result.append((x,y,x+width,y+height)) return result 框出笑脸123456789#在原图像上框出笑脸def drawSmiles(image_name): smiles = detectSmiles(image_name) if smiles: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in smiles: draw_instance.rectangle((x1,y1,x2,y2), outline=(100, 100,0)) img.save('drawsmiles_'+image_name) 效果如图： 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import osimport cv2from PIL import Image,ImageDraw#detectFaces()返回图像中所有人脸的矩形坐标（矩形左上、右下顶点）#使用haar特征的级联分类器haarcascade_frontalface_default.xml，在haarcascades目录下还有其他的训练好的xml文件可供选择。#注：haarcascades目录下训练好的分类器必须以灰度图作为输入。def detectFaces(image_name): img = cv2.imread(image_name) face_cascade = cv2.CascadeClassifier("D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_frontalface_default.xml") if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 faces = face_cascade.detectMultiScale(gray, 1.2, 5)#1.3和5是特征的最小、最大检测窗口，它改变检测结果也会改变 result = [] for (x,y,width,height) in faces: result.append((x,y,x+width,y+height)) return result#保存人脸图def saveFaces(image_name): faces = detectFaces(image_name) if faces: #将人脸保存在save_dir目录下。 #Image模块：Image.open获取图像句柄，crop剪切图像(剪切的区域就是detectFaces返回的坐标)，save保存。 save_dir = image_name.split('.')[0]+"_faces" os.mkdir(save_dir) count = 0 for (x1,y1,x2,y2) in faces: file_name = os.path.join(save_dir,str(count)+".jpg") Image.open(image_name).crop((x1,y1,x2,y2)).save(file_name) count+=1#在原图像上画矩形，框出所有人脸。#调用Image模块的draw方法，Image.open获取图像句柄，ImageDraw.Draw获取该图像的draw实例，然后调用该draw实例的rectangle方法画矩形(矩形的坐标即#detectFaces返回的坐标)，outline是矩形线条颜色(B,G,R)。#注：原始图像如果是灰度图，则去掉outline，因为灰度图没有RGB可言。drawEyes、detectSmiles也一样。def drawFaces(image_name): faces = detectFaces(image_name) if faces: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in faces: draw_instance.rectangle((x1,y1,x2,y2), outline=(255, 0,0)) img.save('drawfaces_'+image_name)#检测眼睛，返回坐标#由于眼睛在人脸上，我们往往是先检测出人脸，再细入地检测眼睛。故detectEyes可在detectFaces基础上来进行，代码中需要注意“相对坐标”。#当然也可以在整张图片上直接使用分类器,这种方法代码跟detectFaces一样，这里不多说。def detectEyes(image_name): eye_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_eye.xml') faces = detectFaces(image_name) img = cv2.imread(image_name) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) result = [] for (x1,y1,x2,y2) in faces: roi_gray = gray[y1:y2, x1:x2] eyes = eye_cascade.detectMultiScale(roi_gray,1.3,2) for (ex,ey,ew,eh) in eyes: result.append((x1+ex,y1+ey,x1+ex+ew,y1+ey+eh)) return result#在原图像上框出眼睛.def drawEyes(image_name): eyes = detectEyes(image_name) if eyes: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in eyes: draw_instance.rectangle((x1,y1,x2,y2), outline=(0, 0,255)) img.save('draweyes_'+image_name)#检测笑脸def detectSmiles(image_name): img = cv2.imread(image_name) smiles_cascade = cv2.CascadeClassifier('D:\OpenCV Library\opencv\sources\data\haarcascades\haarcascade_smile.xml') if img.ndim == 3: gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) else: gray = img #if语句：如果img维度为3，说明不是灰度图，先转化为灰度图gray，如果不为3，也就是2，原图就是灰度图 smiles = smiles_cascade.detectMultiScale(gray,4,5) result = [] for (x,y,width,height) in smiles: result.append((x,y,x+width,y+height)) return result#在原图像上框出笑脸def drawSmiles(image_name): smiles = detectSmiles(image_name) if smiles: img = Image.open(image_name) draw_instance = ImageDraw.Draw(img) for (x1,y1,x2,y2) in smiles: draw_instance.rectangle((x1,y1,x2,y2), outline=(100, 100,0)) img.save('drawsmiles_'+image_name)if __name__ == '__main__': drawFaces('obama.jpg') drawEyes('obama.jpg') drawSmiles('obama.jpg') saveFaces('obama.jpg')"""上面的代码将眼睛、人脸、笑脸在不同的图像上框出，如果需要在同一张图像上框出，改一下代码就可以了。总之，利用opencv里训练好的haar特征的xml文件，在图片上检测出人脸的坐标，利用这个坐标，我们可以将人脸区域剪切保存，也可以在原图上将人脸框出。剪切保存人脸以及用矩形工具框出人脸，本程序使用的是PIL里的Image、ImageDraw模块。此外，opencv里面也有画矩形的模块，同样可以用来框出人脸。""" 总结OpenCV自带的分类器使用起来比较简单，对于标准的人脸图片识别的准确率比较高，但是也有误判的现象，特别是笑脸的判断不够精准，还有待完善。 后期可以使用OpenCV制作分类器，大致分为3步： 制作训练集的数据集 训练分类器 使用分类器进行分类]]></content>
      <categories>
        <category>onpencv</category>
      </categories>
      <tags>
        <tag>图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验三]]></title>
    <url>%2F2018%2F05%2F04%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验三 简单背包问题设有一个背包可以放入的物品重量为S，现有n件物品，重量分别是w1，w2，w3，…wn。 问能否从这n件物品中选择若干件放入背包中，使得放入的重量之和正好为S。 如果有满足条件的选择，则此背包有解，否则此背包问题无解。 输入 输入数据有多行，假设背包可以放入的物品重量为S，物品的件数n，以及每件物品的重量（输入数据均为正整数）。多组测试数据。 输出 对于每个测试实例，若满足条件则输出“YES”，若不满足则输出“NO“。 样例输入 20 51 3 5 7 9 样例输出 YES 题目解读思想就是先把所有的物品都放入背包，然后再一件一件的往外拿，当拿出之后： 当背包被取空了时，就表明有解； 当拿完所有物品后，背包质量还不等于weight，就无解； 当第n个物品没有取出，而n-1个被取出时，背包的质量等于weight，就有解。 假设第n－1个物品取出来了，依然往下取，这时背包的weight变成weight-data[n]。 代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int data[1005];int bag(int weight,int n)&#123; if(weight==0) return 1; if(n==0 &amp;&amp; weight!=0) return 0; if(bag(weight,n-1)==1) return 1; return bag(weight-data[n],n-1);&#125;int main()&#123; int weight,n; while(scanf("%d %d",&amp;weight,&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;data[i]); &#125; if(bag(weight,n)==1) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; Buyer哆啦A梦班级举办个party，当然吃的东西必不可少，哆啦A梦负责采购任务，他得到了一份清单，上面注明不同食品的受欢迎程度，哆啦A梦需要用一定的价钱尽可能达到的更大的受欢迎程度！例如，瓜子的受欢迎程度为20，瓜子的价钱是50元，那么如果哆啦A梦选择买瓜子，将花费50元，但受欢迎程度增加了20。为了避免食品单调性，每种食品只能买一份，不能重复购买。 现在哆啦A梦需要知道如何采购才能达到最大的受欢迎程度，你能帮助他吗？ 输入 输入数据为多组，每组输入的第一行有两个正整数M和N(M&lt;100&amp;&amp;N&lt;1000)，分别为哆啦A梦可以支配的钱数和清单上的可选择的物品种类。 接下来的N行每行有两个正整数,分别为每种物品的价钱和它的受欢迎程度（编号为1到N）。 输出 如果存在物品购买，那么输出的第一行为能够达到的最大的受欢迎程度。第二行为需要购买的物品的编号（如果有多种可能，输出字典序靠前的那种），空格分隔每个数字；如没有物品可以购买，输出只有一行，为数字0。 样例输入 10 4100 55 55 510 10 样例输出 102 3 题目解读这道题就是01背包问题，金额限定M代表背包的容量，每种物品的价格代表物品的重量w[ ]，每种物品的价值用v[ ]表示。 动态规划求解构造一个二维数组dp[N][M]，N行（N个物品),M列（M为容量能使用的最大金额)。二维数组dp[i][j]的含义是：当拿到第i个物品，不超过金额 j 时的最大价值。一行一行的循环填表： 如果当前的限额超过了该物品的价值，表示可以取该物品,需要选择最优解： 如果不取，当前价值为dp[i-1][j] 如果取，当前价值为dp[i-1][ j-w[i] ]+v[i]（指考虑了i-1件物品，背包容量为 j-w[i] 时的价值加上拿取的这件物品的价值） 如果当前的限额低于这件物品的价值，就不能拿取这个物品： 当前价值为dp[i-1][j] 12345678910for(i=1;i&lt;=N;i++)&#123; for(j=1;j&lt;=M;j++) &#123; if(j&gt;=w[i]) dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); else dp[i][j]=dp[i-1][j]; &#125;&#125; 回溯检验是否取了物品另外创建一个一维数组x[N]，下标代表物品对应的编号，0代表没有取，1代表取了。 由于dp[i][M]为最优解，如果dp[i][M]=dp[i-1][M]，那就说明有没有第i件物品都一样，那么x[i]=0，否则x[i]=1。 1234567891011121314void traceback(int M,int N) &#123; for(int i=N;i&gt;1;i--) &#123; if(dp[i][M]==dp[i-1][M]) x[i]=0; else &#123; x[i]=1; M-=w[i]; &#125; &#125; x[1]=(dp[1][M]&gt;0)?1:0; &#125; 输出问题（小心PE） 首先输出一行最大价值，换行； 然后输出取出来的物品，中间用一个空格隔开，注意最后一个数后面没有空格，而是换行； 多组输入，所以当最大价值为0时，输出0然后continue再次进入新的循环 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int dp[1005][1005]=&#123;0&#125;;int x[1005];int v[1005],w[1005];void traceback(int M,int N) &#123; for(int i=N;i&gt;1;i--) &#123; if(dp[i][M]==dp[i-1][M]) x[i]=0; else &#123; x[i]=1; M-=w[i]; &#125; &#125; x[1]=(dp[1][M]&gt;0)?1:0; &#125; int main()&#123; int M,N,i,j; while(scanf("%d %d",&amp;M,&amp;N)!=EOF) &#123; for(i=1;i&lt;=N;i++) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; &#125; for(i=1;i&lt;=N;i++) &#123; for(j=1;j&lt;=M;j++) &#123; if(j&gt;=w[i]) dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]); else dp[i][j]=dp[i-1][j]; &#125; &#125; traceback(M,N); int sum=0; for(i=1;i&lt;=N;i++) &#123; if(x[i]==1) sum+=v[i]; &#125; if(sum==0) &#123; cout&lt;&lt;"0"&lt;&lt;endl; continue; &#125; cout&lt;&lt;sum&lt;&lt;endl; int flag=0; for(i=1;i&lt;=N;i++) &#123; if(x[i]==1 &amp;&amp; flag==0) &#123; cout&lt;&lt;i; flag=1; &#125; else if(x[i]==1 &amp;&amp; flag==1) cout&lt;&lt;" "&lt;&lt;i; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 售货员的难题某乡有n个村庄（1&lt; n &lt; 20），有一个售货员，他要到各个村庄去售货，各村庄之间的路程s（0 &lt; s &lt; 1000）是已知的，且A村到B村与B村到A村的路大多不同。为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，假设商店所在的村庄为 1，他不知道选择什么样的路线才能使所走的路程最短。请你帮他选择一条最短的路。 输入 村庄数n和各村之间的路程（均是整数）。 输出 最短的路径 样例输入 3 {村庄数}0 2 1 {村庄1到各村的路程}1 0 2 {村庄2到各村的路程}2 1 0 {村庄3到各村的路程} 样例输出 3 题目解读代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;#define maxn 25int INF=12345678;int n,maps[maxn][maxn];int d[maxn][maxn];int vis[1005];void Floyd()&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(d[i][j]&gt;d[i][k]+d[k][j]) d[i][j]=d[i][k]+d[k][j];&#125;void dfs(int x,int dis,int cnt)//x:current position&#123; if(x==1 &amp;&amp; cnt==n) &#123; INF=min(INF,dis); return; &#125; vis[x]=1; for(int i=1;i&lt;=n;i++) if((dis+maps[x][i]+d[i][1]&lt;INF) &amp;&amp; ((vis[i]==0) || (cnt==n-1 &amp;&amp; i==1))) dfs(i,dis+maps[x][i],cnt+1); vis[x]=0;&#125;int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;maps[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) d[i][j]=maps[i][j]; memset(vis,0,sizeof(vis)); Floyd(); dfs(1,0,0); printf("%d\n",INF); &#125; return 0;&#125; 跑跑卡丁车跑跑卡丁车是时下一款流行的网络休闲游戏，你可以在这虚拟的世界里体验驾驶的乐趣。这款游戏的特别之处是你可以通过漂移来获得一种 加速卡，用这种加速卡可以在有限的时间里提高你的速度。为了使问题简单化，我们假设一个赛道分为L段，并且给你通过每段赛道的普通耗时Ai和用加速卡的耗时Bi。加速卡的获得机制是：普通行驶的情况下，每通过1段赛道,可以获得20%的能量(N2O).能量集满后获得一个加速卡(同时能量清0).加速卡最多可以储存2个,也就是说当你有2个加速卡而能量再次集满,那么能量清零但得不到加速卡。一个加速卡只能维持一段赛道，游戏开始时没有加速卡。问题是，跑完n圈最少用时为多少？ 输入 每组输入数据有3行，第一行有2个整数L( 0 &lt; L &lt; 100),N(0 &lt; N &lt; 100)分别表示一圈赛道分为L段和有N圈赛道，接下来两行分别有L个整数Ai和Bi (Ai &gt; Bi). 输出 对于每组输入数据，输出一个整数表示最少的用时. 样例输入 18 19 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 98 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8 样例输出 145 题目解读代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int INF=0x3f3f3f3f;int dp[10005][15],a[105],b[105],n,m;int main() &#123; while(cin&gt;&gt;n&gt;&gt;m) &#123; for(int i=0; i&lt;n; i++) cin&gt;&gt;a[i]; for(int i=0; i&lt;n; i++) cin&gt;&gt;b[i]; for(int i=0; i&lt;n*m; i++) &#123; a[i]=a[i%n]; b[i]=b[i%n]; &#125; memset(dp,INF,sizeof(dp)); dp[1][1]=a[0]; for(int i=1; i&lt;n*m; i++) &#123; for(int j=0; j&lt;15; j++) &#123; int k=j+1; if(k==15) k=10; dp[i+1][k]=min(dp[i+1][k],dp[i][j]+a[i]); if(j&gt;=5) dp[i+1][j-5]=min(dp[i+1][j-5],dp[i][j]+b[i]); &#125; &#125; int ans=INF; for(int i=0; i&lt;15; i++) ans=min(ans,dp[n*m][i]); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; Renting Boats长江游艇俱乐部在长江上设置了n 个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt; =i&lt; j &lt; =n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n 所需的最少租金。 输入 第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的n-1 行是r(i,j),1&lt; =i&lt; j &lt; =n。 输出 从游艇出租站1 到游艇出租站n所需的最少租金 样例输入 35 157 样例输出 12 题目解读此题可以用Floyd-Warshall算法算法解决，Floyd算法是解决两点间的最短路径的一种算法。Floyd算法的原理是动态规划。 算法思想:如果存在定点k，使得以k做为中介点时，顶点i和顶点j之间的当前距离缩短，则使用顶点k做为顶点i和顶点j之间的中介点，即当dis[i][k] + dis[k][j] &lt; dis[i][j] 时，令 dis[i][j]=dis[i][k] + dis[k][j] 。 算法流程： 枚举顶点k 以顶点k做为中介点，枚举所有顶点i和j 如果dis[i][k] + dis[k][j] &lt; dis[i][j]成立，则 dis[i][j]=dis[i][k] + dis[k][j] 代码 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int dis[205][205]=&#123;0&#125;;int n;int Floyd()&#123; for(int k=0;k&lt;n;k++) for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) if(dis[i][k]!=0 &amp;&amp; dis[k][j]!=0 &amp;&amp; dis[i][k]+dis[k][j]&lt;dis[i][j]) dis[i][j]=dis[i][k]+dis[k][j];&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i=0;i&lt;n;i++) &#123; for(int j=i+1;j&lt;n;j++) &#123; cin&gt;&gt;dis[i][j]; &#125; &#125; Floyd(); cout&lt;&lt;dis[0][n-1]&lt;&lt;endl; &#125; return 0;&#125; Jack Strawsn the game of Jack Straws, a number of plastic or wooden “straws” are dumped on the table and players try to remove them one-by-one without disturbing the other straws. Here, we are only concerned with if various pairs of straws are connected by a path of touching straws. You will be given a list of the endpoints for some straws (as if they were dumped on a large piece of graph paper) and then will be asked if various pairs of straws are connected. Note that touching is connecting, but also two straws can be connected indirectly via other connected straws. 输入 A problem consists of multiple lines of input. The first line will be an integer n (1 &lt; n &lt; 13) giving the number of straws on the table. Each of the next n lines contain 4 positive integers, x1 , y1 , x2 and y2 , giving the coordinates, (x1 ; y1 ); (x2 ; y2 ) of the endpoints of a single straw. All coordinates will be less than 100. (Note that the straws will be of varying lengths.) The first straw entered will be known as straw #1, the second as straw #2, and so on. The remaining lines of input (except for the final line) will each contain two positive integers, a and b, both between 1 and n, inclusive. You are to determine if straw a can be connected to straw b. When a = 0 = b, the input is terminated. There will be no illegal input and there are no zero-length straws. 输出 You should generate a line of output for each line containing a pair a and b, except the final line where a = 0 = b. The line should say simply “CONNECTED”, if straw a is connected to straw b, or “NOT CONNECTED”, if straw a is not connected to straw b. For our purposes, a straw is considered connected to itself. 样例输入 71 6 3 34 6 4 94 5 6 71 4 3 53 5 5 55 2 6 35 4 7 21 41 63 36 72 31 30 0 样例输出 CONNECTEDNOT CONNECTEDCONNECTEDCONNECTEDNOT CONNECTEDCONNECTED 题目解读代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; int set[20]; struct Point &#123; int x1,x2,y1,y2; Point(int x1 = 0, int x2 = 0, int y1 = 0, int y2 = 0) : x1(x1),x2(x2),y1(y1),y2(y2) &#123;&#125;; void read() &#123; scanf("%d %d %d %d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); &#125; &#125;p[20]; void unit(int n) &#123; for(int i = 1; i &lt;= n; i++) set[i] = i; &#125; int find(int x) &#123; return x == set[x] ? x : set[x] = find(set[x]); &#125; int cross(int x1, int y1, int x2, int y2) &#123; return x1 * y2 - x2 * y1; &#125; int intersection(Point A, Point B) //判断直线相交 &#123; int c[4]; if(max(A.x1,A.x2) &lt; min(B.x1,B.x2) || max(A.y1,A.y2) &lt; min(B.y1,B.y2) || max(B.x1,B.x2) &lt; min(A.x1,A.x2) || max(B.y1,B.y2) &lt; min(A.y1,A.y2) ) return 0; //考虑共线不相交的情况,为快速排斥定理 /*判断两条直线是否相交,即只需判断线是否在另一条线的两端*/ c[0] = cross(A.x2 - A.x1, A.y2 - A.y1, B.x1 - A.x1, B.y1 - A.y1); c[1] = cross(A.x2 - A.x1, A.y2 - A.y1, B.x2 - A.x1, B.y2 - A.y1); c[2] = cross(B.x2 - B.x1, B.y2 - B.y1, A.x1 - B.x1, A.y1 - B.y1); c[3] = cross(B.x2 - B.x1, B.y2 - B.y1, A.x2 - B.x1, A.y2 - B.y1); if(c[0] * c[1] &lt;= 0 &amp;&amp; c[2] * c[3] &lt;= 0) return 1; //运用到了向量的叉乘和点乘的知识; return 0; &#125; int main() &#123; //freopen("in.txt","r",stdin); int n; while(~scanf("%d",&amp;n) &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; i++) p[i].read(); unit(n); for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) &#123; if(intersection(p[i],p[j])) &#123; int a = find(i); int b = find(j); if(a != b) set[a] = b; &#125; &#125; &#125; int a,b; while(~scanf("%d %d",&amp;a,&amp;b), a | b) &#123; a = find(a); b = find(b); if(a == b) puts("CONNECTED"); else puts("NOT CONNECTED"); &#125; &#125; return 0; &#125; Coin-collecting by robotSeveral coins are placed in cells of an n×m board. A robot, located in the upper left cell of the board, needs to collect as many of the coins as possible and bring them to the bottom right cell. On each step, the robot can move either one cell to the right or one cell down from its current location. 输入 The fist line is n,m, which 1&lt; = n,m &lt;= 1000.Then, have n row and m col, which has a coin in cell, the cell number is 1, otherwise is 0. 输出 The max number Coin-collecting by robot. 样例输入 5 60 0 0 0 1 00 1 0 1 0 00 0 0 1 0 10 0 1 0 0 11 0 0 0 1 0 样例输出 5 题目解读题目大意 在nxm的方格中有一些硬币，用1代表有硬币，0代表没有硬币。现在让一个机器人来尽可能多的捡硬币，它从左上角出发，每次只能走一步，要么向下走，要么向右走，到右下角时结束。 编号 0 1 2 3 4 5 0 0 0 0 0 1 0 1 0 1 0 1 0 0 2 0 0 0 1 0 1 3 0 0 1 0 0 1 4 1 0 0 0 1 0 建立dp二维数组，把原始数据存入二维数组中，这时从右下角往左上角依次按行列遍历，重新计算dp[i][j]的值。计算方法就是两种选择二选一，要么向下走，要么向右走： 选择下方的数：dp[i][j] += dp[i+1][j] 选择右面的数：dp[i][j] += dp[i][j+1] 状态方程就是： dp[i][j] += max( dp[i+1][j] , dp[i][j+1] ) 最后dp[0][0]就是最大值。 代码 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define max(a,b) ((a&gt;b)?a:b)int dp[1000][1000]=&#123;0&#125;;int main()&#123; int n,m,i,j; cin&gt;&gt;n&gt;&gt;m; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;m;j++) &#123; cin&gt;&gt;dp[i][j]; &#125; &#125; for(i=n-1;i&gt;=0;i--) &#123; for(j=m-1;j&gt;=0;j--) &#123; dp[i][j] += max(dp[i+1][j],dp[i][j+1]); &#125; &#125; printf("%d\r\n",dp[0][0]); return 0;&#125; Coin-row problemThere is a row of n coins whose values are some positive integers c₁, c₂,…,cn, not necessarily distinct. The goal is to pick up the maximum amount of money subject to the constraint that no two coins adjacent in the initial row can be picked up. 输入 Two lines, the first line is n (0&lt; n &lt;=10000), and the second line is value of coin(0&lt; value &lt;= 2^32). 输出 the maximum amount of money. 样例输入 65 1 2 10 6 2 样例输出 17 题目解读题目大意 有一串数字，现在需要取出一些数组，取数规则就是不能选两个相邻的数。现在需要计算在这种规则下，能取到的数字之和最大是多少。 编号 0 1 2 3 4 5 num 5 1 2 10 6 2 dp(i)代表选择到第i个硬币时，能得到的金额数。 以dp(5)为例，此时有两种选择： 选5号（那就不能选4号）：dp(3)+num(5) 不选5号（就可以选4号）：dp(4) 这样就可以推导出状态方程： dp(i) = max( dp(i-2)+num[i] , dp(i-1) ) dp(0) = num[0] dp(1) = max( num[0] , num[1] ) 这样就可以敲代码了，如果使用递归的方法，会产生很多重叠子问题，运算速度慢，效率为O(n^2)。所以不使用递归方法，而是建立一个dp数组，然后循环填表，一次把dp[0],dp[1],dp[2]……的值计算出来，最后最优解即是dp[n-1]。 代码 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define max(a,b) ((a&gt;b)?a:b)int main()&#123; int num[10000],dp[10000]=&#123;0&#125;; int n,i; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;num[i]; &#125; dp[0]=num[0]; dp[1]=max(num[0],num[1]); for(i=2;i&lt;n;i++) &#123; dp[i]=max(dp[i-2]+num[i],dp[i-1]); &#125; printf("%d\r\n",dp[n-1]); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之sklearn]]></title>
    <url>%2F2018%2F04%2F28%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8Bsklearn%2F</url>
    <content type="text"><![CDATA[Scikit learn 也简称 sklearn, 是机器学习领域当中最知名的 python 模块之一。 Scikit learn模块Scikit learn 也简称 sklearn, 是机器学习领域当中最知名的 python 模块之一。 Sklearn 包含了很多种机器学习的方式: Classification 分类（监督学习） Regression 线性回归（监督学习） Clustering 非监督分类 Dimensionality reduction 数据降维 Model Selection 模型选择 Preprocessing 数据预处理 在股票、房价预测中可以使用线性回归。 其中蓝色圆圈内是判断条件，绿色方框内是可以选择的算法 sklearn 的使用正则化输入正则化含义解释 ： 如果输入特征属于不同范围内，可能有些特征值从0到1，有些特征值从1到1000，那么归一化（normalize）特征值就非常重要了。 具体参考吴恩达课程http://mooc.study.163.com/learn/2001281003?tid=2001391036#/learn/content?type=detail&amp;id=2001701046 12345678910# 将收盘数据正则化，全部化为-1到1之间的数import numpy as npimport pandas as pdfrom sklearn import preprocessing #标准化数据模块def normalize(): data = pd.read_csv("new_day_close.csv") data = data.iloc[:,1:] normalized = preprocessing.scale(data) print(normalized) SVR——Support Vector Regression交叉验证K-CV方法将原始数据分成K组(一般是均分),将每个子集数据分别做一次验证集,其余的K-1组子集数据作为训练集,这样会得到K个模型,用这K个模型最终的验证集的分类准确率的平均数作为此K-CV下分类器的性能指标.K一般大于等于2,实际操作时一般从3开始取,只有在原始数据集合数据量小的时候才会尝试取2.K-CV可以有效的避免过学习以及欠学习状态的发生,最后得到的结果也比较具有说服性。]]></content>
      <categories>
        <category>机器学习</category>
        <category>sklearn</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验二]]></title>
    <url>%2F2018%2F04%2F23%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验二 实验二凸包面积麦兜是个淘气的孩子。一天，他在玩钢笔的时候把墨水洒在了白色的墙上。再过一会，麦兜妈就要回来了，麦兜为了不让妈妈知道这件事情，就想用一个白色的凸多边形把墙上的墨点盖住。你能告诉麦兜最小需要面积多大的凸多边形才能把这些墨点盖住吗？ 现在，给出了这些墨点的坐标，请帮助麦兜计算出覆盖这些墨点的最小凸多边形的面积。 输入 多组测试数据。第一行是一个整数T，表明一共有T组测试数据。每组测试数据的第一行是一个正整数N(0&lt; N &lt; = 105)，表明了墨点的数量。接下来的N行每行包含了两个整数Xi和Yi（0&lt;=Xi,Yi&lt;=2000），表示每个墨点的坐标。每行的坐标间可能包含多个空格。 输出 每行输出一组测试数据的结果，只需输出最小凸多边形的面积。面积是个实数，小数点后面保留一位即可，不需要多余的空格。 样例输入 2 4 0 0 1 0 0 1 1 1 2 0 0 0 1 样例输出 1.0 0.0 题目解读代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;using namespace std;int t,n;struct node&#123; int x,y; &#125;data[110],point[110],basic;int direction(node pi,node pj,node pk)&#123; return (pj.x-pi.x)*(pk.y-pi.y)-(pj.y-pi.y)*(pk.x-pi.x);&#125;int dis(node a,node b)&#123; return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);&#125;int cmp(node pj,node pk)&#123; int k=direction(basic,pj,pk); if(k==0) return(dis(basic,pj)&gt;dis(basic,pk)); else return k&gt;0?1:0;&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; int flag=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;data[i].x&gt;&gt;data[i].y; if(data[i].y&lt;data[flag].y||(data[i].y==data[flag].y&amp;&amp;data[i].x&lt;data[flag].x)) flag=i; &#125; if(n&lt;3) &#123; cout&lt;&lt;"0.0\n"; continue; &#125; node zz=data[0]; data[0]=data[flag]; data[flag]=zz; basic=data[0]; sort(data+1,data+n,cmp); int top=0; point[top++]=data[0]; point[top++]=data[1]; point[top++]=data[2]; for(int i=3;i&lt;n;i++) &#123; while(direction(point[top-2],point[top-1],data[i])&lt;0) top--; point[top++]=data[i]; &#125; double sum=0; for(int i=1;i&lt;top-1;i++) sum+=abs(direction(point[0],point[i],point[i+1])); printf("%.1lf\n",sum/2); &#125; return 0;&#125; 变位词如果两个单词的组成字母完全相同，只是字母的排列顺序不一样，则它们就是变位词，两个单词相同也被认为是变位词。如tea 与eat , nic 与cin, ddc与dcd, abc与abc 等。你的任务就是判断它们是否是变位词。 输入 第一行一个N,表示下面有N行测试数据。每行测试数据包括两个单词，如tea eat ,它们之间用空格割开 输出 对于每个测试数据，如果它们是变位词，输出Yes,否则输出No. 样例输入 3 tea eat ddc cdd dee dde 样例输出 Yes Yes No 题目解读策略 对于两个给定字符串，先预排序，排序之后比较是否完全一样，如果完全一样就是变位词，否则不是变位词。 代码 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int n; char a[105],b[105]; scanf("%d",&amp;n); while(n--) &#123; cin&gt;&gt;a&gt;&gt;b; int len1=strlen(a); int len2=strlen(b); sort(a,a+len1); sort(b,b+len2); if(strcmp(a,b)==0) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; Quick SortQuicksort is a well-known sorting algorithm developed by C. A. R. Hoare that, on average, makes Θ(n log n) comparisons to sort n items. However, in the worst case, it makes Θ(n2) comparisons. Typically, quicksort is significantly faster in practice than other Θ(n log n) algorithms, because its inner loop can be efficiently implemented on most architectures, and in most real-world data it is possible to make design choices which minimize the possibility of requiring quadratic time. Quicksort sorts by employing a divide and conquer strategy to divide a list into two sub-lists. The steps are: 1. Pick an element, called a pivot, from the list. 2. Reorder the list so that all elements which are less than the pivot come before the pivot and so that all elements greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation. 3. Recursively sort the sub-list of lesser elements and the sub-list of greater elements. The base case of the recursion are lists of size zero or one, which are always sorted. The algorithm always terminates because it puts at least one element in its final place on each iteration (the loop invariant). Quicksort in action on a list of random numbers. The horizontal lines are pivot values. Write a program to sort ascending int number by QuickSort ,n less than 50000. 输入 two lows, the first low is numbers , less and equal than 50000. the second low is a set integer numbers 输出 a set integer numbers of sort ascending 样例输入 10 4 2 1 5 7 6 9 8 0 3 样例输出 0 1 2 3 4 5 6 7 8 9 题目解读快排算法 代码 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n,i; int a[50005]; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) &#123; scanf("%d",&amp;a[i]); &#125; sort(a,a+n); for(i=0;i&lt;n;i++) &#123; printf("%d ",a[i]); &#125; printf("\n"); return 0;&#125; PostOffice在一个按照东西和南北方向划分成规整街区的城市里，n个居民点散乱地分布在不同的街区中。用x 坐标表示东西向，用y坐标表示南北向。各居民点的位置可以由坐标(x,y)表示。 街区中任意2 点(x1,y1)和(x2,y2)之间的距离可以用数值|x1-x2|+|y1-y2|度量。 居民们希望在城市中选择建立邮局的最佳位置，使n个居民点到邮局的距离总和最小。 任务：给定n 个居民点的位置,编程计算n 个居民点到邮局的距离总和的最小值。 输入 第1 行是居民点数n，1 &lt; = n &lt; =10000。接下来n 行是居民点的位置，每行2 个整数x 和y，-10000 &lt; =x，y &lt; =10000。 输出 n 个居民点到邮局的距离总和的最小值。 样例输入 5 1 2 2 2 1 3 3 -2 3 3 样例输出 10 题目解读策略 蛮力法。循环比较每两个点之间的距离。 代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n,i,midx,midy; scanf("%d",&amp;n); int x[10005],y[10005]; for(i=0;i&lt;n;i++) &#123; scanf("%d %d",&amp;x[i],&amp;y[i]); &#125; int sum=0; sort(x,x+n); sort(y,y+n); if(n%2==0) &#123; midx=(x[n/2]+x[n/2-1])/2; midy=(y[n/2]+y[n/2-1])/2; &#125; if(n%2!=0) &#123; midx=x[n/2]; midy=y[n/2]; &#125; for(i=0;i&lt;n;i++) &#123; int dis=abs(x[i]-midx)+abs(y[i]-midy); sum+=dis; &#125; printf("%d\n",sum); return 0;&#125; 俄式乘法俄式乘法，又被称为俄国农夫法，它是对两个正整数相乘的非主流算法。假设m和n是两个正整数，我们要计算它们的积。它的主要原理如下： if n is 偶数 n m=n/2 2m else n m=(n-1)/2 2m + m 该算法只包括折半，加倍，相加等几个简单操作，因此实现速度非常快。 输入 两个正整数 n,m。 输出 n和m的乘积。 输出整个求和表达式，运算符与数字之间用一个空格隔开。 样例输入 50 65 样例输出 130 + 1040 + 2080 = 3250 题目解读代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n,m,i,k=0; int a[100]=&#123;0&#125;; scanf("%d %d",&amp;n,&amp;m); while(n&gt;1) &#123; if(n%2==0) &#123; n=n/2; m=m*2; &#125; else &#123; n=(n-1)/2; m=2*m; a[k]=m/2; k++; &#125; &#125; int sum=0; for(i=0;i&lt;k;i++) &#123; printf("%d",a[i]); printf(" + "); sum+=a[i]; &#125; printf("%d",m); printf(" = "); printf("%d\n",sum+m); return 0;&#125; 最近对问题设p1=(x1, y1), p2=(x2, y2), …, pn=(xn, yn)是平面上n个点构成的集合S，设计算法找出集合S中距离最近的点对。 输入 多组测试数据，第一行为测试数据组数n（0&lt;n≤100），每组测试数据由两个部分构成，第一部分为一个点的个数m（0&lt;m≤1000），紧接着是m行，每行为一个点的坐标x和y，用空格隔开，（0&lt;x，y≤100000） 输出 每组测试数据输出一行，为该组数据最近点的距离，保留4为小数。 样例输入 2 2 0 0 0 1 3 0 0 1 1 1 0 样例输出 1.0000 1.0000 题目解读策略 蛮力法。循环比较。 代码 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); while(n--) &#123; int m,i,j,k; scanf("%d",&amp;m); int x[1005],y[1005]; for(k=0;k&lt;m;k++) &#123; scanf("%d %d",&amp;x[k],&amp;y[k]); &#125; double min=10000; for(i=0;i&lt;m;i++) &#123; for(j=i+1;j&lt;m;j++) &#123; double a=(x[j]-x[i])*(x[j]-x[i]); double b=(y[j]-y[i])*(y[j]-y[i]); double dis=sqrt(a+b); if(dis&lt;min) min=dis; &#125; &#125; printf("%.4lf\n",min); &#125; return 0;&#125; 约瑟夫问题的实现n个人围成一个圈，每个人分别标注为1、2、…、n，要求从1号从1开始报数，报到k的人出圈，接着下一个人又从1开始报数，如此循环，直到只剩最后一个人时，该人即为胜利者。例如当n=10,k=4时，依次出列的人分别为4、8、2、7、3、10，9、1、6、5，则5号位置的人为胜利者。给定n个人，请你编程计算出最后胜利者标号数。（要求用单循环链表完成。） 输入 第一行为人数n; 第二行为报数k。 输出 输出最后胜利者的标号数。 样例输入 10 4 样例输出 5 题目解读代码 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int josephus(int n, int m)&#123; int i; int sum=0; for(i=1;i&lt;=n;i++) &#123; sum=(sum+m)%i; &#125; return sum+1;&#125;int main()&#123; int n,k; scanf("%d %d",&amp;n,&amp;k); int ans=josephus(n,k); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法分析实验一]]></title>
    <url>%2F2018%2F04%2F22%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[SWUST OJ 算法分析A（卓越软件1601）实验一 实验一Euclid’s GameStarts with two unequal positive numbers (M,N and M&gt;N) on the board. Two players move in turn. On each move, a player has to write on the board a positive number equal to the difference of two numbers already on the board; this number must be new, i.e., different from all the numbers already on the board. The player who cannot move loses the game. Should you choose to move first or second in this game? According to the above rules, there are two players play tihs game. Assumptions A write a number on the board at first, then B write it. Your task is write a program to judge the winner is A or B. 输入 Two unequal positive numbers M and N , M&gt;N (M&lt;1000000) 输出 A or B 样例输入 3 1 样例输出 A 题目解读翻译 黑板上已经有两个正数M和N（M&gt;N），两个人轮流在黑板上写数组，要求写上的数字必须是黑板上已有数字只差，而且不能重复写已经在黑板上的数字，最后一个不能写数字的人就输了。请问赢家应该先写还是后写？ 策略 如果开始时，两个数字不是倍数关系，那么从M到1所有的数都可以出现，也就是黑板上总共可以出现M个数，减掉原先写在黑板上的两个数，就可以写 M-2 个数； 如果开始时，两个数字是整数倍关系，那么只能出现[M-1N , M-2N, M-3N…]这些数，也就是黑板上总共可以出现M/N个数，减掉原来写在黑板上的两个数，就可以写 M/N-2 个数。 代码 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int a,b,sum; scanf("%d %d",&amp;a,&amp;b); if(a%b==0) sum=a/b-2; else sum=a-2; if(sum%2==0) printf("B\n"); else printf("A\n"); return 0;&#125; 翻煎饼麦兜最喜欢的食物是煎饼，每次在街上看到煎饼摊的时候都会在那里停留几分钟。最吸引麦兜还是煎饼师傅那一手熟练的翻煎饼的技术，一堆煎饼在那里，师傅只需要用铲子翻几下，就让煎饼整齐的叠在了一起。 这天，为了庆祝麦兜被保送上研究生，他从煎饼师傅那里买回来一些煎饼请客。但是麦兜买回的煎饼大小不一，麦兜太想吃煎饼了，他想吃这些煎饼中最大的那个。麦兜还知道同学们也很喜欢煎饼，为了表示他的诚意，他想让同学们先吃，麦兜最后吃，因此，麦兜想把煎饼按照从小到大的顺序叠放在一起，大的在最下面。这样麦兜就可以在最后拿到最大的那一块煎饼了。 现在请你帮助麦兜用煎饼师傅翻煎饼的方法把麦兜买的煎饼从小到大的叠在一起。煎饼师傅的方法是用铲子插入两块煎饼之间，然后将铲子上的煎饼翻一转，这样铲子上第一个煎饼就被翻到了顶上，而原来顶上的煎饼则被翻到了刚才插入铲子的地方。麦兜希望这样翻煎饼的次数最少。 输入 输入包括两行，第一行是一个整数n(1&lt;=n&lt;=1000)，表示煎饼的个数，接下来的一行有n个不相同的整数，整数间用空格隔开，每个整数表示煎饼的大小（直径），左边表示顶部，右边表示底部。 输出 输出为一行，翻煎饼的最少次数 样例输入 5 5 4 2 3 1 样例输出 4 题目解读策略 每次先找最大的，然后把最大的翻到上面，再整体翻一次，最大的就到最下面了。 一个函数找数组中最大数对应的角标； 一个函数实现翻煎饼（把num[a]到num[b]逆序排列）； 一个递归函数反复找最大值和实现翻煎饼的过程。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int num[1005];int times=0;int turn(int a,int b)&#123; int i,j; for(i=a,j=b;i&lt;j;i++,j--) &#123; int t=num[i]; num[i]=num[j]; num[j]=t; &#125; times++;&#125;int FindMax(int a,int b)&#123; int i,max=a; for(i=a;i&lt;=b;i++) &#123; if(num[i]&gt;num[max]) max=i; &#125; return max;&#125;void change(int n)&#123; if(n==0) return; int maxn=FindMax(0,n); if(maxn!=0 &amp;&amp; maxn!=n) &#123; turn(0,maxn); turn(0,n); &#125; if(maxn==0) turn(0,n); change(n-1);&#125;int main()&#123; int n,i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) &#123; scanf("%d",&amp;num[i]); &#125; change(n-1); printf("%d\n",times); return 0;&#125; Locker doorsThere are n lockers in a hallway numbered sequentially from 1 to n. Initially, all the locker doors are closed. You make n passes by the lockers, each time starting with locker #1. On the ith pass, i = 1, 2, …, n, you toggle the door of every ith locker: if the door is closed, you open it, if it is open, you close it. For example, after the first pass every door is open; on the second pass you only toggle the even-numbered lockers (#2, #4, …) so that after the second pass the even doors are closed and the odd ones are opened; the third time through you close the door of locker #3 (opened from the first pass), open the door of locker #6 (closed from the second pass), and so on. After the last pass, which locker doors are open and which are closed? How many of them are open? Your task is write a program to output How many doors are open after the last pass? Assumptions all doors are closed at first. 输入 a positive numbers n, total doors. n&lt;=100000 输出 a positive numbers ，the total of doors opened after the last pass. 样例输入 10 样例输出 3 题目解读翻译 假设走廊上有n把锁，标号为0~n，全部都是锁上的，现在你经过走廊n次，第一次把1的倍数（1,2,3…）的锁打开，第二次把2的倍数（2,4,6…）的锁打开，如果已经打开了就关上，第三次对3的倍数的锁进行类似的操作。请问最后有几把锁是开着的？ 策略 直白的来看，就是从1到n，求每个数的公因数的个数（比如数字6，有1,2,3,6四个公因数，经过4次操作后就是关闭的状态），但是如果循环求n次公因数的个数，就会超时…… 换个角度想一想，什么样的数会有奇数个公因子呢？只有遇到1x1, 2x2, 3x3，… 才会出现奇数个公因子，所以只需要求$\sqrt{n}$的整数部分就可以啦！ 代码 123456789101112#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); int sum=sqrt(n); printf("%d\n",sum); return 0;&#125; The Josephus ProblemThe problem is named after Flavius Josephus, a Jewish historian who participated in and chronicled the Jewish revolt of 66-70C.E. against the Romans. Josephus, as a general, managed to hold the fortress of Jotapata for 47days, but after the fall of the city he took refuge with 40 diehards in a nearby cave. There the rebels voted to perish rather than surrender. Josephus proposed that each man in turn should dispatch his neighbor, the order to be determined by casting lots. Josephus contrived to draw the last lot, and as one of the two surviving men in the cave, he prevailed upon his intended victim to surrender to the Romans. Your task:computint the position of the survivor when there are initially n people. 输入 a Positive Integer n is initially people. n&lt; = 50000 输出 the position of the survivor 样例输入 6 样例输出 5 题目解读翻译 n个人围成一圈报数，报到2的人就会死掉，然后下一个人再接着从1开始报数，直到最后剩下一个人活着，请问最开始应该在几号位才能活到最后？ 策略 一种方法就是模拟，定义一个数组，从1到n全部置为1，对应编号的人死掉就置为0，用另一个数组表示当前报数的数字，等于2时，就从头再来。 还有一种公式法，循环取模。 代码 模拟法 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int n,i; scanf("%d",&amp;n); int s=0,t=0,count=0; int a[50005]=&#123;0&#125;; while(1) &#123; t++; if(t&gt;n) t=1; if(a[t]==0) s++; if(s==2) &#123; s=0; count++; a[t]=1; &#125; if(count==n-1) break; &#125; for(i=1;i&lt;=n;i++) &#123; if(a[i]==0) printf("%d\n",i); &#125; return 0;&#125; 公式法 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int josephus(int n, int m)&#123; int i; int sum=0; for(i=1;i&lt;=n;i++) &#123; sum=(sum+m)%i; &#125; return sum+1;&#125;int main()&#123; int n; scanf("%d",&amp;n); int ans=josephus(n,2); printf("%d\n",ans); return 0;&#125; Binary searchA binary search algorithm (or binary chop) is a technique for finding a particular value in a sorted list. It makes progressively better guesses, and closes in on the sought value, by comparing an element halfway with what has been determined to be an element too low in the list and one too high in the list. A binary search finds the median element in a list, compares its value to the one you are searching for, and determines if it’s greater than, less than, or equal to the one you want. A guess that turns out to be too high becomes the new top of the list, and one too low the new bottom of the list. The binary search’s next guess is halfway between the new list’s top and bottom. Pursuing this strategy iteratively, it narrows the search by a factor 2 each time, and finds your value. A binary search is an example of a divide and conquer algorithm (more specifically a decrease and conquer algorithm) and a dichotomic search (more at Search algorithm). The most common application of binary search is to find a specific value in a sorted list. To cast this in the frame of the guessing game (see Example below), realize that we are now guessing the index, or numbered place, of the value in the list. This is useful because, given the index, other data structures will contain associated information. Suppose a data structure containing the classic collection of name, address, telephone number and so forth has been accumulated, and an array is prepared containing the names, numbered from one to N. A query might be: what is the telephone number for a given name X. To answer this the array would be searched and the index (if any) corresponding to that name determined, whereupon it would be used to report the associated telephone number and so forth. Appropriate provision must be made for the name not being in the list (typically by returning an index value of zero), indeed the question of interest might be only whether X is in the list or not. If the list of names is in sorted order, a binary search will find a given name with far fewer probes than the simple procedure of probing each name in the list, one after the other in a linear search, and the procedure is much simpler than organising a hash table though that would be faster still, typically averaging just over one probe. This applies for a uniform distribution of search items but if it is known that some few items are much more likely to be sought for than the majority then a linear search with the list ordered so that the most popular items are first may do better. The binary search begins by comparing the sought value X to the value in the middle of the list; because the values are sorted, it is clear whether the sought value would belong before or after that middle value, and the search then continues through the correct half in the same way. Only the sign of the difference is inspected: there is no attempt at an interpolation search based on the size of the differences. Your task is to write a program that, given a set numbers of ascending and a key, finding a particular postion in a sorted list. 输入 The input contains one total numbers（N&lt;=5000000） and a find key,followed by a line containing the integer numbers ascending sets. 输出 if find the key in the sorted list, output containing postion in a sorted list, else ouput -1. 样例输入 10 7 0 1 2 3 4 5 6 7 8 9 样例输出 8 题目解读翻译 二分搜索（折半查找）：是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 特别注意 数组要开到5000005，写在函数外面，用iostream，c++提交。 代码 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int num[5000005];int binary(int n,int key)&#123; int first=0,last=n,mid; while(first&lt;=last) &#123; mid=(first+last)/2; if(num[mid]&gt;key) last=mid-1; if(num[mid]&lt;key) first=mid+1; if(num[mid]==key) return mid+1; &#125; return -1;&#125;int main()&#123; int n,i,key; scanf("%d %d",&amp;n,&amp;key); for(i=0;i&lt;n;i++) &#123; scanf("%d",&amp;num[i]); &#125; int ans=binary(n-1,key); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TF在MNIST中的应用]]></title>
    <url>%2F2018%2F04%2F18%2FTF%E5%9C%A8MNIST%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[TensorFlow在MNIST中的应用MNIST数据集简介常用的函数API r1.5tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(logits=prediction, labels=y))tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)tf.layers.conv2d(x_image, 32, 5, 1, ‘same’, activation=tf.nn.relu)tf.layers.max_pooling2d(conv1, 2, 2)tf.layers.dense(flat,10)tf.layers.dropout(output)]]></content>
  </entry>
</search>
